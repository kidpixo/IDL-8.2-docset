<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns:madcap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" madcap:lastblockdepth="2" madcap:lastheight="135.6667" madcap:lastwidth="592" madcap:disablemasterstylesheet="true" madcap:tocpath="IDL Programming|Concepts" madcap:medium="non-print" madcap:inpreviewmode="false" madcap:preloadimages="false" madcap:runtimefiletype="Topic" madcap:targettype="WebHelp" lang="en-US" xml:lang="en-US" madcap:pathtohelpsystem="../../" madcap:helpsystemfilename="idl.xml" madcap:searchtype="Stem">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>
   Supported Devices
  </title>
  <link href="../SkinSupport/MadCap.css" rel="stylesheet" />
  <link href="../Resources/TableStyles/Description.css" rel="stylesheet" />
  <link href="../Resources/Stylesheets/IDL_style.css" rel="stylesheet" />
  <script src="../SkinSupport/MadCapAll.js" type="text/javascript">
  </script>
 </head>
 <body>
  <p class="MCWebHelpFramesetLink" style="display: none;">
   <a href="../../idl_CSH.html#Direct Graphics/Supported_Devices.html" style="">
    Open topic with navigation
   </a>
  </p>
  <div class="MCBreadcrumbsBox_0">
   <span class="MCBreadcrumbsPrefix">
    <![CDATA[ ]]>
   </span>
   <a class="MCBreadcrumbsLink" href="../IDL Programming.html">
    IDL Programming
   </a>
   <span class="MCBreadcrumbsDivider">
    &gt;
   </span>
   <a class="MCBreadcrumbsLink" href="../ProgrammingConcepts.html">
    Concepts
   </a>
   <span class="MCBreadcrumbsDivider">
    &gt;
   </span>
   <span class="MCBreadcrumbs">
    Supported Devices
   </span>
  </div>
  <h1>
   <a name="devices_517620971_568277">
   </a>
   <a name="devices_517620971_76724">
   </a>
   Supported Devices
  </h1>
  <p>
   IDL Direct Graphics support
   <a name="kanchor3518">
   </a>
   graphic output to the devices listed below:
  </p>
  <table style="caption-side: bottom;mc-table-style: url('../Resources/TableStyles/Description.css');margin-left: 0;margin-right: auto;" cellspacing="0" class="TableStyle_Description">
   <caption>
    IDL Graphics Output Devices
   </caption>
   <col />
   <col />
   <thead>
    <tr>
     <td class="TableStyle_Description_Head_0_0_RowSep_ColSep">
      <p>
       Device Name
      </p>
     </td>
     <td class="TableStyle_Description_Head_0_0_RowSep_ColEnd">
      <p>
       Description
      </p>
     </td>
    </tr>
   </thead>
   <tbody>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      <p>
       <a href="#CGM">
        CGM
       </a>
       <![CDATA[
]]>
      </p>
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      <p>
       <a name="kanchor3519">
       </a>
       Computer Graphics Metafile
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
      <p>
       <a href="#HP-GL">
        HP
       </a>
       <![CDATA[
]]>
      </p>
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
      <p>
       <a name="kanchor3520">
       </a>
       Hewlett-Packard Graphics Language (HP-GL)
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      <p>
       <a href="#Metafile">
        METAFILE
       </a>
       <![CDATA[
]]>
      </p>
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      <p>
       <a name="kanchor3521">
       </a>
       Windows Metafile Format (WMF)
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
      <p>
       <a href="#NULL">
        NULL
       </a>
       <![CDATA[
]]>
      </p>
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
      <p>
       No graphics output
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      <p>
       <a href="#PCL">
        PCL
       </a>
       <![CDATA[
]]>
      </p>
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      <p>
       <a name="kanchor3522">
       </a>
       Hewlett-Packard Printer Control Language (PCL)
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
      <p>
       <a href="#Printer">
        PRINTER
       </a>
       <![CDATA[
]]>
      </p>
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
      <p>
       System
       <a name="kanchor3523">
       </a>
       printer
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      <p>
       <a href="#PostScri">
        PS
       </a>
       <![CDATA[
]]>
      </p>
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      <p>
       <a name="kanchor3524">
       </a>
       PostScript
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
      <p>
       <a href="#Microsof">
        WIN
       </a>
       <![CDATA[
]]>
      </p>
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
      <p>
       <a name="kanchor3525">
       </a>
       Microsoft Windows
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      <p>
       <a href="#X">
        X
       </a>
       <![CDATA[
]]>
      </p>
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      <p>
       <a name="kanchor3526">
       </a>
       X Window System
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowEnd_ColSep">
      <p>
       <a href="#Z-Buffer">
        Z
       </a>
       <![CDATA[
]]>
      </p>
     </td>
     <td class="TableStyle_Description_Body_1_0_RowEnd_ColEnd">
      <p>
       <a name="kanchor3527">
       </a>
       Z-buffer pseudo device
      </p>
     </td>
    </tr>
   </tbody>
  </table>
  <p>
   The
   <a href="../Reference Material/S/SET_PLOT_Procedure.html">
    SET_PLOT
   </a>
   procedure can be used to select the graphic device to which IDL directs its output. IDL Object Graphics does not rely on the concept of a current graphics device.
  </p>
  <p>
   The
   <a name="kanchor3528">
   </a>
   <a href="../Reference Material/D/DEVICE_Procedure.html">
    DEVICE procedure
   </a>
   controls the graphic device-specific functions. An attempt has been made to isolate all device-specific functions in this procedure. DEVICE controls the graphics device currently selected by
   <a name="kanchor3529">
   </a>
   SET_PLOT. When using DEVICE, it is important to make sure that the current graphics device is the one you intend to use. This is because most of the devices have different keywords—you will most likely get a
   <span class="Courier">
    Keyword ... ... not allowed in call to: Device
   </span>
   error if you call DEVICE when the wrong device is selected.
  </p>
  <h2 class="API">
   <a name="CGM">
   </a>
   CGM
  </h2>
  <p>
   The CGM, Computer Graphics Metafile, standard describes a device independent file format used for the exchange of graphic information. The IDL CGM driver produces CGM files encoded in one of three methods: Text, Binary or NCAR Binary. To direct graphics output to a CGM file, issue the command:
  </p>
  <p class="Code">
   SET_PLOT,'CGM'
  </p>
  <p>
   This causes IDL to use the CGM driver for producing graphical output. Once the CGM driver is selected, the DEVICE procedure controls its actions, as described below. Typing HELP, /DEVICE displays the current state of the CGM driver. The CGM driver defaults to the binary encoding using 256 colors.
  </p>
  <p>
   See
   <a href="Keywords_Accepted_by_the.html#Keywords">
    keywords accepted by display devices.
   </a>
  </p>
  <h3>
   Abilities and Limitations
  </h3>
  <p>
   This section describes details specific to IDL’s CGM implementation:
  </p>
  <ul>
   <li value="1">
    IDL uses the CGM default integer encoding for graphic primitives. Coordinate values range from 0 to 32767. It is advisable to use the values stored in !D.X_SIZE and !D.Y_SIZE instead of assuming a fixed coordinate range.
   </li>
   <li value="2">
    Color information is output with a resolution of 8 bits (color indices and intensity values range from 0 to 255).
   </li>
   <li value="3">
    The definition of background color in the CGM standard is somewhat ambiguous. According to the standard, color index 0 and the background color are the same. Because background color is specified in the metafile as a color value (RGB triple), not an index, it is possible to have the background color not correspond with the color value of index 0.
   </li>
   <li value="4">
    The CGM BACKGROUND_COLOUR attribute is explicitly set by IDL only during an erase operation: changing the value of the color map at index 0 does not cause IDL to generate a BACKGROUND_COLOUR attribute until the next ERASE occurs. An ERASE command sets the background color to the value in the color map at index 0. The command ERASE, INDEX (where INDEX is not 0) generates the message “Value of background color is out of allowed range.” For consistent results, modify the color table before any graphics are output.
   </li>
   <li value="5">
    The CGM standard uses scalable (variable size) pixels for raster images. By default, the TV and TVSCL procedures output images, regardless of size, using the entire graphics output area. To output an image smaller than the graphics output area, specify the XSIZE and YSIZE keywords with the TV and TVSCL procedures. For example:
   </li>
  </ul>
  <p class="Code">
   ; Select the CGM driver:
  </p>
  <p class="Code">
   SET_PLOT, 'CGM'
  </p>
  <p class="Code">
   ; Create a 64 x 64 element array:
  </p>
  <p class="Code">
   X = DIST(64)
  </p>
  <p class="Code">
   ; Display the image (fills entire screen):
  </p>
  <p class="Code">
   TVSCL, X
  </p>
  <p class="Code">
   ; Now display 4 images on the screen:
  </p>
  <p class="Code">
   ERASE
  </p>
  <p class="Code">
   XS = !D.X_SIZE / 2 ; Size of each image, X dimension
  </p>
  <p class="Code">
   YS = !D.Y_SIZE / 2 ; Size of each image, Y dimension
  </p>
  <p class="Code">
   TVSCL, X, 0, XSIZE=XS, YSIZE=YS ; Upper left
  </p>
  <p class="Code">
   TVSCL, X, 1, XSIZE=XS, YSIZE=YS ; Upper right
  </p>
  <p class="Code">
   TVSCL, X, 2, XSIZE=XS, YSIZE=YS ; Lower left
  </p>
  <p class="Code">
   TVSCL, X, 3, XSIZE=XS, YSIZE=YS ; Lower right
  </p>
  <h2 class="API">
   <a name="HP-GL">
   </a>
   HP-GL
  </h2>
  <p>
   HP-GL (Hewlett-Packard Graphics Language) is a plotter control language used to produce graphics on a wide family of pen plotters. To use HP-GL as the current graphics device, issue the IDL command:
  </p>
  <p class="Code">
   SET_PLOT,'HP'
  </p>
  <p>
   See
   <a href="Keywords_Accepted_by_the.html#Keywords">
    keywords accepted by display devices.
   </a>
  </p>
  <h2 class="API">
   <a name="Metafile">
   </a>
   Metafile
  </h2>
  <p>
   The Windows Metafile Format (WMF) is used by Windows to store vector graphics in order to exchange graphics information between applications. This format is only available on the Windows platforms. To direct graphics to a file in the WMF format, use the SET_PLOT procedure:
  </p>
  <p class="Code">
   SET_PLOT, 'METAFILE'
  </p>
  <p>
   See
   <a href="Keywords_Accepted_by_the.html#Keywords">
    keywords accepted by display devices.
   </a>
  </p>
  <p>
   For example, the following will create a WMF file for a simple plot:
  </p>
  <p class="Code">
   ;Create X and Y Axis data
  </p>
  <p class="Code">
   x=findgen(10)
  </p>
  <p class="Code">
   y=findgen(10)
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ;Save current device name
  </p>
  <p class="Code">
   mydevice=!D.NAME
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ;Set the device to Metafile
  </p>
  <p class="Code">
   SET_PLOT, 'METAFILE'
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ;Name the file to be created
  </p>
  <p class="Code">
   DEVICE, FILE='test.emf'
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ;Create the plot
  </p>
  <p class="Code">
   PLOT, x, y
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ;Close the device which creates the Metafile
  </p>
  <p class="Code">
   DEVICE, /CLOSE
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ;Set the device back to the original
  </p>
  <p class="Code">
   SET_PLOT, mydevice
  </p>
  <h2 class="API">
   <a name="NULL">
   </a>
   NULL
  </h2>
  <p>
   To suppress graphics output entirely, use the null device:
  </p>
  <p class="Code">
   SET_PLOT, 'NULL'
  </p>
  <h2 class="API">
   <a name="PCL">
   </a>
   PCL
  </h2>
  <p>
   PCL (Printer Control Language) is used by Hewlett-Packard laser and ink jet printers to produce graphics output. To direct graphics output to a PCL file, issue the command:
  </p>
  <p class="Code">
   SET_PLOT,'PCL'
  </p>
  <p>
   See
   <a href="Keywords_Accepted_by_the.html#Keywords">
    keywords accepted by display devices.
   </a>
  </p>
  <h2 class="API">
   <a name="Printer">
   </a>
   Printer
  </h2>
  <p>
   The PRINTER device allows IDL Direct Graphics to be output to a system printer. To direct graphics output to a printer, issue the command:
  </p>
  <p class="Code">
   SET_PLOT, 'printer'
  </p>
  <p>
   See
   <a href="Keywords_Accepted_by_the.html#Keywords">
    keywords accepted by display devices.
   </a>
  </p>
  <p>
   Note that the printer device is an IDL Direct Graphics device. Like other Direct Graphics devices, you must change to the new device and then issue the IDL commands that send output to that device. With the printer device, you must use the CLOSE_DOCUMENT keyword to the DEVICE routine to actually initiate the print job and make something come out of your printer.
  </p>
  <h2 class="API">
   <a name="PostScri">
   </a>
   PostScript
  </h2>
  <p>
   PostScript is a programming language designed to convey a description of a page containing text and graphics. Many laser printers and high-resolution, high-quality photo typesetters support PostScript. Color output or direct color separations can be produced with color PostScript. To direct graphics output to a PostScript file, issue the command:
  </p>
  <p class="Code">
   SET_PLOT, 'PS'
  </p>
  <p>
   See
   <a href="Keywords_Accepted_by_the.html#Keywords">
    keywords accepted by display devices.
   </a>
  </p>
  <p>
   This causes IDL to use the PostScript driver for producing graphical output. Once the PostScript driver is enabled via SET_PLOT, the DEVICE procedure is used to control its actions, as described below. The default PostScript settings are given in the following table:
  </p>
  <table class="TableStyle_Description" style="margin-left: 0;margin-right: auto;caption-side: top;mc-table-style: url('../Resources/TableStyles/Description.css');" cellspacing="0">
   <col />
   <col />
   <thead>
    <tr>
     <th class="TableStyle_Description_Head_0_0_RowSep_ColSep">
      <p>
       Feature
      </p>
     </th>
     <th class="TableStyle_Description_Head_0_0_RowSep_ColEnd">
      <p>
       Value
      </p>
     </th>
    </tr>
   </thead>
   <tbody>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      <p>
       File
      </p>
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      <p>
       idl.ps
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
      <p>
       Mode
      </p>
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
      <p>
       Portrait, non-encapsulated, no color
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      <p>
       Horizontal offset
      </p>
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      <p>
       3/4 in.
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
      <p>
       Vertical offset
      </p>
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
      <p>
       5 in.
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      <p>
       Width
      </p>
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      <p>
       7 in.
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
      <p>
       Height
      </p>
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
      <p>
       5 in.
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      <p>
       Scale factor
      </p>
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      <p>
       1.0
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
      <p>
       Font size
      </p>
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
      <p>
       12 points
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      <p>
       Font
      </p>
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      <p>
       Helvetica
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowEnd_ColSep">
      <p>
       # Bits / Image Pixel
      </p>
     </td>
     <td class="TableStyle_Description_Body_1_0_RowEnd_ColEnd">
      <p>
       4
      </p>
     </td>
    </tr>
   </tbody>
  </table>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   Unlike monitors where white is the most visible color, PostScript writes black on white paper. Setting the output color index to 0, the default when PostScript output is selected, writes black. A color index of 255 writes white which is invisible on white paper. Color tables are not used with PostScript unless the color mode has been enabled using the DEVICE procedure. See Indexed Color Images, below.
  </p>
  <p>
   To obtain adequate resolution, the device coordinate system used for PostScript output is expressed in units of 0.001 centimeter (i.e., 1000 pixels/cm).
  </p>
  <p>
   Use the HELP, /DEVICE call to view the current font, file, and other options set for PostScript output.
  </p>
  <h3>
   Using PostScript Fonts
  </h3>
  <p>
   Information necessary for rendering a set of 35 standard PostScript fonts are included with IDL. (The standard 35 fonts are the fonts found on the Apple Laserwriter II PostScript printer; the same fonts are found on almost any PostScript printer made in the time since the LaserWriter II appeared.)
  </p>
  <h4>
   Color PostScript
  </h4>
  <p>
   If you have a color PostScript device you can enable the use of either indexed color or TrueColor for plotting.
  </p>
  <h4>
   Indexed Color Plots
  </h4>
  <p>
   Set the PostScript device to use indexed color with the statement:
  </p>
  <p class="Code">
   DEVICE, DECOMPOSED=0, COLOR=1
  </p>
  <p>
   In indexed color mode, color values are interpreted as indices into IDL’s current color table. For example, to draw a plot using the color specified by color index 160, use a statement like:
  </p>
  <p class="Code">
   PLOT, INDGEN(10), COLOR = 160
  </p>
  <h4>
   TrueColor Plots
  </h4>
  <p>
   Set the PostScript device to use 24-bit color (often referred to as TrueColor) with the statement:
  </p>
  <p class="Code">
   DEVICE, DECOMPOSED=1, COLOR=1
  </p>
  <p>
   In Decomposed color mode, 24-bit color specifications are interpreted as three 8-bit color values, where the least-significant 8 bits contain the red value, the next 8 bits contain the green value, and the most-significant 8 bits contain the blue value. 24-bit color values are most commonly specified using hexidecimal notation, in which the blue, green, and red values are encoded in a string with the following format:
  </p>
  <p class="Code">
   'bbggrr'x
  </p>
  <p>
   where bb is a hexidecimal number specifying the blue value, gg is a hexidecimal number specifying the green value, and rr is a hexidecimal number specifying the red value.
  </p>
  <p>
   For example, to draw a plot using pure blue on a device that uses 24-bit color, use the following statement:
  </p>
  <p class="Code">
   PLOT, INDGEN(10), COLOR = 'FF0000'x
  </p>
  <h4>
   Indexed Color Images
  </h4>
  <p>
   Set the PostScript device to use color with the statement:
  </p>
  <p>
   DEVICE, COLOR=1, BITS_PER_PIXEL=n
  </p>
  <p>
   where the value of the BITS_PER_PIXEL keyword can be 1, 2, 4, or 8 bits, yielding 2, 4, 16, or 256 possible colors. In an indexed color image, each pixel value is used as an index into the current color table, thereby obtaining an RGB value for each possible pixel value. To allow pixels in the image to map to a full 256-entry color table, specify BITS_PER_PIXEL=8.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   In the case of indexed color images of fewer than 8 bits, the number of columns in the image should be an exact multiple of the number of pixels per byte (i.e., when displaying 4 bit images the number of columns should be even, and 2 bit images should have a column size that is a multiple of 4). If the image column size is not an exact multiple, extra pixels with a value of 255 are output at the end of each row. This causes no problems if the color white is loaded into the last color table entry, otherwise a stripe of the last (index 255) color is drawn to the right of the image.
  </p>
  <h4>
   TrueColor Images
  </h4>
  <p>
   Set the PostScript device to use color with the statement:
  </p>
  <p class="Code">
   DEVICE, COLOR=1, BITS_PER_PIXEL=8
  </p>
  <p>
   A TrueColor image consists of an array with three dimensions, one of which has a size of three, containing the three color components. It may be considered as three two dimensional images, one each for the red, green and blue components. Each two-dimensional channel uses eight bits per pixel, which combine to create the 24-bit (TrueColor) image.
  </p>
  <p>
   Use the TRUE keyword to the TV and TVSCL procedures to indicate that the image is a TrueColor image and to specify the dimension over which color is interleaved. RGB data can be interleaved by pixel, by line, or by image. Use the TRUE keyword to specify the method of interleaving. A c column by l line TrueColor image is dimensioned as follows:
  </p>
  <table class="TableStyle_Description" style="caption-side: bottom;margin-left: 0;margin-right: auto;mc-table-style: url('../Resources/TableStyles/Description.css');" cellspacing="0">
   <caption>
    Values for the TRUE Keyword to TV and TVSCL
   </caption>
   <col />
   <col />
   <col />
   <thead>
    <tr>
     <th class="TableStyle_Description_Head_0_0_RowSep_ColSep">
      <p>
       TRUE Value
      </p>
     </th>
     <th class="TableStyle_Description_Head_0_0_RowSep_ColSep">
      <p>
       Dimensions
      </p>
     </th>
     <th class="TableStyle_Description_Head_0_0_RowSep_ColEnd">
      <p>
       Interleaving
      </p>
     </th>
    </tr>
   </thead>
   <tbody>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      <p>
       1
      </p>
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      <p>
       (3, c, l)
      </p>
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      <p>
       Pixel
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
      <p>
       2
      </p>
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
      <p>
       (c, 3, l)
      </p>
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
      <p>
       Line or Row
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowEnd_ColSep">
      <p>
       3
      </p>
     </td>
     <td class="TableStyle_Description_Body_0_0_RowEnd_ColSep">
      <p>
       (c, l, 3)
      </p>
     </td>
     <td class="TableStyle_Description_Body_0_0_RowEnd_ColEnd">
      <p>
       Image
      </p>
     </td>
    </tr>
   </tbody>
  </table>
  <p>
   The following example writes a 24-bit image, interleaved over the first dimension, to a PostScript file:
  </p>
  <p class="Code">
   ; Save the original graphics device.
  </p>
  <p class="Code">
   old_device = !D.NAME
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Change to the PostScript device.
  </p>
  <p class="Code">
   SET_PLOT, 'PS'
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Specify an output filename.
  </p>
  <p class="Code">
   outfile = DIALOG_PICKFILE(FILE='24bit.ps', /WRITE, $
  </p>
  <p class="Code_Indented">
   PATH=GETENV('IDL_TMPDIR'))
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Set the PostScript device to create the output file in
  </p>
  <p class="Code">
   ; color. Use *8* bits per pixel, not 24.
  </p>
  <p class="Code">
   DEVICE, FILE=outfile, /COLOR, BITS_PER_PIXEL=8
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Get some truecolor image data.
  </p>
  <p class="Code">
   image = READ_IMAGE(FILEPATH('rose.jpg', SUBDIRECTORY=['examples', 'data']))
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Write the 24-bit image and close the file.
  </p>
  <p class="Code">
   TV, image, TRUE=1
  </p>
  <p class="Code">
   DEVICE, /CLOSE
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Return plotting to the original graphics device:
  </p>
  <p class="Code">
   SET_PLOT, old_device
  </p>
  <p>
   Unlike TrueColor plots using the DECOMPOSED keyword, TrueColor images are routed through IDL’s color tables. The red color table array contains the intensity translation table for the red image, and so forth. Assuming that the color tables have been loaded with the vectors R, G, and B, a pixel with a color value of (r, g, b) is displayed with a color of (Rr, Gg, Bb). As with other devices, a color table value of 255 represents maximum intensity, while 0 indicates an absence of the color. To pass the RGB pixel values without change, load the red, green and blue color tables with a ramp with a slope of 1.0:
  </p>
  <p class="Code">
   TVLCT, INDGEN(256), INDGEN(256), INDGEN(256)
  </p>
  <p>
   or with the LOADCT procedure:
  </p>
  <p class="Code">
   ; Load standard black/white table:
  </p>
  <p class="Code">
   LOADCT, 0
  </p>
  <h4>
   Image Background Color
  </h4>
  <p>
   Images that are displayed with a black background on a monitor frequently look better if the background is changed to white when displayed with PostScript. This is easily done with the statement:
  </p>
  <p class="Code">
   a(WHERE(a EQ 0B)) = 255B
  </p>
  <h4>
   CMYK Output
  </h4>
  <p>
   When the CMYK keyword is set, IDL converts the PostScript output to the CMYK color model as a final step. The indexed or RGB data is mapped to the cyan, magenta, yellow, and black color model just prior to output.
  </p>
  <p>
   The CMYK format is a subtractive color model that is better suited for color printing. This color model allows some document processing applications and printer control software to easily adjust the overall brightness of an image by manipulating a single channel (K). PostScript files created with the CMYK color model must be processed by an interpreter capable of interpreting PostScript Language Level 2 or higher.
  </p>
  <h3>
   PostScript Positioning
  </h3>
  <h4>
   Using the XOFFSET and YOFFSET Keywords
  </h4>
  <p>
   Often, IDL users are confused by the use of the XOFFSET and YOFFSET keywords to the PostScript DEVICE routine. These keywords control the position of IDL plots on the page. XOFFSET specifies the “X” position of the lower left corner of the output generated by IDL. This offset is always taken relative to the lower left-hand corner of the page when viewed in portrait orientation. YOFFSET specifies the “Y” position of the lower left corner of the output generated by IDL. This offset is also taken relative to the lower left-hand corner of the page when viewed in portrait orientation.
  </p>
  <p>
   The following figure shows how the XOFFSET and YOFFSET keywords are interpreted by the PostScript device in the Portrait (left) and Landscape (right) modes. Note that the landscape plot uses the same origin for determining the effect of the XOFFSET and YOFFSET keywords, but that the output is rotated 270 degrees clockwise.
  </p>
  <p>
   <img src="../Resources/Images/device_frame.gif" />
  </p>
  <p class="FigureTitle">
   Interpretation of the XOFFSET and YOFFSET Keywords
  </p>
  <p>
   The page on the left shows an IDL plot printed in “portrait” orientation. Note that the X and Y offsets work just as we expect them to—increasing the XOFFSET moves the plot to the right and increasing the YOFFSET moves the plot up the page. The page on the right shows an IDL plot printed in “landscape” orientation. Here, the X and Y offsets are still taken relative to the same points even though the orientation of the plot has changed. This happens because IDL moves the origin of the plot before rotating the PostScript coordinate system 270 degrees clockwise for the landscape plot.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   The XOFFSET and YOFFSET keywords have no effect when you generate ENCAPSULATED PostScript output.
  </p>
  <h4>
   Encapsulated PostScript Output
  </h4>
  <p>
   Another form of PostScript output is Encapsulated PostScript. This is the format used to import PostScript files into page layout and desktop publishing programs. An Encapsulated PostScript (EPS) file is similar to a regular PostScript file except that it contains only one page of PostScript output contained in a “bounding box” that is used to tell other programs about the size and aspect ratio of the encapsulated image.
  </p>
  <p>
   Most of the time, output from IDL to an EPS file is properly scaled into the EPS bounding box because commands such as PLOT take full advantage of the plotting area made available to them. Sometimes, however, the default bounding box is inappropriate for the image being displayed.
  </p>
  <p>
   As an example, suppose you have an image that is narrow and tall that, when TV’ed to an IDL window, fills only a small portion of the plotting window. Similarly, when output to an EPS file, this image will only fill a small portion of the bounding box. When the resulting EPS file is brought into a desktop publishing program, it becomes very hard to properly scale the image since the aspect ratio of the bounding box bears no relation to the aspect ratio of the image itself.
  </p>
  <p>
   To solve this problem, use the XSIZE and YSIZE keywords to the DEVICE procedure to make the bounding box just large enough to contain the image. Since IDL uses a resolution of 1000 dots per centimeter with the PostScript device, the correct XSIZE and YSIZE (in centimeters) can be computed as:
  </p>
  <ul>
   <li value="1">
    XSIZE = Width of image in pixels/1000.0 pixels per cm
   </li>
   <li value="2">
    YSIZE = Height of image in pixels/1000.0 pixels per cm
   </li>
  </ul>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   The values of XSIZE and YSIZE for this device are effectively limited to a maximum of 11 inches due to the size of the memory map employed to render the graphics information.
  </p>
  <p>
   The following IDL procedure demonstrates this technique. This procedure reads an X Windows Dump file and writes it back out as a properly-sized, 8-bit-color Encapsulated PostScript file:
  </p>
  <p class="Code">
   PRO XWDTOEPS, filename
  </p>
  <p class="Code_Indented">
   ; Read the XWD file. Pixel intensity information is stored
  </p>
  <p class="Code_Indented">
   ; in the variable 'array'. Values to reconstruct the color
  </p>
  <p class="Code_Indented">
   ; table are stored in 'r', 'g', and 'b':
  </p>
  <p class="Code_Indented">
   array = READ_XWD(filename, r, g, b)
  </p>
  <p class="Code_Indented">
   &#160;
  </p>
  <p class="Code_Indented">
   ; Reconstruct the color table:
  </p>
  <p class="Code_Indented">
   TVLCT, r,g,b
  </p>
  <p class="Code_Indented">
   &#160;
  </p>
  <p class="Code_Indented">
   ; Display the image in an IDL window:
  </p>
  <p class="Code_Indented">
   TV, array
  </p>
  <p class="Code_Indented">
   &#160;
  </p>
  <p class="Code_Indented">
   ; Find the size of the picture. The width of the picture
  </p>
  <p class="Code_Indented">
   ; (in pixels) is stored in s[1]. The height of the picture
  </p>
  <p class="Code_Indented">
   ; is stored in s[2]:
  </p>
  <p class="Code_Indented">
   s = SIZE(array)
  </p>
  <p class="Code_Indented">
   &#160;
  </p>
  <p class="Code_Indented">
   ; Take the 'xwd' (for X Windows Dump) extension off of
  </p>
  <p class="Code_Indented">
   ; the old filename and replace it with 'eps':
  </p>
  <p class="Code_Indented">
   fl = STRLEN(filename)
  </p>
  <p class="Code_Indented">
   filename = STRMID(filename, 0, fl-4)
  </p>
  <p class="Code_Indented">
   filename = filename + '.eps'
  </p>
  <p class="Code_Indented">
   PRINT, 'Making file: ', filename
  </p>
  <p class="Code_Indented">
   PRINT, s
  </p>
  <p class="Code_Indented">
   &#160;
  </p>
  <p class="Code_Indented">
   ; Set the plotting device to PostScript:
  </p>
  <p class="Code_Indented">
   SET_PLOT, 'ps'
  </p>
  <p class="Code_Indented">
   &#160;
  </p>
  <p class="Code_Indented">
   ; Use the DEVICE procedure to make the output encapsulated,
  </p>
  <p class="Code_Indented">
   ; 8 bits, color, and only as wide and high as it needs to
  </p>
  <p class="Code_Indented">
   ; be to contain the XWD image:
  </p>
  <p class="Code_Indented">
   DEVICE, /ENCAPSUL, BITS_PER_PIXEL=8, /COLOR, $
  </p>
  <p class="Code_Indented">
   &#160;&#160;FILENAME=filename, XSIZE=S[1]/1000., $
  </p>
  <p class="Code_Indented">
   &#160;&#160;YSIZE=S[2]/1000.
  </p>
  <p class="Code_Indented">
   &#160;
  </p>
  <p class="Code_Indented">
   ; Write the image to the file:
  </p>
  <p class="Code_Indented">
   TV, array
  </p>
  <p class="Code_Indented">
   &#160;
  </p>
  <p class="Code_Indented">
   ; Close the file:
  </p>
  <p class="Code_Indented">
   DEVICE, /CLOSE
  </p>
  <p class="Code_Indented">
   &#160;
  </p>
  <p class="Code_Indented">
   ; Return plotting to X Windows:
  </p>
  <p class="Code_Indented">
   SET_PLOT, 'x'
  </p>
  <p class="Code">
   END
  </p>
  <h4>
   Multiple Plots on the Same Page
  </h4>
  <p>
   To put multiple plots on the same PostScript page, use the !P.MULTI system variable (described in more detail in
   <a href="Graphics_System_Variable.html#!P">
    !P
   </a>
   ). !P.MULTI is a 5-element integer array that controls the number of rows and columns of plots to make on a page or in a graphics window.
  </p>
  <p>
   The first element of !P.MULTI is a counter that reports how many plots remain on the page. The second element of !P.MULTI is the number of columns per page. The third element is the number of rows per page.
  </p>
  <p>
   For example, the following lines of code create a PostScript file,
   <code>
    multi.ps
   </code>
   , with 6 different plots arranged as 2 columns and 3 rows:
  </p>
  <p class="Code">
   ; Set plotting to PostScript:
  </p>
  <p class="Code">
   SET_PLOT, 'PS'
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Set the filename:
  </p>
  <p class="Code">
   DEVICE, FILENAME='multi.ps'
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Make IDL’s plotting area hold 2 columns and 3 rows of plots:
  </p>
  <p class="Code">
   !P.MULTI = [0, 2, 3]
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Create a simple dataset:
  </p>
  <p class="Code">
   A = FINDGEN(10)
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Make 6 different plots:
  </p>
  <p class="Code">
   PLOT, A
  </p>
  <p class="Code">
   PLOT, SIN(A)
  </p>
  <p class="Code">
   PLOT, COS(A)
  </p>
  <p class="Code">
   PLOT, TAN(A)
  </p>
  <p class="Code">
   PLOT, TANH(A)
  </p>
  <p class="Code">
   PLOT, SINH(A)
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Close the file:
  </p>
  <p class="Code">
   DEVICE, /CLOSE
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Return plotting to Windows:
  </p>
  <p class="Code">
   SET_PLOT, 'win'
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Reset plotting to 1 plot per page:
  </p>
  <p class="Code">
   !P.MULTI = 0
  </p>
  <p>
   The resulting file produces a set of plots as shown in the following figure:
  </p>
  <p>
   <img src="../Resources/Images/devices1.gif" />
  </p>
  <p class="FigureTitle">
   Multiple plots on a single page produced by setting the !P.MULTI system variable.
  </p>
  <h3>
   Importing IDL Plots into Other Documents
  </h3>
  <p>
   This section shows how to generate IDL PostScript graphics so that they can be inserted into other documents. It also provides several examples of how the PostScript graphics device is used. Simply omit the ENCAPSULATED keyword from the calls to DEVICE if you wish to produce plots that can be printed directly. The following figure is an encapsulated PostScript file suitable for inclusion in other documents. The figure was produced with the following IDL statements. Note the use of the ENCAPSULATED keyword in the call to DEVICE:
  </p>
  <p class="Code">
   ; Select the PostScript driver:
  </p>
  <p class="Code">
   SET_PLOT, 'PS'
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Note use of ENCAPSULATED keyword:
  </p>
  <p class="Code">
   DEVICE, /ENCAPSULATED, FILENAME = 'pic1.ps'
  </p>
  <p class="Code">
   x = FINDGEN(200)
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Plot the sine wave:
  </p>
  <p class="Code">
   PLOT, 10000 * SIN(x/5) / EXP(x/100), $
  </p>
  <p class="Code_Indented">
   LINESTYLE = 2, TITLE = 'IDL PostScript Plot', $
  </p>
  <p class="Code_Indented">
   XTITLE = 'Point Number', YTITLE='Y Axis Title', $
  </p>
  <p class="Code_Indented">
   FONT = 0
  </p>
  <p class="Code">
   ; Add the cosine:
  </p>
  <p class="Code">
   OPLOT, 10000 * COS(x/5) / EXP(x/100), LINESTYLE = 4
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Annotate the plot:
  </p>
  <p class="Code">
   XYOUTS, 100, -6000, 'Sine', FONT = 0
  </p>
  <p class="Code">
   OPLOT, [120, 180], [-6000, -6000], LINESTYLE = 2
  </p>
  <p class="Code">
   XYOUTS, 100, -8000, 'Cosine', FONT = 0
  </p>
  <p class="Code">
   OPLOT, [120, 180], [-8000, -8000], LINESTYLE = 4
  </p>
  <p class="Code">
   &#160;
  </p>
  <p>
   <img src="../Resources/Images/devices2.gif" style="width: 486px;height: 336px;" />
  </p>
  <p class="FigureTitle">
   Sample PostScript plot using Helvetica font
  </p>
  <p>
   &#160;
  </p>
  <p>
   The following figure is a more complicated plot. It demonstrates some of the three-dimensional plotting capabilities of IDL. It was produced with the following IDL statements:
  </p>
  <p class="Code">
   ; Select the PostScript driver:
  </p>
  <p class="Code">
   SET_PLOT, 'PS'
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Note use of ENCAPSULATED keyword:
  </p>
  <p class="Code">
   DEVICE, /ENCAPSULATED, FILENAME = 'pic2.ps'
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Access the data:
  </p>
  <p class="Code">
   OPENR, 1, FILEPATH('abnorm.dat', SUBDIR=['examples', 'data'])
  </p>
  <p class="Code">
   aa = ASSOC(1, BYTARR(64, 64, /NOZERO))
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Get a smoothed version:
  </p>
  <p class="Code">
   a = SMOOTH(aa[0], 3)
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Generate the surface:
  </p>
  <p class="Code">
   SURFACE, a, /SAVE, ZAXIS = 1, XSTYLE = 1, YSTYLE = 1
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Add the contour:
  </p>
  <p class="Code">
   CONTOUR, a, /T3D, /NOERASE, ZVALUE = 1, $
  </p>
  <p class="Code_Indented">
   XSTYLE = 1, YSTYLE = 1, C_LINESTYLE = [0,1,2], $
  </p>
  <p class="Code_Indented">
   TITLE = 'IDL PostScript Plot'
  </p>
  <p class="Code">
   CLOSE, 1
  </p>
  <p>
   <img src="../Resources/Images/devices3.gif" style="width: 469px;height: 368px;" />
  </p>
  <p class="FigureTitle">
   Three-Dimensional Plot with Vector-Drawn Characters
  </p>
  <p>
   &#160;
  </p>
  <p>
   The following figure illustrates polygon filling. It was produced with the following IDL statements:
  </p>
  <p class="Code">
   SET_PLOT, 'PS'
  </p>
  <p class="Code">
   DEVICE, /ENCAPSULATED, FILENAME = 'pic3.ps'
  </p>
  <p class="Code">
   x = FINDGEN(200)
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Upper sine wave:
  </p>
  <p class="Code">
   a = 10000 * sin(x / 5) / exp(x / 100)
  </p>
  <p class="Code">
   PLOT, a, /NODATA, TITLE = 'IDL PostScript Plot', $
  </p>
  <p class="Code_Indented">
   XTITLE='Point Number', YTITLE='Y Axis Title', $
  </p>
  <p class="Code_Indented">
   FONT = 0
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Vector of X vertices for polygon filling. Note that the
  </p>
  <p class="Code">
   ; ROTATE(V,2) function call returns the vector V in reverse order:
  </p>
  <p class="Code">
   C = [X, ROTATE(X, 2)]
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Vector of Y vertices for polygon filling:
  </p>
  <p class="Code">
   D = [A, ROTATE(A-2000, 2)]
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Fill the region using an intensity of about 75% white:
  </p>
  <p class="Code">
   POLYFILL, C, D, COLOR=192
  </p>
  <p>
   <img src="../Resources/Images/devices4.gif" style="width: 469px;height: 320px;" />
  </p>
  <p class="FigureTitle">
   Polygon Filling Example
  </p>
  <p>
   The following figure illustrates IDL PostScript images. In this case, the same image is reproduced four times. In each case, a different number of bits are used per image pixel. It was produced with the following IDL statements:
  </p>
  <p class="Code">
   SET_PLOT, 'PS'
  </p>
  <p class="Code">
   DEVICE, /ENCAPSULATED, FILENAME = 'pic4.ps'
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Open image file:
  </p>
  <p class="Code">
   OPENR, 1, FILEPATH('people.dat', SUBDIR = ['examples','data'])
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Variable to hold image:
  </p>
  <p class="Code">
   a = BYTARR(192, 192, /NOZERO)
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Input the image:
  </p>
  <p class="Code">
   READU, 1, a
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Done with the file:
  </p>
  <p class="Code">
   CLOSE, 1
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Add a color table ramp to the bottom of the image:
  </p>
  <p class="Code">
   A[0,0] = BYTSCL(INDGEN(192))#REPLICATE(1,16)
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Output the image four times:
  </p>
  <p class="Code">
   FOR i = 0,3 DO BEGIN
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code_Indented">
   ; Use 1, 2, 4, and 8 bits per pixel:
  </p>
  <p class="Code_Indented">
   DEVICE, BITS_PER_PIXEL=2^i
  </p>
  <p class="Code_Indented">
   &#160;
  </p>
  <p class="Code_Indented">
   ; Output using TV with position numbers 0, 1, 2, and 3:
  </p>
  <p class="Code_Indented">
   TV, a, i, XSIZE=2.5, YSIZE=2.5, /INCHES
  </p>
  <p class="Code">
   ENDFOR
  </p>
  <p class="Code">
   <img src="../Resources/Images/devices5.gif" style="width: 408px;height: 410px;" />
  </p>
  <p class="FigureTitle">
   1, 2, 4, and 8-bit PostScript Images
  </p>
  <h2 class="API">
   <a name="Microsof">
   </a>
   Microsoft Windows
  </h2>
  <p>
   The Microsoft Windows version of IDL uses the WIN device by default. This device is similar to the X Windows device described below. The WIN device is available only in IDL for Windows.
  </p>
  <p>
   To set plotting to the Microsoft Windows device, use the command:
  </p>
  <p class="Code">
   SET_PLOT, 'WIN'
  </p>
  <p>
   See
   <a href="Keywords_Accepted_by_the.html#Keywords">
    keywords accepted by display devices.
   </a>
  </p>
  <h2 class="API">
   <a name="X">
   </a>
   X Windows
  </h2>
  <p>
   X Windows is a network-based windowing system. IDL uses the X System (often referred to simply as “X”), to provide an environment in which the user can create one or more independent windows, each of which can be used for the display of graphics and/or images.
  </p>
  <p>
   In the X system, there are two basic cooperating processes: clients and servers. A server consists of a display, keyboard, and pointer (such as a mouse) as well as the software that controls them. Client processes (such as IDL) display graphics and text on the screen of a server by sending X protocol requests across the network to the server. Although in the most common case, the server and client reside on the same machine, this network based design allows much more elaborate configurations.
  </p>
  <p>
   To use X Windows as the current graphics device, issue the IDL command:
  </p>
  <p class="Code">
   SET_PLOT, 'X'
  </p>
  <p>
   Use the statement:
  </p>
  <p class="Code">
   HELP, /DEVICE
  </p>
  <p>
   to view the current state of the X Windows driver.
  </p>
  <p>
   See
   <a href="Keywords_Accepted_by_the.html#Keywords">
    keywords accepted by display devices.
   </a>
  </p>
  <h3>
   Multi-Monitor Configurations and X Windows
  </h3>
  <p>
   IDL supports multiple monitor configurations on X Windows in two ways:
  </p>
  <ul>
   <li value="1">
    <b>
     X Multi-Screen
    </b>
    — The core method for an X server to handle more than one monitor. Each monitor is assigned a screen or separate and independent drawing surface. You can move the pointing device from one monitor to another, but cannot drag windows between monitors. Each screen is addressed by the final digit in the X Display name (e.g. the
    <code>
     1
    </code>
    in
    <code>
     ajax:0.1
    </code>
    ). IDL applications use the DISPLAY_NAME keyword on WIDGET_BASE to specify on which monitor to open the widget.
   </li>
   <li value="2">
    <b>
     X with XINERAMA Extension
    </b>
    — XINERAMA is a popular extension used to make multiple monitors appear as one logical screen to the application. IDL applications simply use offsets or locations to specify the desired monitor.
   </li>
  </ul>
  <h4>
   Direct Graphics Limitations
  </h4>
  <p>
   In an X Multi-Screen configuration you can open a Direct Graphics window only on the default Display connection. This applies both to stand-alone Direct Graphics windows (e.g., PLOT) and WIDGET_DRAW widgets created with the GRAPHICS_LEVEL keyword set equal to any value other than 2.
  </p>
  <p>
   In an XINERAMA configuration you can draw Direct Graphics on any monitor. This is because the extended desktop is one logical connection and is addressed with one X Display Name.
  </p>
  <p>
   See the
   <a href="../Object Classes/Miscellaneous/IDLsysMonitorInfo.html">
    IDLsysMonitorInfo
   </a>
   object for more information.
  </p>
  <h3>
   X Windows Visuals
  </h3>
  <p>
   Visuals specify how the hardware deals with color. The X Window server (your display) may provide colors or only gray scale (black and white), or both. The color tables may be changeable from within IDL (read-write), or may be fixed (read-only). The value of each pixel value may be mapped to any color (Un-decomposed Colormap), or certain bits of each pixel are dedicated to the red, green, and blue primary colors (Decomposed Colormap).
  </p>
  <p>
   There are six X Windows visual classes—read-write and read-only visuals for three types of displays: Gray Scale, Pseudo Color, and Decomposed Color. The names of the visuals are shown in the following table:
  </p>
  <table class="TableStyle_Description" style="caption-side: bottom;margin-left: 0;margin-right: auto;mc-table-style: url('../Resources/TableStyles/Description.css');" cellspacing="0">
   <caption>
    Windows Visual Classes
   </caption>
   <col />
   <col />
   <col />
   <thead>
    <tr>
     <th class="TableStyle_Description_Head_0_0_RowSep_ColSep">
      Visual Name
     </th>
     <th class="TableStyle_Description_Head_0_0_RowSep_ColSep">
      Writable
     </th>
     <th class="TableStyle_Description_Head_0_0_RowSep_ColEnd">
      Description
     </th>
    </tr>
   </thead>
   <tbody>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      StaticGray
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      no
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      Gray scale
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
      GrayScale
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
      yes
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
      Gray scale
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      StaticColor
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      no
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      Undecomposed color
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
      PseudoColor
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
      yes
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
      Undecomposed color
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      TrueColor
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      no
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      Decomposed color
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowEnd_ColSep">
      DirectColor
     </td>
     <td class="TableStyle_Description_Body_1_0_RowEnd_ColSep">
      yes
     </td>
     <td class="TableStyle_Description_Body_1_0_RowEnd_ColEnd">
      Decomposed color
     </td>
    </tr>
   </tbody>
  </table>
  <p>
   IDL supports all six types of visuals, although not at all possible depths. UNIX X Window System users can use the command xdpyinfo to determine which visuals are supported by their systems.
  </p>
  <p>
   Each X Window server has a default visual class. Many servers may provide multiple visual classes. For example, a server with display hardware that supports an 8-bit-deep, un-decomposed, writable color map (PseudoColor), may also easily provide StaticColor, StaticGray, and GrayScale visuals.
  </p>
  <p>
   You can select the visual used by IDL using the DEVICE procedure before a window is created, or by including the resource idl.gr_visual in your X defaults file, as explained in
   <a href="#Setting">
    Setting the X Window Defaults
   </a>
   .
  </p>
  <h4>
   How IDL Selects a Visual Class
  </h4>
  <p>
   When opening the display, IDL asks the display for the following visuals, in order, until a supported visual class is found:
  </p>
  <ol>
   <li value="1">
    TrueColor, 24-bit, then 16-bit, then 15-bit
   </li>
   <li value="2">
    PseudoColor, 8-bit, then 4-bit
   </li>
   <li value="3">
    DirectColor, 24-bit
   </li>
   <li value="4">
    StaticColor, 8-bit, then 4-bit
   </li>
   <li value="5">
    GrayScale, any depth
   </li>
   <li value="6">
    StaticGray, any depth
   </li>
  </ol>
  <p>
   You can override this behavior by using the DEVICE routine to specify the desired visual class and depth before you create a window. For example, if you are using a display that supports both the TrueColor, 24-bit-deep visual, and an 8-bit-deep PseudoColor visual, IDL will select the 24-bit-deep TrueColor visual. To instead use PseudoColor, issue the following command before creating a window:
  </p>
  <p class="Code">
   DEVICE, PSEUDO_COLOR = 8
  </p>
  <p>
   The colormap/visual class combination is chosen when IDL first connects with the X Window server. Note that if you connect with the X server by creating a window or using the DEVICE keyword to the HELP procedure, the visual class will be set; it then cannot be changed until IDL is restarted. If you wish to use a visual class other than the default, be sure to set it with a call to the DEVICE procedure before creating windows or otherwise connecting with the X Window server.
  </p>
  <p>
   Windows are created in two ways:
  </p>
  <ol>
   <li value="1">
    Using the WINDOW procedure. WINDOW allows you to explicitly control many aspects of how the window is created.
   </li>
   <li value="2">
    If no windows exist and a graphics operation requiring a window is executed, IDL implicitly creates window 0 with the default characteristics.
   </li>
  </ol>
  <p>
   Once the visual class is selected, all subsequently-created windows share the same class and colormap. The number of simultaneous colors available is stored in the system variable !D.N_COLORS. The visual class and number of colors, once initialized, cannot be changed without first exiting IDL.
  </p>
  <h4>
   How IDL Obtains a Colormap
  </h4>
  <p>
   IDL chooses the type of colormap in the following manner:
  </p>
  <ul>
   <li value="1">
    By default, the shared colormap is used whenever possible (i.e., whenever IDL is using the default visual for the system). All available colors from the shared colormap are allocated for use by IDL. This is what happens when no window currently exists and a graphics operation causes IDL to implicitly create one.
   </li>
   <li value="2">
    If the number of colors to use is explicitly specified using the COLORS keyword with the WINDOW procedure, IDL attempts to allocate the number of colors specified from the shared colormap using the default visual of the screen. If there aren’t enough colors available, a private colormap with that number of colors is used instead.
   </li>
   <li value="3">
    Specifying a negative value for the COLORS keyword to the WINDOW procedure causes IDL to attempt to use the shared colormap, allocating all but the specified number of colors. For example:
    <br />
    <code>
     &#160;&#160;&#160;&#160;WINDOW, COLORS = -8
    </code>
    <br />
    <br />
    allocates all but 8 of the currently available colors. This allows other applications that might need their own colors to run in tandem with IDL.
   </li>
   <li value="4">
    If a visual type and depth is specified, via the DEVICE procedure, which does not match the default visual of the screen, a new, private, colormap is created.
   </li>
  </ul>
  <h3>
   Using Color Under X
  </h3>
  <p>
   Colormaps define the mapping from color index to screen color. Two attributes of colormaps are important to the IDL user: they may be private or shared; and they may be static or writable. These different types of colormaps are described below.
  </p>
  <h4>
   Shared Colormaps
  </h4>
  <p>
   The window manager creates a colormap when it is started. This is known as the default colormap, and can be shared by most applications using the display. When each application requires a colormap entry (i.e., a mapping from a color index to a color), it allocates one from this shared table. Advantages and disadvantages of shared colormaps include:
  </p>
  <ul>
   <li value="1">
    Using the shared colormap ensures that all applications share the available colors without conflict. A given application will not change a color that is allocated to a different application. In the case of IDL it means that IDL can change the colors it has allocated without changing the colors in use by the window manager or other applications.
   </li>
   <li value="2">
    The window system interface routines must translate between the actual and allocated pixel values, significantly slowing the transfer of images.
   </li>
   <li value="3">
    The shared colormap might not have enough colors available to perform the desired operations with IDL.
   </li>
   <li value="4">
    The number of available colors in the shared colormap depends on the window manager in use and the demands of other applications. Thus, the number of available colors can vary.
   </li>
   <li value="5">
    The allocated colors in a shared colormap do not generally start at zero and they are not necessarily contiguous. This makes it difficult to use the write mask for certain operations.
   </li>
  </ul>
  <h4>
   Private Colormaps
  </h4>
  <p>
   An application can create its own private color map. Most hardware can only display a single colormap at a time, so these private colormaps are called virtual color maps, and only one at a time is actually in use and visible. When the window manager gives the color focus to a window with a private colormap, the X window system loads its virtual colormap into the hardware colormap.
  </p>
  <ul>
   <li value="1">
    Every color index supported by the hardware is available to IDL, improving the quality of images.
   </li>
   <li value="2">
    Allocated colors always start at zero and are contiguous. This simplifies using the write mask.
   </li>
   <li value="3">
    No translation between internal pixel values and the values required by the server is required, making the transfer of images more efficient.
   </li>
   <li value="4">
    When the IDL colormap is loaded, other applications are displayed using the wrong colors. Furthermore, colors from the shared colormap are usually allocated from the lower end of the map first. These are the colors allocated by the window manager for such things as window borders, the color of text, and so forth. Since most IDL colormaps have very dark colors in the lower entries, the end effect with the IDL colormap loaded is that the non-IDL portions of the screen go blank.
   </li>
  </ul>
  <h4>
   Static Colormaps
  </h4>
  <p>
   As mentioned above, the contents of static colormaps are determined outside of IDL and cannot be changed. When using a static colormap, the TVLCT procedure simulates writable colormaps by finding the closest RGB color entry in the colormap to the requested color. The colormap translation table is then set to map IDL color indices to those of the closest colors in the colormap.
  </p>
  <p>
   The colors present in the colormap may, and probably will, not match the requested colors exactly. For example, with a typical static color map, loading the IDL standard color table number 0, which consists of 256 intensities of gray, results in only 8 or 16 distinct intensities.
  </p>
  <p>
   With static colormaps, loading a new color table does not affect the appearance of previously written objects. The internal translation tables are modified, which only affects objects that are subsequently written.
  </p>
  <h4>
   Color Translation
  </h4>
  <p>
   As mentioned above, colors from the shared colormap do not necessarily start from index zero, and are not necessarily contiguous. IDL preserves the illusion of a zero based contiguous colormap by maintaining a translation table between user color indices, which range from 0 to !D.TABLE_SIZE, and the actual pixel values allocated from the X server. Normally, the user need not be concerned with this translation table, but it is available using the statement:
  </p>
  <p class="Code">
   DEVICE, TRANSLATION=T
  </p>
  <p>
   This statement stores the current translation table, a 256 element byte vector, in the variable T. Element zero of the vector contains the value pixel allocated for the zeroth color in the IDL colormap, and so forth. In the case of a private colormap, each element of the translation vector contains it’s own index value, because private colormaps start at zero and are contiguous.
  </p>
  <p>
   The translation table may be bypassed, allowing direct access to the display’s color indices, by setting the BYPASS_TRANSLATION keyword in the DEVICE procedure.
  </p>
  <p class="Code">
   DEVICE, /BYPASS_TRANSLATION
  </p>
  <p>
   Translation can be reestablished by setting the keyword to zero:
  </p>
  <p class="Code">
   DEVICE, BYPASS_TRANSLATION=0
  </p>
  <p>
   By default, the color translation tables are bypassed if the visual type is TrueColor or the visual type is DirectColor with a private colormap.
  </p>
  <h3>
   Using Pixmaps
  </h3>
  <p>
   X Windows can direct graphics to windows or pixmaps. Windows are the usual windows that appear on the screen and contain graphics. Pixmaps are invisible graphics memory contained in the server. Drawing to a window produces a viewable result, while drawing to a pixmap simply updates the pixmap memory.
  </p>
  <p>
   Pixmaps are useful because it is possible to write graphics to a pixmap and then copy the contents of the pixmap to a window where it can be viewed. Furthermore, this copy operation is very fast because it happens entirely within the server. Provided enough pixmap memory is available, this technique works very well for animating a series of images by placing the images into pixmap memory and then sequentially copying them to a visible window.
  </p>
  <p>
   To create a pixmap, use the PIXMAP keyword with the WINDOW procedure. For example, to create a square pixmap with 128 pixels per side as IDL window 1, use the command:
  </p>
  <p class="Code">
   WINDOW, 1, /PIXMAP, XSIZE=128, YSIZE=128
  </p>
  <p>
   Once they are created, pixmaps are treated just like normal windows, although some operations (WSHOW for instance) don’t do anything useful when applied to a pixmap.
  </p>
  <h4>
   Pixmap Animation Example
  </h4>
  <p>
   The following procedure shows how animation can be done using pixmap memory. It uses a series of 15 heart images taken from the file abnorm.dat. This file is supplied with all IDL distributions in the examples/data subdirectory of the main IDL directory. It creates a pixmap and writes the heart images to it. It then uses the COPY keyword of the DEVICE procedure to copy the images to a visible window.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   Pressing any key causes the display process to halt. If you are using the IDL Workbench interface, make sure the IDL Command Line view has the focus before pressing a key.
  </p>
  <p class="Code">
   ; Animate heart series:
  </p>
  <p class="Code">
   PRO animate_heart
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Open the file containing the images:
  </p>
  <p class="Code">
   OPENR, u, FILEPATH('abnorm.dat', SUBDIR = ['examples','data']), $
  </p>
  <p class="Code_Indented">
   /GET_LUN
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Associate a file variable with the file. Each heart image
  </p>
  <p class="Code">
   ; is 64x64 pixels:
  </p>
  <p class="Code">
   frame = ASSOC(u, BYTARR(64,64, /NOZERO))
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Window 0 is a pixmap which is 4 images tall and 4
  </p>
  <p class="Code">
   ; images wide. The images will be placed in this pixmap:
  </p>
  <p class="Code">
   WINDOW, 0, /PIXMAP, XSIZE = 512, YSIZE = 512
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Write each image to the pixmap. SMOOTH is used to improve
  </p>
  <p class="Code">
   ; the appearance of each image and REBIN is used to
  </p>
  <p class="Code">
   ; enlarge/shrink each image to the final display size:
  </p>
  <p class="Code">
   FOR i=0, 15-1 DO TV, REBIN(SMOOTH(frame[i],3), 128, 128),i
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Close the image file and free the file unit:
  </p>
  <p class="Code">
   FREE_LUN, u
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; The visible window will be used to display the animated heart
  </p>
  <p class="Code">
   ; cycle:
  </p>
  <p class="Code">
   WINDOW, XSIZE = 128, YSIZE=128, TITLE='Heart', /FREE
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Current frame number:
  </p>
  <p class="Code">
   i = 0L
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Display frames until any key is pressed:
  </p>
  <p class="Code">
   WHILE GET_KBRD(0) EQ '' DO BEGIN
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Compute x and y locations of pixmap image’s lower left corner:
  </p>
  <p class="Code">
   x = (i mod 4) * 128 &amp; y = 384 - (i/4) * 128
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Copy the next image from the pixmap to the visible window:
  </p>
  <p class="Code">
   DEVICE, COPY = [x, y, 128, 128, 0, 0, 0]
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Keep track of total frame count:
  </p>
  <p class="Code">
   i = (i + 1) MOD 15
  </p>
  <p class="Code">
   ENDWHILE
  </p>
  <p class="Code">
   END
  </p>
  <p>
   Animation sequences with more and/or larger images can be made. See the documentation for the XANIMATE procedure, which is a more generalized embodiment of the above procedure.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   Some X Windows servers will refuse to create a pixmap that is larger than the physical screen in either dimension.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   Excessive pixmap allocation can exhaust virtual storage, causing some X Windows servers to become unresponsive.
  </p>
  <h3>
   How Color is Interpreted for a TrueColor Visual
  </h3>
  <p>
   How a color (such as !P.COLOR) is interpreted by IDL (when a TrueColor visual is being utilized) depends in part upon the decomposed setting for the device.
  </p>
  <p>
   To retrieve the decomposed setting:
  </p>
  <p class="Code">
   DEVICE, GET_DECOMPOSED = currentDecomposed
  </p>
  <p>
   To set the decomposed setting:
  </p>
  <p class="Code">
   DEVICE, DECOMPOSED = newDecomposed
  </p>
  <p>
   If the decomposed value is zero, colors (like !P.COLOR) are interpreted as indices into IDL's color table. A color should be in the range from 0 to !D.TABLE_SIZE - 1. The IDL color table contains a red, green, and blue component at a given index; each of these components is in the range of 0 up to 255.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   IDL’s color table does not map directly to a hardware color table for a TrueColor visual. If IDL’s color table is modified, for example using the LOADCT or TVLCT routines, then the new color table will only take effect for graphics that are drawn after it has been modified.
  </p>
  <p>
   If the decomposed value is non-zero, colors (like !P.COLOR) are interpreted as a combination of red, green, and blue settings. The least significant 8 bits contain the red component, the next 8 bits contain the green component, and the most significant 8 bits contain the blue component.
  </p>
  <p>
   In either case, the most significant bits of each of the resulting red, green, and blue components are utilized. The number of bits utilized per component depends upon the red, green, and blue masks for the visual. On UNIX systems, a new field (Bits Per RGB) has been added to the output from HELP, /DEVICE. This Bits Per RGB field indicates the amount of bits utilized for each component.
  </p>
  <p class="Tip" madcap:autonum="&lt;b&gt;Tip: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Tip:
     </b>
    </span>
   </span>
   The UNIX command
   <code>
    xdpyinfo
   </code>
   also provides information about each of the visuals.
  </p>
  <h3>
   <a name="Setting">
   </a>
   Setting the X Window Defaults
  </h3>
  <p>
   You can set the initial default value of the following parameters by setting resources in the file .Xdefaults file in your home directory as follows:
  </p>
  <table style="caption-side: bottom;margin-left: 0;margin-right: auto;mc-table-style: url('../Resources/TableStyles/Description.css');" class="TableStyle_Description" cellspacing="0">
   <caption>
    IDL/X Window Defaults
   </caption>
   <col />
   <col />
   <thead>
    <tr>
     <th class="TableStyle_Description_Head_0_0_RowSep_ColSep">
      Resource Name
     </th>
     <th class="TableStyle_Description_Head_0_0_RowSep_ColEnd">
      Description
     </th>
    </tr>
   </thead>
   <tbody>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      idl.colors
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      The number of colors used by IDL.
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
      idl.gr_depth
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
      The depth, in bits, of the visual used by IDL.
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      idl.retain
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      The default setting for the retain parameter: 0=none, 1= by server, 2=by IDL.
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowEnd_ColSep">
      idl.gr_visual
     </td>
     <td class="TableStyle_Description_Body_1_0_RowEnd_ColEnd">
      The type of visual: StaticGray, GrayScale, StaticColor, PseudoColor, TrueColor, or DirectColor.
     </td>
    </tr>
   </tbody>
  </table>
  <p>
   For example, to set the default visual to PseudoColor, and to allocate 100 colors, insert the following lines in your defaults file:
  </p>
  <p class="Code">
   idl.gr_visual: PseudoColor
  </p>
  <p class="Code">
   idl.colors: 100
  </p>
  <h2 class="API">
   <a name="Z-Buffer">
   </a>
   Z-Buffer
  </h2>
  <p>
   The IDL Z-buffer device is a pseudo device that draws 2-D or 3-D graphics in a buffer contained in memory. This driver implements the classic Z buffer algorithm for hidden surface removal. Although primarily used for 3-D graphics, the Z-buffer driver can be used to create 2-D objects in a frame buffer in memory. The resolution (dimensions) of this device can be set by the user.
  </p>
  <p>
   All of the IDL plotting and graphics routines work with the Z-buffer device driver. In addition, the POLYFILL procedure has a few keyword parameters, allowing Gouraud shading and warping images over 3-D polygons, that are only effective when used with the Z-buffer.
  </p>
  <p>
   When used for 3-D graphics, two buffers are present: an 8-bit-deep or 24-bit deep frame buffer that contains the picture; and a 16-bit-deep Z-buffer of the same resolution, containing the z-value of the visible surface of each pixel. The Z-buffer is initialized to the depth at the back of the viewing volume. When objects are drawn, the z-value of each pixel is compared with the value at the same location in the Zbuffer, and if the z-value is greater (closer to the viewer), the new pixel is written in the frame buffer and the Z-buffer is updated with the new z-value.
  </p>
  <p>
   The frame buffer is 8 bits deep by default, but can be configured to be 24 bits deep using the SET_PIXEL_DEPTH keyword to the DEVICE routine. In 8-bit mode, the low-order 8 bits of any color specification are written to the 8-bit frame buffer. In 24- bit mode, the behavior depends on the value of the
   <a href="../Reference Material/D/DEVICE_Procedure.html#devices_517620971_144834">
    DECOMPOSED
   </a>
   keyword to the
   <a href="../Reference Material/D/DEVICE_Procedure.html">
    DEVICE
   </a>
   routine. When DECOMPOSED=1 (the default), the 24-bit color specification is stored in the 24-bit frame buffer, providing TrueColor functionality. When DECOMPOSED=0, the lower 8 bits of the color specification are used to index the current color lookup table to obtain 3-channel color information to store in the 24-bit frame buffer. Use the
   <a href="../Reference Material/D/DEVICE_Procedure.html#devices_517620971_486222">
    SET_COLORS
   </a>
   keyword to the DEVICE routine to limit the maximum color index value used in this process.
  </p>
  <p>
   The Z-buffer device is a “pseudo device” in that drawing commands update buffers in memory rather than sending commands to a physical device or file. The TVRD function reads the contents of either buffer to an IDL array. This array may then be further processed, written to a file, or output to a raster-based graphics output device.
  </p>
  <p>
   The Z-buffer driver can be used for 2-D graphics by disabling the depth computations.
  </p>
  <p>
   To use the Z-buffer as the current graphics device, issue the IDL command:
  </p>
  <p class="Code">
   SET_PLOT, 'Z'
  </p>
  <p>
   Once the Z-buffer driver is enabled, the DEVICE procedure is used to control its actions, as described below.
  </p>
  <p>
   Use the statement:
  </p>
  <p class="Code">
   HELP, /DEVICE
  </p>
  <p>
   to view the current state of the Z-buffer driver and the amount of memory used for the buffers.
  </p>
  <p>
   See
   <a href="Keywords_Accepted_by_the.html#Keywords">
    keywords accepted by display devices.
   </a>
  </p>
  <h3>
   Reading and Writing Buffers
  </h3>
  <p>
   The contents of both frame and depth buffers are directly accessed by the TV (or TVSCL) and TVRD routines via the CHANNEL keyword. Access the buffers as follows, depending on the device pixel depth:
  </p>
  <h4>
   8-bit Pixel Depth
  </h4>
  <p>
   When the Z buffer device pixel depth is 8 bits (the default), the assignments for the CHANNEL keyword are:
  </p>
  <table class="TableStyle_Description" style="margin-left: 0;margin-right: auto;caption-side: top;mc-table-style: url('../Resources/TableStyles/Description.css');" cellspacing="0">
   <col />
   <col />
   <col />
   <thead>
    <tr>
     <th class="TableStyle_Description_Head_0_0_RowSep_ColSep">
      CHANNEL
     </th>
     <th class="TableStyle_Description_Head_0_0_RowSep_ColSep">
      Buffer
     </th>
     <th class="TableStyle_Description_Head_0_0_RowSep_ColEnd">
      Data Type
     </th>
    </tr>
   </thead>
   <tbody>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      0
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      8-bit Frame Buffer (color indices)
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      byte
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowEnd_ColSep">
      1
     </td>
     <td class="TableStyle_Description_Body_1_0_RowEnd_ColSep">
      16-bit Depth Buffer
     </td>
     <td class="TableStyle_Description_Body_1_0_RowEnd_ColEnd">
      signed integer
     </td>
    </tr>
   </tbody>
  </table>
  <p>
   Use CHANNEL=1 and set the WORDS keyword when reading or writing the depth buffer in 8-bit mode.
  </p>
  <p>
   The Z buffer device ignores the TRUE keyword in 8-bit mode.
  </p>
  <h4>
   24-bit Pixel Depth
  </h4>
  <p>
   When the device pixel depth is 24 bits, the assignments for the CHANNEL keyword are:
  </p>
  <table class="TableStyle_Description" style="margin-left: 0;margin-right: auto;caption-side: top;mc-table-style: url('../Resources/TableStyles/Description.css');" cellspacing="0">
   <col />
   <col />
   <col />
   <thead>
    <tr>
     <th class="TableStyle_Description_Head_0_0_RowSep_ColSep">
      CHANNEL
     </th>
     <th class="TableStyle_Description_Head_0_0_RowSep_ColSep">
      Buffer
     </th>
     <th class="TableStyle_Description_Head_0_0_RowSep_ColEnd">
      Data Type
     </th>
    </tr>
   </thead>
   <tbody>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      0
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      3 8-bit Frame Buffer channels (Red, Green, Blue)
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      byte
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
      1
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
      8-bit Frame Buffer (Red channel)
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
      byte
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      2
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      8-bit Frame Buffer (Green channel)
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      byte
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
      3
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
      8-bit Frame Buffer (Blue channel)
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
      byte
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowEnd_ColSep">
      4
     </td>
     <td class="TableStyle_Description_Body_0_0_RowEnd_ColSep">
      16-bit Depth Buffer
     </td>
     <td class="TableStyle_Description_Body_0_0_RowEnd_ColEnd">
      signed integer
     </td>
    </tr>
   </tbody>
  </table>
  <p>
   Use CHANNEL=4 and set the WORDS keyword when reading or writing the depth buffer in 24-bit mode.
  </p>
  <p>
   In 24-bit mode, the interleave is controlled by the value of the TRUE keyword:
  </p>
  <table style="caption-side: top;margin-left: 0;margin-right: auto;mc-table-style: url('../Resources/TableStyles/Description.css');" class="TableStyle_Description" cellspacing="0">
   <col />
   <col />
   <thead>
    <tr>
     <th class="TableStyle_Description_Head_0_0_RowSep_ColSep">
      TRUE
     </th>
     <th class="TableStyle_Description_Head_0_0_RowSep_ColEnd">
      Interleave
     </th>
    </tr>
   </thead>
   <tbody>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      0
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      None (see below)
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
      1
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
      Pixel
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      2
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      Row
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowEnd_ColSep">
      3
     </td>
     <td class="TableStyle_Description_Body_1_0_RowEnd_ColEnd">
      Band
     </td>
    </tr>
   </tbody>
  </table>
  <p>
   If TRUE=0:
  </p>
  <ul>
   <li value="1">
    The TV and TVSCL routines replicate the single channel of input data into each of the three frame buffer channels.
   </li>
   <li value="2">
    The TVRD routine returns a one-channel image where each pixel is the maximum of the three pixel components in the frame buffer.
   </li>
  </ul>
  <h4>
   Using the Z Buffer
  </h4>
  <p>
   The normal procedure is to set the graphics device to “Z”, draw the objects, read the frame buffer, and then select another graphics device and write the image. For example, to create an image with the Z-buffer driver and then display it on an X-Window display:
  </p>
  <p class="Code">
   ; Select Z-buffer device:
  </p>
  <p class="Code">
   SET_PLOT,'Z'
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Write objects to the frame buffer using normal graphics
  </p>
  <p class="Code">
   ; routines, e.g. PLOT, SURFACE, POLYFILL
  </p>
  <p class="Code">
   ... ... ...
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Read back the entire frame buffer:
  </p>
  <p class="Code">
   a=TVRD()
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Select X Windows:
  </p>
  <p class="Code">
   SET_PLOT,'X'
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Display the contents of the frame buffer:
  </p>
  <p class="Code">
   TV, a
  </p>
  <p>
   To read the depth values in the Z-buffer, use the command:
  </p>
  <p class="Code">
   a = TVRD(CHANNEL=1, /WORDS)
  </p>
  <p>
   To write the depth values, use the command:
  </p>
  <p class="Code">
   TV, a, /WORDS, CHANNEL=1
  </p>
  <p>
   The TV, TVSCL, and TVRD routines write or read pixels directly to a rectangular area of the designated buffer without affecting the other buffer.
  </p>
  <h3>
   Z-Axis Scaling
  </h3>
  <p>
   The values in the depth buffer are short integers, scaled from -32765 to +32765, corresponding to normalized Z-coordinate values of 0.0 to 1.0, where 1.0 represents the plane closest to the viewer.
  </p>
  <h3>
   Polyfill Procedure
  </h3>
  <p>
   The Z device draws patterns specified via the PATTERN keyword to the POLYFILL procedure using one of two methods:
  </p>
  <ul>
   <li value="1">
    The default method treats the pattern image as a background pattern, drawing it only inside the boundaries of the polygons. All graphics devices that render POLYFILL patterns can use this method.
   </li>
   <li value="2">
    The alternate method emulates texture mapping, in which the pattern image is “warped” between the vertices of the polygons. This method is used when the IMAGE_COORDINATES keyword to POLYFILL is present, specifying which part of the image is warped to each vertex. This method is only available when using the Z device.
   </li>
  </ul>
  <p>
   The following POLYFILL keywords are active only with the Z-buffer device: IMAGE_COORDINATES, IMAGE_INTERPOLATE, and TRANSPARENT. These parameters allow images, specified via the PATTERN keyword, to be warped over 2-D and 3-D polygons. The values of the IMAGE_INTERPOLATE and TRANSPARENT keywords apply only when IMAGE_COORDINATES are specified.
  </p>
  <p>
   The Z device converts all image data specified with the PATTERN keyword to BYTE.
  </p>
  <p>
   Image data can be supplied in either an [m x n] array (a single-channel image), or as an [3 x m x n] array (a three-channel image). Table A-21 describes how different types of image data interact with the device pixel depth and the DECOMPOSED setting of the device.
  </p>
  <table class="TableStyle_Description" style="margin-left: 0;margin-right: auto;caption-side: top;mc-table-style: url('../Resources/TableStyles/Description.css');" cellspacing="0">
   <col />
   <col />
   <col />
   <col />
   <thead>
    <tr>
     <th class="TableStyle_Description_Head_0_0_RowSep_ColSep">
      <p>
       Z Device
      </p>
      <p>
       Pixel Depth
      </p>
     </th>
     <th class="TableStyle_Description_Head_0_0_RowSep_ColSep">
      Number of PATTERN Channels
     </th>
     <th class="TableStyle_Description_Head_0_0_RowSep_ColSep">
      DECOMPOSED Setting
     </th>
     <th class="TableStyle_Description_Head_0_0_RowSep_ColEnd">
      Resulting Pattern Image
     </th>
    </tr>
   </thead>
   <tbody>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep" style="text-align: center;">
      8
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep" style="text-align: center;">
      1
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep" style="text-align: center;">
      n/a
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      Grayscale
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep" style="text-align: center;">
      8
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep" style="text-align: center;">
      3
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep" style="text-align: center;">
      n/a
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
      Grayscale, created from first (red) channel
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep" style="text-align: center;">
      24
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep" style="text-align: center;">
      1
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep" style="text-align: center;">
      0
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      Color table applied
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep" style="text-align: center;">
      24
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep" style="text-align: center;">
      1
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep" style="text-align: center;">
      1
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
      Single image channel replicated to grayscale
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowEnd_ColSep" style="text-align: center;">
      24
     </td>
     <td class="TableStyle_Description_Body_0_0_RowEnd_ColSep" style="text-align: center;">
      3
     </td>
     <td class="TableStyle_Description_Body_0_0_RowEnd_ColSep" style="text-align: center;">
      n/a
     </td>
     <td class="TableStyle_Description_Body_0_0_RowEnd_ColEnd">
      True color
     </td>
    </tr>
   </tbody>
  </table>
  <p>
   The IMAGE_COORDINATES keyword specifies a [2 x n] array containing the image space coordinates that correspond to each of the n vertices of the polygon.
  </p>
  <p>
   The IMAGE_INTERPOLATE keyword indicates that bilinear interpolation is to be used, rather than the default nearest neighbor sampling.
  </p>
  <p>
   Pixels less than the value of the TRANSPARENT keyword are not drawn, simulating transparency. The TRANSPARENT keyword is a byte value. A three-channel image pixel is not drawn only when all three components are less than the TRANSPARENT value. If performing color table lookup (Z device pixel depth is 24, PATTERN is one channel, and DECOMPOSED=0), the pixel is not drawn if the single-channel pixel is less than the transparent value.
  </p>
  <p>
   For Gouraud shading of polygons, the COLOR keyword can contain an array specifying the color index for each polygon vertex.
  </p>
  <h3>
   Examples Using the Z-Buffer
  </h3>
  <p>
   This example forms a Bessel function, draws its shaded surface and overlays its contour, using the Z-buffer as shown in the following figure. The final output is directed to a PostScript file.
  </p>
  <p class="Code">
   ; Store the original display device
  </p>
  <p class="Code">
   oldDevice = !D.NAME
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Select the Z-buffer:
  </p>
  <p class="Code">
   SET_PLOT, 'Z'
  </p>
  <p class="Code">
   n = 50 ; Size of array for Bessel
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Make the Bessel function:
  </p>
  <p class="Code">
   a = BESELJ(SHIFT(DIST(n), n/2, n/2)/2, 0)
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Draw the surface, label axes in black, background in white:
  </p>
  <p class="Code">
   SHADE_SURF, a, /SAVE, COLOR=1, BACKGROUND=255
  </p>
  <p class="Code">
   nlev = 8 ; Number of contour levels
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Make the Contour at normalized Z=.6:
  </p>
  <p class="Code">
   CONTOUR, a, /OVERPLOT, ZVALUE=.6, /T3D, $
  </p>
  <p class="Code_Indented">
   LEVELS=FINDGEN(nlev)*1.5/nlev-.5, COLOR=1
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Read image:
  </p>
  <p class="Code">
   b=TVRD()
  </p>
  <p class="Code">
   ; Select PostScript output:
  </p>
  <p class="Code">
   SET_PLOT, 'PS'
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Select a file name for the output file
  </p>
  <p class="Code">
   DEVICE, FILENAME = DIALOG_PICKFILE(FILE='zbuffer-1.ps')
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Output the image:
  </p>
  <p class="Code">
   TV, b
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Close the new PostScript file:
  </p>
  <p class="Code">
   DEVICE, /CLOSE
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Select the original device:
  </p>
  <p class="Code">
   SET_PLOT, oldDevice
  </p>
  <p>
   <img src="../Resources/Images/devices6.gif" />
   <![CDATA[ ]]>
  </p>
  <p class="FigureTitle">
   Combined Shaded Surface and Contour Plot
  </p>
  <p>
   If we use a 24-bit Z device, we can prepare a true color image that can then be displayed on a 24-bit display. (Here, we assume that the display monitor is a TrueColor device):
  </p>
  <p class="Code">
   ; Store the original display device
  </p>
  <p class="Code">
   oldDevice = !D.NAME
  </p>
  <p class="Code">
   DEVICE, GET_DECOMPOSED=oldDecomposed
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Select the Z-buffer:
  </p>
  <p class="Code">
   SET_PLOT, 'Z'
  </p>
  <p class="Code">
   DEVICE, SET_PIXEL_DEPTH=24, DECOMPOSED=0
  </p>
  <p class="Code">
   LOADCT, 5
  </p>
  <p class="Code">
   n = 50 ; Size of array for Bessel
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Make the Bessel function:
  </p>
  <p class="Code">
   a = BESELJ(SHIFT(DIST(n), n/2, n/2)/2, 0)
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Draw the surface, label axes in black, background in white:
  </p>
  <p class="Code">
   SHADE_SURF, a, /SAVE, COLOR=1, BACKGROUND=255
  </p>
  <p class="Code">
   nlev = 8 ; Number of contour levels
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Make the Contour at normalized Z=.6:
  </p>
  <p class="Code">
   CONTOUR, a, /OVERPLOT, ZVALUE=.6, /T3D, $
  </p>
  <p class="Code_Indented">
   LEVELS=FINDGEN(nlev)*1.5/nlev-.5, COLOR=1
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Read image:
  </p>
  <p class="Code">
   b=TVRD(/TRUE)
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Select the original device and set window size:
  </p>
  <p class="Code">
   SET_PLOT, oldDevice
  </p>
  <p class="Code">
   DEVICE, DECOMPOSED=oldDecomposed
  </p>
  <p class="Code">
   WINDOW, XSIZE=(SIZE(b))[2], YSIZE=(SIZE(b))[3]
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Output the image:
  </p>
  <p class="Code">
   TV, b, /TRUE
  </p>
  <p>
   Using the 24-bit Z device, we can also modify the example to use full 24-bit color specifications, rather than picking colors from a color table:
  </p>
  <p class="Code">
   ; Store the original display device
  </p>
  <p class="Code">
   oldDevice = !D.NAME
  </p>
  <p class="Code">
   DEVICE, GET_DECOMPOSED=oldDecomposed
  </p>
  <p class="Code">
   SET_PLOT, 'Z'
  </p>
  <p class="Code">
   DEVICE, SET_PIXEL_DEPTH=24, DECOMPOSED=1
  </p>
  <p class="Code">
   n = 50 ; Size of array for Bessel
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Make the Bessel function:
  </p>
  <p class="Code">
   a = BESELJ(SHIFT(DIST(n), n/2, n/2)/2, 0)
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Draw the surface and axes in red, background in purple:
  </p>
  <p class="Code">
   SHADE_SURF, a, /SAVE, COLOR='000000d2'x, BACKGROUND='00ff80c0'x
  </p>
  <p class="Code">
   nlev = 8 ; Number of contour levels
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Make the Contour at normalized Z=.6:
  </p>
  <p class="Code">
   CONTOUR, a, /OVERPLOT, ZVALUE=.6, /T3D, $
  </p>
  <p class="Code_Indented">
   LEVELS=FINDGEN(nlev)*1.5/nlev-.5, $
  </p>
  <p class="Code_Indented">
   C_COLORS=['00ffff00'x, '0000ffff'x, '00ff00ff'x]
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Read image:
  </p>
  <p class="Code">
   b=TVRD(/TRUE)
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Select original output and set window size:
  </p>
  <p class="Code">
   SET_PLOT, oldDevice
  </p>
  <p class="Code">
   DEVICE, DECOMPOSED=oldDecomposed
  </p>
  <p class="Code">
   WINDOW, XSIZE=(SIZE(b))[2], YSIZE=(SIZE(b))[3]
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Output the image:
  </p>
  <p class="Code">
   TV, b, /TRUE
  </p>
  <p>
   The 24-bit Z buffer device is useful for creating a TrueColor image from an 8-bit display. The following example creates (and then displays) an image file from a display window that uses an 8-bit color lookup table.
  </p>
  <p class="Code">
   ; Read an image file containing elevation data
  </p>
  <p class="Code">
   file = FILEPATH('worldelv.dat', $
  </p>
  <p class="Code_Indented">
   SUBDIRECTORY = ['examples', 'data'])
  </p>
  <p class="Code">
   image = READ_BINARY(file, DATA_DIMS = [360, 360])
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Store the original display device
  </p>
  <p class="Code">
   oldDevice = !D.NAME
  </p>
  <p class="Code">
   DEVICE, GET_DECOMPOSED=oldDecomposed
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Write the image to the 24-bit Z buffer device, using a
  </p>
  <p class="Code">
   ; color lookup table. Note that we must set the DECOMPOSED
  </p>
  <p class="Code">
   ; keyword to zero to create the color image.
  </p>
  <p class="Code">
   SET_PLOT, 'Z'
  </p>
  <p class="Code">
   ERASE
  </p>
  <p class="Code">
   DEVICE, SET_PIXEL_DEPTH=24
  </p>
  <p class="Code">
   DEVICE, SET_RESOLUTION=[360,360]
  </p>
  <p class="Code">
   DEVICE, DECOMPOSED=0
  </p>
  <p class="Code">
   LOADCT, 33
  </p>
  <p class="Code">
   TVLCT, 255,255,255, !D.TABLE_SIZE - 1
  </p>
  <p class="Code">
   TVSCL, image
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Read the image array back from the Z buffer device
  </p>
  <p class="Code">
   ; and write it to a TIFF file.
  </p>
  <p class="Code">
   new_image = TVRD(/TRUE)
  </p>
  <p class="Code">
   new_file = GETENV('IDL_TMPDIR')+'world.tif'
  </p>
  <p class="Code">
   WRITE_TIFF, new_file, new_image
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Change back to the original device
  </p>
  <p class="Code">
   SET_PLOT, oldDevice
  </p>
  <p class="Code">
   DEVICE, DECOMPOSED=oldDecomposed
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Read in the TIFF file and display it.
  </p>
  <p class="Code">
   tif_image = READ_TIFF(new_file)
  </p>
  <p class="Code">
   WINDOW, XSIZE=360, YSIZE=360, TITLE='Image read from TIFF file'
  </p>
  <p class="Code">
   TV, tif_image, /TRUE
  </p>
  <p>
   The following example warps an image to a cube as shown in the figure below. The lower two quadrants of the image are warped to the front two faces of the cube. The upper-right quadrant is warped to the top face of the cube.
  </p>
  <p class="Code">
   ; Read an image from a JPEG file and resize it to
  </p>
  <p class="Code">
   ; 100 by 100 pixels.
  </p>
  <p class="Code">
   READ_JPEG, FILEPATH('rose.jpg', $
  </p>
  <p class="Code_Indented">
   SUBDIRECTORY=['examples', 'data']), rose
  </p>
  <p class="Code">
   nx = 100
  </p>
  <p class="Code">
   ny = 100
  </p>
  <p class="Code">
   rose = CONGRID(rose, 3, nx, ny)
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Store the original display device
  </p>
  <p class="Code">
   oldDevice = !D.NAME
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Change to the Z buffer device
  </p>
  <p class="Code">
   SET_PLOT, 'Z'
  </p>
  <p class="Code">
   DEVICE, SET_PIXEL_DEPTH=24, SET_RESOLUTION=[400,400]
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Make a greenish background:
  </p>
  <p class="Code">
   ERASE, '80ff80'x
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Establish 3-D scaling as (0,1) cube:
  </p>
  <p class="Code">
   SCALE3, XRANGE=[0,1], YRANGE=[0,1], ZRANGE=[0,1]
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Define vertices of cube. Vertices 0-3 are bottom, 4-7 are top:
  </p>
  <p class="Code">
   verts = [[0,0,0], [1,0,0], [1,1,0], [0,1,0], $
  </p>
  <p class="Code_Indented">
   [0,0,1], [1,0,1], [1,1,1], [0,1,1]]
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Fill lower left face:
  </p>
  <p class="Code">
   POLYFILL, verts[*, [3,0,4,7]], /T3D, PATTERN=rose, $
  </p>
  <p class="Code_Indented">
   IMAGE_COORD=[[0,0], [nx/2,0], [nx/2,ny/2], [0,ny/2]]
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Fill lower right face:
  </p>
  <p class="Code">
   POLYFILL, verts[*, [0,1,5,4]], /T3D, PATTERN=rose, $
  </p>
  <p class="Code_Indented">
   IMAGE_COORD=[[nx/2,0], [nx-1,0], $
  </p>
  <p class="Code">
   [nx-1,ny/2], [nx/2,ny/2]]
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Fill top face:
  </p>
  <p class="Code">
   POLYFILL, verts[*, [4,5,6,7]], /T3D, PATTERN=rose, $
  </p>
  <p class="Code_Indented">
   IMAGE_COORD = [[nx/2,ny/2], [nx-1,ny/2], $
  </p>
  <p class="Code_Indented">
   [nx-1,ny-1], [nx/2,ny-1]]
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Draw edges of cube in black:
  </p>
  <p class="Code">
   PLOTS, verts[*, [0,4]], /T3D, COLOR=0
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Edges of top face:
  </p>
  <p class="Code">
   PLOTS, verts[*, [4,5,6,7,4]], /T3D, COLOR=0
  </p>
  <p class="Code">
   img = TVRD(/TRUE)
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Change back to the original device and display:
  </p>
  <p class="Code">
   SET_PLOT, oldDevice
  </p>
  <p class="Code">
   WINDOW, XSIZE=400, YSIZE=400
  </p>
  <p class="Code">
   TV, img, /TRUE
  </p>
  <p>
   <img src="../Resources/Images/devices7.gif" />
  </p>
  <p class="FigureTitle">
   TrueColor Image Warped to a Cube Using the Z-Buffer
  </p>
  <div class="mp_footer">
   Copyright ©
   <span class="DocumentTitleCopyrightYear">
    2012
   </span>
   <![CDATA[ ]]>
   <span class="DocumentTitleCopyrightCompanyName">
    Exelis Visual Information Solutions, Inc.
   </span>
   All Rights Reserved.
  </div>
  <script type="text/javascript" src="../SkinSupport/MadCapBodyEnd.js">
  </script>
 </body>
</html>