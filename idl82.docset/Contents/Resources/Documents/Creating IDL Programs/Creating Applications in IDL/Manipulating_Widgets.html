<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns:madcap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" madcap:lastblockdepth="2" madcap:lastheight="135.6667" madcap:lastwidth="592" madcap:disablemasterstylesheet="true" madcap:tocpath="IDL Programming|Interfaces (Widgets)|Creating Widget Applications" madcap:medium="non-print" madcap:inpreviewmode="false" madcap:preloadimages="false" madcap:runtimefiletype="Topic" madcap:targettype="WebHelp" lang="en-US" xml:lang="en-US" madcap:pathtohelpsystem="../../../" madcap:helpsystemfilename="idl.xml" madcap:searchtype="Stem">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>
   Manipulating Widgets
  </title>
  <link href="../../SkinSupport/MadCap.css" rel="stylesheet" />
  <link href="../../Resources/Stylesheets/IDL_style.css" rel="stylesheet" />
  <script src="../../SkinSupport/MadCapAll.js" type="text/javascript">
  </script>
 </head>
 <body>
  <p class="MCWebHelpFramesetLink" style="display: none;">
   <a href="../../../idl_CSH.html#Creating IDL Programs/Creating Applications in IDL/Manipulating_Widgets.html" style="">
    Open topic with navigation
   </a>
  </p>
  <div class="MCBreadcrumbsBox_0">
   <span class="MCBreadcrumbsPrefix">
    <![CDATA[ ]]>
   </span>
   <a class="MCBreadcrumbsLink" href="../../IDL Programming.html">
    IDL Programming
   </a>
   <span class="MCBreadcrumbsDivider">
    &gt;
   </span>
   <a class="MCBreadcrumbsLink" href="Widget Application Techniques.html">
    Interfaces (Widgets)
   </a>
   <span class="MCBreadcrumbsDivider">
    &gt;
   </span>
   <a class="MCBreadcrumbsLink" href="../Application Programming/Creating Widget Applications.html">
    Creating Widget Applications
   </a>
   <span class="MCBreadcrumbsDivider">
    &gt;
   </span>
   <span class="MCBreadcrumbs">
    Manipulating Widgets
   </span>
  </div>
  <h1>
   <a name="widget_apps_4063420628_1042022">
   </a>
   <a name="widget_apps_4063420628_42168">
   </a>
   Manipulating Widgets
  </h1>
  <p>
   IDL provides several routines that allow you to
   <a name="kanchor4821">
   </a>
   manipulate and manage widgets programmatically:
  </p>
  <ul>
   <li value="1">
    <a class="MCXref_Heading_0" href="#widget_apps_4063420628_1042047">
     WIDGET_CONTROL
    </a>
    allows you to realize widget hierarchies, manipulate them, and destroy them.
   </li>
   <li value="2">
    <a class="MCXref_Heading_0" href="#widget_apps_4063420628_1042103">
     WIDGET_EVENT
    </a>
    allows you to process events generated by a specific widget hierarchy.
   </li>
   <li value="3">
    <a class="MCXref_Heading_0" href="#widget_apps_4063420628_1042116">
     WIDGET_INFO
    </a>
    allows you to obtain information about the state of a specific widget or widget hierarchy.
   </li>
   <li value="4">
    <a class="MCXref_Heading_0" href="#widget_apps_4063420628_1042130">
     XMANAGER
    </a>
    provides an event loop and manages events generated by all existing widget hierarchies.
   </li>
   <li value="5">
    <a class="MCXref_Heading_0" href="#widget_apps_4063420628_1042139">
     XREGISTERED
    </a>
    allows you to test whether a specific widget is currently registered with XMANAGER.
   </li>
  </ul>
  <p>
   These widget manipulation routines are discussed in more detail in the following sections.
  </p>
  <h2 class="API">
   <a name="widget_apps_4063420628_1042047">
   </a>
   <a name="widget_apps_4063420628_78959">
   </a>
   WIDGET_CONTROL
  </h2>
  <p>
   The
   <a name="kanchor4822">
   </a>
   WIDGET_CONTROL procedure allows you to realize, manage, and destroy widget hierarchies. It is often used to change the default behavior or appearance of previously-realized widgets.
  </p>
  <p>
   Keywords to WIDGET_CONTROL may affect only certain types of widgets, any type of widget, or the widget system in general. See
   <a class="MCXref_Heading_0" href="../../Reference Material/W/WIDGET_CONTROL.html#W_811389549_1232714" target="" title="" alt="">
    WIDGET_CONTROL
   </a>
   for complete details. We discuss here only a few of the more common uses of this procedure.
  </p>
  <h3>
   <a name="kanchor4823">
   </a>
   Realizing Widget Hierarchies
  </h3>
  <p>
   IDL widgets are actually
   <i>
    widget records
   </i>
   that represent platform-specific user interface toolkit elements. In order to instantiate the platform-specific toolkit elements, widgets must be
   <i>
    realized
   </i>
   with the following statement:
  </p>
  <p class="Code">
   WIDGET_CONTROL, base, /REALIZE
  </p>
  <p>
   where
   <span class="Courier">
    base
   </span>
   is the widget ID of the top-level base widget for your widget hierarchy.
  </p>
  <h3>
   <a name="kanchor4824">
   </a>
   Destroying Widget Hierarchies
  </h3>
  <p>
   The standard way to destroy a
   <a name="kanchor4825">
   </a>
   widget hierarchy is with the statement:
  </p>
  <p class="Code">
   WIDGET_CONTROL, base, /DESTROY
  </p>
  <p>
   where
   <span class="Courier">
    base
   </span>
   is the widget ID of the top-level base widget of the hierarchy to be killed. Usually, IDL programs that use widgets issue this statement in their event-handling routine in response to the user’s clicking on a “Done” button in the application.
  </p>
  <p>
   In addition, some window managers place a pulldown menu on the frame of the top-level base widget that allows the user to kill the entire hierarchy. Using the window manager to kill a widget hierarchy is equivalent to using the DESTROY keyword to the WIDGET_CONTROL procedure.
  </p>
  <p>
   When designing widget applications, you should always include a “Done” button (or some other widget that allows the user to exit) in the application itself, since some window managers do not provide the user with a kill option from the outer frame.
  </p>
  <h3>
   <a name="kanchor4826">
   </a>
   Retrieving or Changing Widget Values
  </h3>
  <p>
   You can use WIDGET_CONTROL to
   <a name="kanchor4827">
   </a>
   retrieve or change widget values using the GET_VALUE and SET_VALUE keywords. Similarly, you can retrieve or change widget user values with the GET_UVALUE and SET_UVALUE keywords.
  </p>
  <p>
   For example, you could use the following commands to retrieve the value of a draw widget whose widget ID is stored in the variable
   <span class="Courier">
    drawwid
   </span>
   , and to make that draw widget the current graphics window:
  </p>
  <p class="Code">
   WIDGET_CONTROL, drawwid, GET_VALUE=draw
  </p>
  <p class="Code">
   WSET, draw
  </p>
  <p>
   Similarly, you could use the following command in an event handling procedure to save the user value of the widget that generates an event into an IDL variable named
   <span class="Courier">
    uval
   </span>
   :
  </p>
  <p class="Code">
   WIDGET_CONTROL, event.id, GET_UVALUE=uval
  </p>
  <p>
   For more on widget user values, see
   <a class="MCXref_Heading_0" href="Widget_User_Values.html#widget_apps_4063420628_1042184" target="" title="" alt="">
    Widget User Values
   </a>
   .
  </p>
  <h3>
   <a name="widget_apps_4063420628_1042081">
   </a>
   <a name="widget_apps_4063420628_87407">
   </a>
   Controlling Widget Visibility
  </h3>
  <p>
   <a name="kanchor4828">
   </a>
   You can display or remove realized
   <a name="kanchor4829">
   </a>
   widgets from the screen by
   <i>
    mapping
   </i>
   or
   <i>
    unmapping
   </i>
   them. Unmapped widgets still exist in the widget hierarchy, but they are not displayed and do not generate events.
  </p>
  <p>
   Set the MAP keyword to WIDGET_CONTROL equal to zero to hide a widget, or to a nonzero value to display it again. For example, to hide the
   <span class="Courier">
    base1
   </span>
   widget and all its child widgets from view, use the following command:
  </p>
  <p class="Code">
   WIDGET_CONTROL, base1, MAP=0
  </p>
  <p>
   By default, widgets are mapped automatically when they are realized. You can prevent a widget from appearing on screen when you realize it by setting MAP=0
   <i>
    before
   </i>
   realizing the widget hierarchy.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   While it is possible to call WIDGET_CONTROL, MAP=0 with the widget ID of any widget, only base widgets can actually be unmapped. If you specify a widget ID that is not from a base widget, IDL searches upward in the widget hierarchy until it finds the closest base widget. The map operation is applied to that base.
  </p>
  <h3>
   <a name="widget_apps_4063420628_1042091">
   </a>
   <a name="kanchor4830">
   </a>
   <a name="widget_apps_4063420628_72720">
   </a>
   Sensitizing Widgets
  </h3>
  <p>
   <a name="kanchor4831">
   </a>
   Use sensitivity to control when a user is allowed to manipulate a widget. When a widget is sensitive, it has a normal appearance and can receive user input. When a widget is insensitive, it ignores any input directed at it. Note that while most widgets change their appearance when they become insensitive, some simply stop generating events.
  </p>
  <p>
   Set the SENSITIVE keyword equal to zero to desensitize a widget, or to a nonzero value to make it sensitive. For example, you might wish to make a group of buttons contained in a base whose widget ID is stored in the variable
   <span class="Courier">
    bgroup
   </span>
   insensitive after some user input. You would use the following command:
  </p>
  <p class="Code">
   WIDGET_CONTROL, bgroup, SENSITIVE=0
  </p>
  <h3>
   <a name="widget_apps_4063420628_1042097">
   </a>
   <a name="widget_apps_4063420628_40225">
   </a>
   Indicating Time-Consuming Operations
  </h3>
  <p>
   In an event driven environment, it is important that the interface be highly responsive to the user’s manipulations.
   <a name="kanchor4832">
   </a>
   Widget event handlers should be written to execute quickly and return. However, sometimes the event handler has no option but to perform an operation that is slow. In such a case, it is a good idea to give the user feedback that the system is busy. This is easily done using the HOURGLASS keyword just before the expensive operation is started:
  </p>
  <p class="Code">
   WIDGET_CONTROL, /HOURGLASS
  </p>
  <p>
   This command causes IDL to turn on an hourglass-shaped cursor for all IDL widgets and graphics windows. The hourglass remains active until the next event is processed, at which point the previous cursor is automatically restored.
  </p>
  <h2 class="API">
   <a name="widget_apps_4063420628_1042103">
   </a>
   <a name="widget_apps_4063420628_92658">
   </a>
   WIDGET_EVENT
  </h2>
  <p>
   The
   <a name="kanchor4833">
   </a>
   WIDGET_EVENT function returns events for the widget hierarchy rooted at
   <i>
    Widget_ID
   </i>
   . Events are generated when a button is pressed, a slider position is changed, and so forth. In most cases, you will not use WIDGET_EVENT directly, but instead will use the
   <a class="MCXref_Heading_0" href="#widget_apps_4063420628_1042130">
    XMANAGER
   </a>
   routine to manage widget events. Event processing is discussed in detail in
   <a class="MCXref_Heading_0" href="Widget_Event_Processing.html#widget_apps_4063420628_1042201" target="" title="" alt="">
    Widget Event Processing
   </a>
   . See also
   <a class="MCXref_Heading_0" href="../../Reference Material/W/WIDGET_EVENT.html#W_811389549_680296" target="" title="" alt="">
    WIDGET_EVENT
   </a>
   for additional details.
  </p>
  <h2 class="API">
   <a name="widget_apps_4063420628_1042116">
   </a>
   <a name="widget_apps_4063420628_16908">
   </a>
   WIDGET_INFO
  </h2>
  <p>
   The
   <a name="kanchor4834">
   </a>
   WIDGET_INFO function is used to obtain information about the widget subsystem and individual widgets. You supply the widget ID of a widget for which you want to retrieve some information, along with a keyword that specifies the type of information. For example, to determine the index of the selected item in a list widget whose widget ID is contained in the variable
   <span class="Courier">
    list
   </span>
   , you would use a command like the following:
  </p>
  <p class="Code">
   listindex = WIDGET_INFO(list, /LIST_SELECT)
  </p>
  <h3>
   Finding Widget IDs using WIDGET_INFO
  </h3>
  <p>
   One noteworthy use of WIDGET_INFO is to locate the widget ID of a widget with a specified
   <i>
    user name
   </i>
   . (A
   <i>
    user name
   </i>
   is a part of the widget’s widget record that contains a text identifier, specified by the programmer.) See
   <a class="MCXref_Heading_0" href="Working_With_Widget_IDs.html#widget_apps_4063420628_1042151" target="" title="" alt="">
    Working With Widget IDs
   </a>
   for more information on this technique.
  </p>
  <p>
   See
   <a class="MCXref_Heading_0" href="../../Reference Material/W/WIDGET_INFO.html#W_811389549_680333" target="" title="" alt="">
    WIDGET_INFO
   </a>
   for more information.
  </p>
  <h2 class="API">
   <a name="widget_apps_4063420628_1042130">
   </a>
   <a name="widget_apps_4063420628_99783">
   </a>
   XMANAGER
  </h2>
  <p>
   The
   <a name="kanchor4835">
   </a>
   XMANAGER procedure provides the main event loop registration and widget management. Calling XMANAGER “registers” a widget program with the XMANAGER event handler. XMANAGER takes control of event processing until all widgets have been destroyed.
  </p>
  <p>
   Using XMANAGER allows you to run multiple widget applications and work at the IDL command line at the same time. While it is possible to use WIDGET_EVENT directly to manage events in your application, it is almost always easier to use XMANAGER.
  </p>
  <p>
   See
   <a class="MCXref_Heading_0" href="../../Reference Material/X/XMANAGER.html#X_800576109_762775" target="" title="" alt="">
    XMANAGER
   </a>
   for complete details.
  </p>
  <h2 class="API">
   <a name="widget_apps_4063420628_1042139">
   </a>
   <a name="widget_apps_4063420628_17272">
   </a>
   XREGISTERED
  </h2>
  <p>
   The
   <a name="kanchor4836">
   </a>
   XREGISTERED function returns True if the widget specified by its argument is currently registered with the XMANAGER.
  </p>
  <p>
   One use of the XREGISTERED function is to control the number of instances of a given widget application that run at a given time. For example, suppose that you have a widget program that registers itself with the XMANAGER with the command:
  </p>
  <p class="Code">
   XMANAGER, 'mywidget', base
  </p>
  <p>
   You could limit this widget to one instantiation by adding the following line as the first line (after the procedure definition statement) of the widget creation routine:
  </p>
  <p class="Code">
   IF (XREGISTERED('mywidget') NE 0) THEN RETURN
  </p>
  <p>
   See
   <a class="MCXref_Heading_0" href="../../Reference Material/X/XREGISTERED.html#X_800576109_762885" target="" title="" alt="">
    XREGISTERED
   </a>
   for complete details.
  </p>
  <div class="mp_footer">
   Copyright ©
   <span class="DocumentTitleCopyrightYear">
    2012
   </span>
   <![CDATA[ ]]>
   <span class="DocumentTitleCopyrightCompanyName">
    Exelis Visual Information Solutions, Inc.
   </span>
   All Rights Reserved.
  </div>
  <script type="text/javascript" src="../../SkinSupport/MadCapBodyEnd.js">
  </script>
 </body>
</html>