<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns:madcap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" madcap:lastblockdepth="2" madcap:lastheight="135.6667" madcap:lastwidth="592" madcap:disablemasterstylesheet="true" madcap:tocpath="IDL Programming|Objects|Object-Oriented Programming|Creating an Object Graphics Display" madcap:medium="non-print" madcap:inpreviewmode="false" madcap:preloadimages="false" madcap:runtimefiletype="Topic" madcap:targettype="WebHelp" lang="en-US" xml:lang="en-US" madcap:pathtohelpsystem="../../" madcap:helpsystemfilename="idl.xml" madcap:searchtype="Stem">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>
   Controlling Object Transparency
  </title>
  <link href="../SkinSupport/MadCap.css" rel="stylesheet" />
  <link href="../Resources/TableStyles/NoLines.css" rel="stylesheet" />
  <link href="../Resources/TableStyles/Figure_Format.css" rel="stylesheet" />
  <link href="../Resources/Stylesheets/IDL_style.css" rel="stylesheet" />
  <script src="../SkinSupport/MadCapAll.js" type="text/javascript">
  </script>
 </head>
 <body>
  <p class="MCWebHelpFramesetLink" style="display: none;">
   <a href="../../idl_CSH.html#Objects/Controlling_Object_Trans.html" style="">
    Open topic with navigation
   </a>
  </p>
  <div class="MCBreadcrumbsBox_0">
   <span class="MCBreadcrumbsPrefix">
    <![CDATA[ ]]>
   </span>
   <a class="MCBreadcrumbsLink" href="../IDL Programming.html">
    IDL Programming
   </a>
   <span class="MCBreadcrumbsDivider">
    &gt;
   </span>
   <a class="MCBreadcrumbsLink" href="../Object Classes/ref_part2.html">
    Objects
   </a>
   <span class="MCBreadcrumbsDivider">
    &gt;
   </span>
   <span class="MCBreadcrumbsSelf">
    Object-Oriented Programming
   </span>
   <span class="MCBreadcrumbsDivider">
    &gt;
   </span>
   <span class="MCBreadcrumbs">
    Controlling Object Transparency
   </span>
  </div>
  <h1>
   <a name="obj_graphics_348174843_1014081">
   </a>
   <a name="obj_graphics_348174843_27673">
   </a>
   Co
   <a name="kanchor3750">
   </a>
   ntrolling Object Transparency
  </h1>
  <p>
   IDL objects which support an alpha channel are:
  </p>
  <table style="width: 271px;caption-side: top;mc-table-style: url('../Resources/TableStyles/NoLines.css');" cellspacing="0" class="TableStyle_NoLines">
   <col width="132px" />
   <col width="139px" />
   <tbody>
    <tr>
     <td class="TableStyle_NoLines_Body_0_0_RowSep_ColSep">
      <p>
       IDLgrAxis
      </p>
     </td>
     <td class="TableStyle_NoLines_Body_0_0_RowSep_ColEnd">
      <p>
       IDLgrContour
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_NoLines_Body_0_0_RowSep_ColSep">
      <p>
       IDLgrImage
      </p>
     </td>
     <td class="TableStyle_NoLines_Body_0_0_RowSep_ColEnd">
      <p>
       IDLgrPlot
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_NoLines_Body_0_0_RowSep_ColSep">
      <p>
       IDLgrPolygon
      </p>
     </td>
     <td class="TableStyle_NoLines_Body_0_0_RowSep_ColEnd">
      <p>
       IDLgrPolyline
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_NoLines_Body_0_0_RowSep_ColSep">
      <p>
       IDLgrROI
      </p>
     </td>
     <td class="TableStyle_NoLines_Body_0_0_RowSep_ColEnd">
      <p>
       IDLgrSurface
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_NoLines_Body_0_0_RowSep_ColSep">
      <p>
       IDLgrSymbol
      </p>
     </td>
     <td class="TableStyle_NoLines_Body_0_0_RowSep_ColEnd">
      <p>
       IDLgrText
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_NoLines_Body_0_0_RowEnd_ColSep">
      <p>
       IDLgrVolume
      </p>
     </td>
     <td class="TableStyle_NoLines_Body_0_0_RowEnd_ColEnd">
      <p>
       &#160;
      </p>
     </td>
    </tr>
   </tbody>
  </table>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   The transparency of an IDLgrImage object can be defined using a band of data defining the alpha values, and/or the ALPHA_CHANNEL property. Regardless of which way the image transparency is defined, you also need to set BLEND_FUNCTION property.
  </p>
  <p>
   The alpha channel has many uses. One of the most important is drawing primitives semi-transparently, which can be used to enhance your object graphics scene. An example might be a text label drawn semi-transparently to let other graphical details “show through” the text label. This would allow you to use a larger text font size, rather than using a small font size to squeeze text between details in a scene. Another use for alpha channel might be to draw polygons and surfaces semi-transparently, allowing you to see “inside” certain objects and structures.
  </p>
  <p>
   Some of the most important uses for semi-transparent rendering are discussed in the following sections.
  </p>
  <ul>
   <li value="1">
    <a class="MCXref_Heading_0" href="#obj_graphics_348174843_1013893" target="" title="" alt="">
     Opacity and Transparency
    </a>
   </li>
   <li value="2">
    <a class="MCXref_Heading_0" href="#obj_graphics_348174843_1013897" target="" title="" alt="">
     Blending Mathematics
    </a>
   </li>
   <li value="3">
    <a class="MCXref_Heading_0" href="#obj_graphics_348174843_1013910" target="" title="" alt="">
     Rendering Order
    </a>
   </li>
   <li value="4">
    <a class="MCXref_Heading_0" href="#obj_graphics_348174843_1013921" target="" title="" alt="">
     Viewing and Rotation
    </a>
   </li>
   <li value="5">
    <a class="MCXref_Heading_0" href="#obj_graphics_348174843_1013928" target="" title="" alt="">
     Depth Buffer Updating
    </a>
   </li>
  </ul>
  <h2 class="API">
   <a name="obj_graphics_348174843_1013893">
   </a>
   <a name="obj_graphics_348174843_56874">
   </a>
   Opacity and Transparency
  </h2>
  <p>
   Opacity describes the degree to which an object blocks the appearance of other objects. In IDL, the value used for the ALPHA_CHANNEL properties in IDLgr* objects is a measure of the object's opacity. A value of 1.0 indicates complete opacity. The object completely blocks the appearance of other objects. Conversely, an opacity value of 0.0 indicates that the object does not block the appearance of objects at all. Intermediate values indicate varying degrees of visibility for covered objects.
  </p>
  <p>
   Transparency is essentially the opposite of opacity. Transparency indicates the degree to which an object does not block the appearance of other objects. Complete or full transparency is indicated by an opacity value of 0.0, while an object that is not transparent at all has an opacity value of 1.0.
  </p>
  <p>
   By default all IDLgr* graphic objects use an ALPHA_CHANNEL value of 1.0, indicating full opacity (zero transparency), matching the rendering behavior before the addition of the ALPHA_CHANNEL property. To change the opacity of the object, simply change the this property to a value between 0.0 (zero opacity or full transparency) and 1.0.
  </p>
  <h2 class="API">
   <a name="obj_graphics_348174843_1013897">
   </a>
   <a name="obj_graphics_348174843_83620">
   </a>
   Blending Mathematics
  </h2>
  <p>
   Blending is the drawing of semi-transparent objects on a screen already containing objects. During rendering, the color of the pixels belonging to the primitive being rendered are blended with the color of the pixels that are already on the screen, producing the desired blending effect. This process is accomplished on a pixel-by-pixel basis.
  </p>
  <p>
   IDL uses this well-established blending equation:
  </p>
  <p class="Code" style="font-family: Courier;">
   <span class="Courier">
    newColor = oldColor * (1 - alpha) + primitiveColor * alpha
   </span>
  </p>
  <p>
   An example might suppose that you want to draw a red square in an area of the screen that is completely green. By default, the alpha value is 1.0, so the result is:
  </p>
  <p class="Code">
   [255, 0, 0] = [0, 255, 0] * (1.0 - 1.0) + [255, 0, 0] * 1.0
  </p>
  <p>
   The green color is removed completely and replaced by red, the expected result of conventional non-blended rendering.
  </p>
  <p>
   If the alpha value is changed to equal 0.5, the result is:
  </p>
  <p class="Code">
   [127, 127, 0] = [0, 255, 0] * (1.0-0.5) + [255, 0, 0] * 0.5
  </p>
  <p>
   The resulting color is the half of the red of the polygon combined with half of the green of the background, a pale yellow.
  </p>
  <p>
   If you draw another red square in the same place with the same alpha, the red square is blended with the now current contents of the screen:
  </p>
  <p class="Code">
   [190, 63, 0] = [127, 127, 0] * (1.0-0.5) + [255, 0, 0] * 0.5
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   Large levels of semi-transparent rendering may reduce rendering performance. This is because the graphics blending operation that is performed involves reading the destination pixel from the frame buffer, combining it with the new color value and then writing the result back to the frame buffer. This is more expensive than simply overwriting the frame buffer contents with the new color value. The degree to which your performance will be impacted depends heavily on the hardware and software components of your graphics system.
  </p>
  <h2 class="API">
   <a name="obj_graphics_348174843_1013910">
   </a>
   <a name="obj_graphics_348174843_85629">
   </a>
   Rendering Order
  </h2>
  <p>
   The colors of the pixels on the screen are important when drawing a blended primitive. Similarly, the order in which the primitives are drawn is also very important when drawing scenes with blended primitives.
  </p>
  <p>
   In computer graphics, depth sorting presents a similar challenge. Without depth sorting, a scene would have to be drawn from back to front to obtain a correct result. IDL handles depth sorting by providing a "depth buffer" (also known as a "Z-buffer") allowing you to draw the primitives in any order while allowing the primitives closer to the viewer to still appear to be on top.
  </p>
  <p>
   There is no similar feature for alpha-blended primitives. Be sure to draw the blended primitives carefully so that all primitives behind a blended primitive are drawn before the blended primitive.
  </p>
  <p>
   If your scene consists of many primitives that are not blended and a few text labels that are drawn with blending, it is a good idea to defer the drawing of the labels until after everything else is drawn. This will allow users to see through all labels and to see the objects beneath. If a non-blended primitive is drawn on top of and after a blended primitive, it will cover the blended primitive. If any primitive is drawn behind but after a blended primitive, the primitive drawn later will not appear where the blended primitive covers it, due to depth buffering. In other words, it is not possible to blend primitives unless all objects behind the blended primitive which are to be blended are already drawn.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   If you have a complex scene where many primitives are blended, it may be difficult to determine the proper ordering.
  </p>
  <h3>
   Inter- and Intra-primitive Rendering Orders
  </h3>
  <p>
   Inter-primitive rendering order deals with the ordering of primitive objects within an IDLgrModel. For primitives which do not intersect each other, it is straightforward to order these in a back-to-front viewing order, particularly if your scene is fixed so it cannot be rotated by the user. This is done by arranging your primitives along the Z direction so that the objects farthest away appear first in the IDLgrModels, which makes them draw first.
  </p>
  <p>
   If primitives intersect, it may be necessary to divide the object so that the back parts of each primitive are drawn first, and then the front parts. This can be a very difficult issue.
  </p>
  <p>
   Intra-primitive rendering order deals with the ordering of graphical items within an IDL graphics primitive. Some primitives, such as IDLgrSurface and IDLgrPolygon actually consist of a large number of individual polygons. They are not all drawn at once, and the order in which they are drawn is also important when drawing with blending.
  </p>
  <p>
   You can control the order in which the individual polygons are drawn in an IDLgrPolygon object by ordering the vertices or specifying the order in the POLYGONS property. Polygons specified first in the POLYGONS list are drawn first.
  </p>
  <h2 class="API">
   <a name="obj_graphics_348174843_1013921">
   </a>
   <a name="obj_graphics_348174843_56077">
   </a>
   Viewing and Rotation
  </h2>
  <p>
   If you draw a typical height field with IDLgrSurface and invoke blending, the object might look right from some viewing orientations.
  </p>
  <p>
   For example, try the following:
  </p>
  <p class="Code">
   XOBJVIEW, OBJ_NEW('idlgrsurface',$ BESELJ(shift(dist(40),20,20)/2,0) * 20, STYLE=2,$
  </p>
  <p class="Code">
   &#160;&#160;&#160;ALPHA_CHANNEL=0.5)
  </p>
  <table style="width: 517px;caption-side: bottom;mc-table-style: url('../Resources/TableStyles/Figure_Format.css');" class="TableStyle_Figure_Format" cellspacing="0">
   <caption valign="bottom" style="padding-bottom: 12pt;">
   </caption>
   <p class="FigureTitle">
    Viewing Alpha Channel in an Object
   </p>
   <col width="517px" />
   <tbody>
    <tr>
     <td class="TableStyle_Figure_Format_Body_0_0_RowEnd_ColEnd">
      <p style="text-align: center;">
       <img src="../images/alphachannel1.gif" style="margin-left: 5.99976px;margin-top: 5.99976px;margin-right: 6.000484px;margin-bottom: 6.000484px;" />
      </p>
     </td>
    </tr>
   </tbody>
  </table>
  <p>
   Notice in the previous figure that you can see-through the waves in the object to see other waves, but only when you view the object from certain directions. From other directions, all you see are the waves closer to you.
  </p>
  <p>
   Solving this problem can be extremely difficult. A complete solution would generate a scene for every possible viewing angle, where the polygons are drawn back to front, splitting them if necessary. There are several techniques available for accomplishing this, one of them being the Binary Space Partition Tree, however this is not supported directly in IDL. If the objects are simple, it might be possible to construct a few scenes that give correct or passable results.
  </p>
  <p>
   For example, if you wanted to look at a semi-transparent sphere from all angles, creating eight models might suffice. Each of the eight models contains the polygons sorted in back-to-front order for a viewing direction corresponding to each of the eight octants formed by the half spaces of the three principle axes. As the user rotates the scene with a trackball, the program would select the appropriate model, based on the current viewing direction. More complex scenes may require more models.
  </p>
  <h2 class="API">
   <a name="obj_graphics_348174843_1013928">
   </a>
   <a name="obj_graphics_348174843_82710">
   </a>
   Depth Buffer Updating
  </h2>
  <p>
   For any value of the ALPHA_CHANNEL property, IDL updates the depth buffer when the primitive is drawn, unless the DEPTH_WRITE_DISABLE property is set to a value that disables depth buffer updates. Thus, even if you draw a completely transparent primitive, the depth buffer is updated as if there were a visible primitive drawn there. This means that subsequent primitives drawn behind the transparent object are not visible. Though potentially confusing, this can also be a useful way to hide objects in certain situations.
  </p>
  <p>
   After drawing a transparent object, that there may be gaps in objects drawn later. For example, suppose lines in a plot are drawn with ALPHA_CHANNEL=0 (transparent), and then symbols are drawn. Where the symbols and lines intersect, there are gaps in the symbols. The gaps are caused by the invisible lines changing the depth buffer, thus masking out the symbols that are drawn later. At times, the ability to modify the depth buffer without changing the color buffer is a useful tool for clever clipping operations. In other contexts, you may consider using invisible polygons to mask out entire areas. However, if the partial or entire invisibility of objects drawn after a transparent object is unintended use one of the following options:
  </p>
  <ul>
   <li value="1">
    Set the DEPTH_TEST_FUNCTION=4, or disable depth testing entirely using the DEPTH_WRITE_DISABLE property.
   </li>
   <li value="2">
    Set the HIDE property to 1 if ALPHA_CHANNEL becomes 0.
   </li>
  </ul>
  <p>
   Either of these options would erase the gaps in the symbols caused by the transparent plot lines as described in the previous situation.
  </p>
  <div class="mp_footer">
   Copyright ©
   <span class="DocumentTitleCopyrightYear">
    2012
   </span>
   <![CDATA[ ]]>
   <span class="DocumentTitleCopyrightCompanyName">
    Exelis Visual Information Solutions, Inc.
   </span>
   All Rights Reserved.
  </div>
  <script type="text/javascript" src="../SkinSupport/MadCapBodyEnd.js">
  </script>
 </body>
</html>