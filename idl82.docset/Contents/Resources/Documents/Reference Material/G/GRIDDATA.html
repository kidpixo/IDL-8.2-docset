<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns:madcap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" madcap:lastblockdepth="2" madcap:lastheight="135.6667" madcap:lastwidth="592" madcap:disablemasterstylesheet="true" madcap:tocpath="Routines (alphabetical)|Routines: G" madcap:medium="non-print" madcap:inpreviewmode="false" madcap:preloadimages="false" madcap:runtimefiletype="Topic" madcap:targettype="WebHelp" lang="en-US" xml:lang="en-US" madcap:pathtohelpsystem="../../../" madcap:helpsystemfilename="idl.xml" madcap:searchtype="Stem">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>
   GRIDDATA
  </title>
  <link href="../../SkinSupport/MadCap.css" rel="stylesheet" />
  <link href="../../Resources/TableStyles/NoLines.css" rel="stylesheet" />
  <link href="../../Resources/TableStyles/Keyword_Table.css" rel="stylesheet" />
  <link href="../../Resources/TableStyles/Description.css" rel="stylesheet" />
  <link href="../../Resources/TableStyles/VersionTable.css" rel="stylesheet" />
  <link href="../../Resources/Stylesheets/IDL_style.css" rel="stylesheet" />
  <script src="../../SkinSupport/MadCapAll.js" type="text/javascript">
  </script>
 </head>
 <body>
  <p class="MCWebHelpFramesetLink" style="display: none;">
   <a href="../../../idl_CSH.html#Reference Material/G/GRIDDATA.html" style="">
    Open topic with navigation
   </a>
  </p>
  <div class="MCBreadcrumbsBox_0">
   <span class="MCBreadcrumbsPrefix">
    <![CDATA[ ]]>
   </span>
   <a class="MCBreadcrumbsLink" href="../../images/ref_part1.html">
    Routines (alphabetical)
   </a>
   <span class="MCBreadcrumbsDivider">
    &gt;
   </span>
   <a class="MCBreadcrumbsLink" href="G_list.html">
    Routines: G
   </a>
   <span class="MCBreadcrumbsDivider">
    &gt;
   </span>
   <span class="MCBreadcrumbs">
    GRIDDATA
   </span>
  </div>
  <h1 class="Routine">
   <a name="G_845992557_884941">
   </a>
   <a name="G_845992557_50011">
   </a>
   GRIDDATA
  </h1>
  <p madcap:conditions="Reference Material.Online_Help_Only">
   <madcap:conditionaltext madcap:conditions="Reference Material.Online_Help_Only">
    <a class="MCXref_Heading_0" href="#G_845992557_877537">
     Syntax
    </a>
    |
    <a class="MCXref_Heading_0" href="#G_845992557_899603">
     Return Value
    </a>
    |
    <a class="MCXref_Heading_0" href="#G_845992557_877560">
     Arguments
    </a>
    |
    <a class="MCXref_Heading_0" href="#G_845992557_877567">
     Keywords
    </a>
    |
    <a class="MCXref_Heading_0" href="#G_845992557_877787">
     Examples
    </a>
    |
    <a class="MCXref_Heading_0" href="#G_845992557_878207">
     Version History
    </a>
    |
    <a class="MCXref_Heading_0" href="#G_845992557_881408">
     See Also
    </a>
   </madcap:conditionaltext>
  </p>
  <p>
   The
   <a name="kanchor1103">
   </a>
   GRIDDATA function
   <a name="kanchor1104">
   </a>
   interpolates scattered data values on a plane or a sphere to a regular grid, an irregular grid, a specified set of interpolates, or scattered data points. The returned value is a two-dimensional floating point array. Computations are performed in double-precision floating point. The following interpolation methods are supported:
  </p>
  <table style="caption-side: top;mc-table-style: url('../../Resources/TableStyles/NoLines.css');margin-left: 0;margin-right: auto;" cellspacing="0" class="TableStyle_NoLines">
   <col width="217px" />
   <col width="202px" />
   <tbody>
    <tr>
     <td class="TableStyle_NoLines_Body_0_0_RowSep_ColSep">
      <p>
       Inverse Distance (default)
      </p>
     </td>
     <td class="TableStyle_NoLines_Body_0_0_RowSep_ColEnd">
      <p>
       Natural Neighbor
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_NoLines_Body_0_0_RowSep_ColSep">
      <p>
       Kriging
      </p>
     </td>
     <td class="TableStyle_NoLines_Body_0_0_RowSep_ColEnd">
      <p>
       Nearest Neighbor
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_NoLines_Body_0_0_RowSep_ColSep">
      <p>
       Linear
      </p>
     </td>
     <td class="TableStyle_NoLines_Body_0_0_RowSep_ColEnd">
      <p>
       Polynomial Regression
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_NoLines_Body_0_0_RowSep_ColSep">
      <p>
       Minimum Curvature
      </p>
     </td>
     <td class="TableStyle_NoLines_Body_0_0_RowSep_ColEnd">
      <p>
       Quintic
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_NoLines_Body_0_0_RowEnd_ColSep">
      <p>
       Modified Shepard’s
      </p>
     </td>
     <td class="TableStyle_NoLines_Body_0_0_RowEnd_ColEnd">
      <p>
       Radial Basis Function
      </p>
     </td>
    </tr>
   </tbody>
  </table>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   GRIDDATA accepts complex input but only utilizes the real part of any complex number.
  </p>
  <h2 class="API">
   <a name="G_845992557_877537">
   </a>
   <a name="G_845992557_877537_PageTOC_GRIDDATA_">
   </a>
   Syntax
  </h2>
  <h4>
   Interleaved
  </h4>
  <p class="Syntax">
   <i>
    Result
   </i>
   = GRIDDATA(&#160;
   <i>
    X
   </i>
   ,
   <i>
    F
   </i>
   )
  </p>
  <h4>
   Planar
  </h4>
  <p class="Syntax">
   <i>
    Result
   </i>
   = GRIDDATA(&#160;
   <i>
    X
   </i>
   ,
   <i>
    Y
   </i>
   ,
   <i>
    F
   </i>
   &#160;)
  </p>
  <h4>
   Sphere From Cartesian Coordinates
  </h4>
  <p class="Syntax">
   <i>
    Result
   </i>
   = GRIDDATA(&#160;
   <i>
    X
   </i>
   ,
   <i>
    Y
   </i>
   ,&#160;
   <i>
    Z
   </i>
   ,&#160;
   <i>
    F
   </i>
   , &#160;/
   <a class="MCXref_Heading_0" href="#G_845992557_877769">
    SPHERE
   </a>
   &#160;)
  </p>
  <h4>
   Sphere From Spherical Coordinates
  </h4>
  <p class="Syntax">
   <i>
    Result
   </i>
   = GRIDDATA(&#160;
   <i>
    Lon
   </i>
   ,&#160;
   <i>
    Lat
   </i>
   ,&#160;
   <i>
    F
   </i>
   , &#160;/
   <a class="MCXref_Heading_0" href="#G_845992557_877769">
    SPHERE
   </a>
   &#160;)
  </p>
  <p class="Syntax">
   <span class="Bold">
    Inverse Distance Keywords:
   </span>
   [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877664">
    METHOD
   </a>
   ='
   <i>
    InverseDistance
   </i>
   '&#160;|&#160;/
   <a class="MCXref_Heading_0" href="#G_845992557_877655">
    INVERSE_DISTANCE
   </a>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877568">
    ANISOTROPY
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#G_845992557_877573">
    DEGREES
   </a>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877575">
    DELTA
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877578">
    DIMENSION
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877774">
    TRIANGLES
   </a>
   =
   <i>
    array
   </i>
   &#160;[,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877581">
    EMPTY_SECTORS
   </a>
   =
   <i>
    value
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877661">
    MAX_PER_SECTOR
   </a>
   =
   <i>
    value
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877715">
    MIN_POINTS
   </a>
   =
   <i>
    value
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877757">
    SEARCH_ELLIPSE
   </a>
   =
   <i>
    vector
   </i>
   &#160;]&#160;]&#160; [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877584">
    FAULT_POLYGONS
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877588">
    FAULT_XY
   </a>
   =
   <i>
    array
   </i>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#G_845992557_877652">
    GRID
   </a>
   ,
   <a class="MCXref_Heading_0" href="#G_845992557_877781">
    XOUT
   </a>
   =
   <i>
    vector
   </i>
   ,
   <a class="MCXref_Heading_0" href="#G_845992557_877784">
    YOUT
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877719">
    MISSING
   </a>
   =
   <i>
    value
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877749">
    POWER
   </a>
   =
   <i>
    value
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877761">
    SECTORS
   </a>
   ={1&#160;|&#160;2&#160;|&#160;3&#160;|&#160;4&#160;|&#160;5&#160;|&#160;6&#160;|&#160;7&#160;|&#160;8&#160;}&#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877766">
    SMOOTHING
   </a>
   =
   <i>
    value
   </i>
   &#160;] [, /
   <a class="MCXref_Heading_0" href="#G_845992557_877769">
    SPHERE
   </a>
   ] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877771">
    START
   </a>
   =
   <i>
    vector
   </i>
   &#160;]
  </p>
  <p class="Syntax">
   <span class="Bold">
    Kriging Keywords:
   </span>
   <br />
   [&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877664">
    METHOD
   </a>
   ='
   <i>
    Kriging
   </i>
   '&#160;|&#160;/
   <a class="MCXref_Heading_0" href="#G_845992557_877657">
    KRIGING
   </a>
   &#160; [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877568">
    ANISOTROPY
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877575">
    DELTA
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877578">
    DIMENSION
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877774">
    TRIANGLES
   </a>
   =
   <i>
    array
   </i>
   &#160;[,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877581">
    EMPTY_SECTORS
   </a>
   =
   <i>
    value
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877661">
    MAX_PER_SECTOR
   </a>
   =
   <i>
    value
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877715">
    MIN_POINTS
   </a>
   =
   <i>
    value
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877757">
    SEARCH_ELLIPSE
   </a>
   =
   <i>
    vector
   </i>
   &#160;]&#160;]&#160; [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877584">
    FAULT_POLYGONS
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877588">
    FAULT_XY
   </a>
   =
   <i>
    array
   </i>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#G_845992557_877652">
    GRID
   </a>
   ,
   <a class="MCXref_Heading_0" href="#G_845992557_877781">
    XOUT
   </a>
   =
   <i>
    vector
   </i>
   ,
   <a class="MCXref_Heading_0" href="#G_845992557_877784">
    YOUT
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877719">
    MISSING
   </a>
   =
   <i>
    value
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877761">
    SECTORS
   </a>
   ={1&#160;|&#160;2&#160;|&#160;3&#160;|&#160;4&#160;|&#160;5&#160;|&#160;6&#160;|&#160;7&#160;|&#160;8&#160;}&#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#G_845992557_877769">
    SPHERE
   </a>
   ] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877771">
    START
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877778">
    VARIOGRAM
   </a>
   =
   <i>
    vector
   </i>
   &#160;]
  </p>
  <p class="Syntax">
   <span class="Bold">
    Linear Interpolation Keywords:
   </span>
   [&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877664">
    METHOD
   </a>
   ='
   <i>
    Linear
   </i>
   '&#160;|&#160;/
   <a class="MCXref_Heading_0" href="#G_845992557_877659">
    LINEAR
   </a>
   &#160;,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877774">
    TRIANGLES
   </a>
   =
   <i>
    array
   </i>
   &#160; [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877575">
    DELTA
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877578">
    DIMENSION
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#G_845992557_877652">
    GRID
   </a>
   ,
   <a class="MCXref_Heading_0" href="#G_845992557_877781">
    XOUT
   </a>
   =
   <i>
    vector
   </i>
   ,
   <a class="MCXref_Heading_0" href="#G_845992557_877784">
    YOUT
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877719">
    MISSING
   </a>
   =
   <i>
    value
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877771">
    START
   </a>
   =
   <i>
    vector
   </i>
   &#160;]&#160;
  </p>
  <p class="Syntax">
   <span class="Bold">
    Minimum Curvature Keywords:
   </span>
   [&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877664">
    METHOD
   </a>
   ='
   <i>
    MinimumCurvature
   </i>
   '&#160;|&#160;/
   <a class="MCXref_Heading_0" href="#G_845992557_877713">
    MIN_CURVATURE
   </a>
   [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877575">
    DELTA
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877578">
    DIMENSION
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877771">
    START
   </a>
   =
   <i>
    vector
   </i>
   &#160;]&#160;
  </p>
  <p class="Syntax">
   <span class="Bold">
    Modified Shepard’s Keywords:
   </span>
   <br />
   [&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877664">
    METHOD
   </a>
   ='
   <i>
    ModifiedShepards
   </i>
   '&#160;|&#160;/
   <a class="MCXref_Heading_0" href="#G_845992557_877763">
    SHEPARDS
   </a>
   ,
   <a class="MCXref_Heading_0" href="#G_845992557_877774">
    TRIANGLES
   </a>
   =
   <i>
    array
   </i>
   &#160; [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877568">
    ANISOTROPY
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877575">
    DELTA
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877578">
    DIMENSION
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877581">
    EMPTY_SECTORS
   </a>
   =
   <i>
    value
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877584">
    FAULT_POLYGONS
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877588">
    FAULT_XY
   </a>
   =
   <i>
    array
   </i>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#G_845992557_877652">
    GRID
   </a>
   ,
   <a class="MCXref_Heading_0" href="#G_845992557_877781">
    XOUT
   </a>
   =
   <i>
    vector
   </i>
   ,
   <a class="MCXref_Heading_0" href="#G_845992557_877784">
    YOUT
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877661">
    MAX_PER_SECTOR
   </a>
   =
   <i>
    value
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877715">
    MIN_POINTS
   </a>
   =
   <i>
    value
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877719">
    MISSING
   </a>
   =
   <i>
    value
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877729">
    NEIGHBORHOOD
   </a>
   =
   <i>
    array
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877757">
    SEARCH_ELLIPSE
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877761">
    SECTORS
   </a>
   ={1&#160;|&#160;2&#160;|&#160;3&#160;|&#160;4&#160;|&#160;5&#160;|&#160;6&#160;|&#160;7&#160;|&#160;8&#160;}&#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877771">
    START
   </a>
   =
   <i>
    vector
   </i>
   &#160;]
  </p>
  <p class="Syntax">
   <span class="Bold">
    Natural Neighbor Keywords:
   </span>
   [&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877664">
    METHOD
   </a>
   ='
   <i>
    NaturalNeighbor
   </i>
   '&#160;|&#160;/
   <a class="MCXref_Heading_0" href="#G_845992557_877723">
    NATURAL_NEIGHBOR
   </a>
   ,
   <a class="MCXref_Heading_0" href="#G_845992557_877774">
    TRIANGLES
   </a>
   =
   <i>
    array
   </i>
   &#160; [,&#160;/
   <a class="MCXref_Heading_0" href="#G_845992557_877573">
    DEGREES
   </a>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877575">
    DELTA
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877578">
    DIMENSION
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#G_845992557_877652">
    GRID
   </a>
   ,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877781">
    XOUT
   </a>
   =
   <i>
    vector
   </i>
   ,
   <a class="MCXref_Heading_0" href="#G_845992557_877784">
    YOUT
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877719">
    MISSING
   </a>
   =
   <i>
    value
   </i>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#G_845992557_877769">
    SPHERE
   </a>
   ]&#160;[,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877771">
    START
   </a>
   =
   <i>
    vector
   </i>
   &#160;]
  </p>
  <p class="Syntax">
   <span class="Bold">
    Nearest Neighbor Keywords:
   </span>
   [&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877664">
    METHOD
   </a>
   ='
   <i>
    NearestNeighbor
   </i>
   '&#160;|&#160;/
   <a class="MCXref_Heading_0" href="#G_845992557_877726">
    NEAREST_NEIGHBOR
   </a>
   ,
   <a class="MCXref_Heading_0" href="#G_845992557_877774">
    TRIANGLES
   </a>
   =
   <i>
    array
   </i>
   &#160; [,&#160;/
   <a class="MCXref_Heading_0" href="#G_845992557_877573">
    DEGREES
   </a>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877575">
    DELTA
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877578">
    DIMENSION
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877584">
    FAULT_POLYGONS
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877588">
    FAULT_XY
   </a>
   =
   <i>
    array
   </i>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#G_845992557_877652">
    GRID
   </a>
   ,
   <a class="MCXref_Heading_0" href="#G_845992557_877781">
    XOUT
   </a>
   =
   <i>
    vector
   </i>
   ,
   <a class="MCXref_Heading_0" href="#G_845992557_877784">
    YOUT
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877719">
    MISSING
   </a>
   =
   <i>
    value
   </i>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#G_845992557_877769">
    SPHERE
   </a>
   ]&#160;[,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877771">
    START
   </a>
   =
   <i>
    vector
   </i>
   &#160;]
  </p>
  <p class="Syntax">
   <span class="Bold">
    Polynomial Regression Keywords:
   </span>
   <a class="MCXref_Heading_0" href="#G_845992557_877664">
    METHOD
   </a>
   ='
   <i>
    PolynomialRegression
   </i>
   '&#160;|&#160;/
   <a class="MCXref_Heading_0" href="#G_845992557_877733">
    POLYNOMIAL_REGRESSION
   </a>
   , [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877575">
    DELTA
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877578">
    DIMENSION
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877774">
    TRIANGLES
   </a>
   =
   <i>
    array
   </i>
   &#160;[,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877581">
    EMPTY_SECTORS
   </a>
   =
   <i>
    value
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877661">
    MAX_PER_SECTOR
   </a>
   =
   <i>
    value
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877715">
    MIN_POINTS
   </a>
   =
   <i>
    value
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877757">
    SEARCH_ELLIPSE
   </a>
   =
   <i>
    vector
   </i>
   &#160;]&#160;]&#160; [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877584">
    FAULT_POLYGONS
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877588">
    FAULT_XY
   </a>
   =
   <i>
    array
   </i>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#G_845992557_877652">
    GRID
   </a>
   ,
   <a class="MCXref_Heading_0" href="#G_845992557_877781">
    XOUT
   </a>
   =
   <i>
    vector
   </i>
   ,
   <a class="MCXref_Heading_0" href="#G_845992557_877784">
    YOUT
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877719">
    MISSING
   </a>
   =
   <i>
    value
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877749">
    POWER
   </a>
   =
   <i>
    value
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877761">
    SECTORS
   </a>
   ={1&#160;|&#160;2&#160;|&#160;3&#160;|&#160;4&#160;|&#160;5&#160;|&#160;6&#160;|&#160;7&#160;|&#160;8&#160;}&#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877771">
    START
   </a>
   =
   <i>
    vector
   </i>
   &#160;]
  </p>
  <p class="Syntax">
   <span class="Bold">
    Quintic Keywords:
   </span>
   <a class="MCXref_Heading_0" href="#G_845992557_877664">
    METHOD
   </a>
   ='
   <i>
    Quintic
   </i>
   '&#160;|&#160;/
   <a class="MCXref_Heading_0" href="#G_845992557_877752">
    QUINTIC
   </a>
   , &#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877774">
    TRIANGLES
   </a>
   =
   <i>
    array
   </i>
   &#160; [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877575">
    DELTA
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877578">
    DIMENSION
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877719">
    MISSING
   </a>
   =
   <i>
    value
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877771">
    START
   </a>
   =
   <i>
    vector
   </i>
   &#160;]&#160;
  </p>
  <p class="Syntax">
   <span class="Bold">
    Radial Basis Function Keywords:
   </span>
   <a class="MCXref_Heading_0" href="#G_845992557_877664">
    METHOD
   </a>
   ='
   <i>
    RadialBasisFunction
   </i>
   '&#160;|&#160;/
   <a class="MCXref_Heading_0" href="#G_845992557_877755">
    RADIAL_BASIS_FUNCTION
   </a>
   , [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877568">
    ANISOTROPY
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#G_845992557_877573">
    DEGREES
   </a>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877575">
    DELTA
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877578">
    DIMENSION
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877774">
    TRIANGLES
   </a>
   =
   <i>
    array
   </i>
   &#160;[,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877581">
    EMPTY_SECTORS
   </a>
   =
   <i>
    value
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877661">
    MAX_PER_SECTOR
   </a>
   =
   <i>
    value
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877715">
    MIN_POINTS
   </a>
   =
   <i>
    value
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877757">
    SEARCH_ELLIPSE
   </a>
   =
   <i>
    vector
   </i>
   &#160;]&#160;]&#160; [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877584">
    FAULT_POLYGONS
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877588">
    FAULT_XY
   </a>
   =
   <i>
    array
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877591">
    FUNCTION_TYPE
   </a>
   ={&#160;0&#160;|&#160;1&#160;|&#160;2&#160;|&#160;3&#160;|&#160;4&#160;}&#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#G_845992557_877652">
    GRID
   </a>
   ,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877781">
    XOUT
   </a>
   =
   <i>
    vector
   </i>
   ,
   <a class="MCXref_Heading_0" href="#G_845992557_877784">
    YOUT
   </a>
   =
   <i>
    vector
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877719">
    MISSING
   </a>
   =
   <i>
    value
   </i>
   &#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877761">
    SECTORS
   </a>
   ={1&#160;|&#160;2&#160;|&#160;3&#160;|&#160;4&#160;|&#160;5&#160;|&#160;6&#160;|&#160;7&#160;|&#160;8&#160;}&#160;] [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877766">
    SMOOTHING
   </a>
   =
   <i>
    value
   </i>
   &#160;] [, /
   <a class="MCXref_Heading_0" href="#G_845992557_877769">
    SPHERE
   </a>
   ]&#160; [,&#160;
   <a class="MCXref_Heading_0" href="#G_845992557_877771">
    START
   </a>
   =
   <i>
    vector
   </i>
   &#160;]
  </p>
  <h2 class="API">
   <a name="G_845992557_899603">
   </a>
   <a name="G_845992557_877558_PageTOC_GRIDDATA_">
   </a>
   Return Value
  </h2>
  <p>
   If any of the input arguments are double precision,
   <i>
    Result
   </i>
   is double precision; otherwise,
   <i>
    Result
   </i>
   is single precision. All computations are performed in double precision.
  </p>
  <h2 class="API">
   <a name="G_845992557_877560">
   </a>
   <a name="G_845992557_877560_PageTOC_GRIDDATA_">
   </a>
   Arguments
  </h2>
  <h3 class="Argument">
   X, Y, Z
  </h3>
  <p>
   The point locations. If only one input coordinate parameter is supplied, the points are interleaved; for the Cartesian coordinate system the points are 2-by-
   <i>
    n
   </i>
   dimensions; and 3-by-
   <i>
    n
   </i>
   for a sphere in Cartesian coordinates.
  </p>
  <h3 class="Argument">
   F
  </h3>
  <p>
   The function value at each location in the form of an
   <i>
    n
   </i>
   -element vector.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   GRIDDATA will use the minimum number of points specified in any of the X, Y, Z, or F array arguments as the number of input points and function values.
  </p>
  <h3 class="Argument">
   Lon, Lat
  </h3>
  <p>
   These arguments contain the locations (on a sphere) of the data points (similar to
   <i>
    X
   </i>
   , and
   <i>
    Y
   </i>
   ) but are in degrees or radians (default) depending on the use of the keyword DEGREES.
  </p>
  <h2 class="API">
   <a name="G_845992557_877567">
   </a>
   <a name="G_845992557_877567_PageTOC_GRIDDATA_">
   </a>
   Keywords
  </h2>
  <h3 class="Keyword">
   <a name="G_845992557_877568">
   </a>
   <a name="G_845992557_877568_Keywords_GRIDDATA__">
   </a>
   ANISOTROPY
  </h3>
  <p>
   This keyword is a vector describing an ellipse (see the description for the SEARCH_ELLIPSE keyword). All points on the circumference of the ellipse have an equal influence on a point at the center of the ellipse.
  </p>
  <p>
   For example, assume that atmospheric data are being interpolated, with one dimension being altitude, and the other dimension representing distance from a point. If the vertical mixing is half that of the horizontal mixing, a point 100 units from an interpolate and at the same level has the same influence as a point 50 units above or below the interpolate at the same horizontal location. This effect requires setting the ANISOTROPY keyword to
   <span class="Courier">
    [2, 1, 0]
   </span>
   which forms an ellipse with an
   <i>
    X
   </i>
   -axis length twice as long as its
   <i>
    Y
   </i>
   -axis length.
  </p>
  <h3 class="Keyword">
   <a name="G_845992557_877573">
   </a>
   <a name="G_845992557_877573_Keywords_GRIDDATA__">
   </a>
   DEGREES
  </h3>
  <p>
   By default, all angular inputs and keywords are assumed to be in radian units. Set the DEGREES keyword to change the angular input units to degrees.
  </p>
  <h3 class="Keyword">
   <a name="G_845992557_877575">
   </a>
   <a name="G_845992557_877575_Keywords_GRIDDATA__">
   </a>
   DELTA
  </h3>
  <p>
   A two-element array specifying the grid spacing in
   <i>
    X
   </i>
   and
   <i>
    Y
   </i>
   .
  </p>
  <p>
   If this keyword is not specified, or if one of the elements is set equal to zero, the grid spacing is determined from the values of the DIMENSION and START keywords, according to the following rules:
  </p>
  <p class="Bullet">
   DELTA
   <sub>
    0
   </sub>
   = (max(
   <i>
    x
   </i>
   ) - START
   <sub>
    0
   </sub>
   )/(DIMENSION
   <sub>
    0
   </sub>
   - 1)
  </p>
  <p class="Bullet">
   DELTA
   <sub>
    1
   </sub>
   = (max(
   <i>
    y
   </i>
   ) - START
   <sub>
    1
   </sub>
   )/(DIMENSION
   <sub>
    1
   </sub>
   - 1)
  </p>
  <p>
   DELTA can also be set to a scalar value to be used for the grid size in both
   <i>
    X
   </i>
   and
   <i>
    Y
   </i>
   .
  </p>
  <p>
   This keyword is ignored if the GRID, XOUT and YOUT keywords are specified.
  </p>
  <h3 class="Keyword">
   <a name="G_845992557_877578">
   </a>
   <a name="G_845992557_877578_Keywords_GRIDDATA__">
   </a>
   DIMENSION
  </h3>
  <p>
   A two element array specifying the grid dimensions in
   <i>
    X
   </i>
   and
   <i>
    Y
   </i>
   . Default value is 25 for each dimension. This keyword can also be set to a scalar value to be used for the grid spacing in both
   <i>
    X
   </i>
   and
   <i>
    Y
   </i>
   .
  </p>
  <p>
   This keyword is ignored if the GRID, XOUT and YOUT keywords are specified.
  </p>
  <h3 class="Keyword">
   <a name="G_845992557_877581">
   </a>
   <a name="G_845992557_877581_Keywords_GRIDDATA__">
   </a>
   EMPTY_SECTORS
  </h3>
  <p>
   This keyword defines the search rules for the maximum number of sectors that may be empty when interpolating at each point. If this number or more sectors contain no data points, considering the search ellipse and/or the fault polygons, the resulting interpolant is the missing data value.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   The TRIANGLES keyword is required when the EMPTY_SECTORS,&#160; MAX_PER_SECTOR,&#160; MIN_POINTS, or SEARCH_ELLIPSE keywords are used.
  </p>
  <h3 class="Keyword">
   <a name="G_845992557_877584">
   </a>
   <a name="G_845992557_877584_Keywords_GRIDDATA__">
   </a>
   FAULT_POLYGONS
  </h3>
  <p>
   Set this keyword to an array containing one or more polygon descriptions. A polygon description is an integer or longword array of the form: [
   <i>
    n
   </i>
   ,
   <i>
    i
   </i>
   <sub>
    0
   </sub>
   ,
   <i>
    i
   </i>
   <sub>
    1
   </sub>
   , ...,
   <i>
    i
   </i>
   <sub class="italic">
    n
   </sub>
   <sub>
    –1
   </sub>
   ], where
   <i>
    n
   </i>
   is the number of vertices that define the polygon, and
   <i>
    i
   </i>
   <sub>
    0
   </sub>
   ...
   <i>
    i
   </i>
   <sub class="italic">
    n
   </sub>
   <sub>
    –1
   </sub>
   are indices into the FAULT_XY vertices. The FAULT_POLYGON array may contain multiple polygon descriptions that have been concatenated. To have this keyword ignore an entry in the FAULT_POLYGONS array, set the vertex count,
   <i>
    n
   </i>
   , and all associated indices to 0. To end the drawing list, even if additional array space is available, set
   <i>
    n
   </i>
   to –1. If this keyword is not specified, a single connected polygon is generated from FAULT_XY.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   FAULT_POLYGONS are not supported with spherical gridding.
  </p>
  <h3 class="Keyword">
   <a name="G_845992557_877588">
   </a>
   <a name="G_845992557_877588_Keywords_GRIDDATA__">
   </a>
   FAULT_XY
  </h3>
  <p>
   The a 2-by-
   <i>
    n
   </i>
   array specifying the coordinates of points on the fault lines/polygons.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   FAULT_XY is not supported with spherical gridding.
  </p>
  <h3 class="Keyword">
   <a name="G_845992557_877591">
   </a>
   <a name="G_845992557_877591_Keywords_GRIDDATA__">
   </a>
   FUNCTION_TYPE
  </h3>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   This keyword is only used with the Radial Basis Function method of interpolation.
  </p>
  <p>
   Set this keyword to one of the values shown in the following table to indicate which basis function to use. Default is 0, the Inverse Multiquadric function.
   <madcap:conditionaltext madcap:conditions="Reference Material.Online_Help_Only">
   </madcap:conditionaltext>
  </p>
  <p>
   &#160;
  </p>
  <table style="width: 498px;caption-side: top;mc-table-style: url('../../Resources/TableStyles/Keyword_Table.css');" class="TableStyle-Keyword_Table" cellspacing="0">
   <col width="81px" class="Column-Column1" />
   <col width="164px" class="Column-Column1" />
   <col width="253px" class="Column-Column1" />
   <thead>
    <tr class="Head-Header1">
     <td class="HeadE-Column1-Header1">
      <p>
       Value
      </p>
     </td>
     <td class="HeadE-Column1-Header1">
      <p>
       Function Type Used
      </p>
     </td>
     <td class="HeadD-Column1-Header1">
      <p>
       Equation
      </p>
     </td>
    </tr>
   </thead>
   <tbody>
    <tr class="Body-Body1">
     <td class="BodyE-Column1-Body1">
      <p>
       0
      </p>
     </td>
     <td class="BodyE-Column1-Body1">
      <p>
       Inverse Multiquadric
      </p>
     </td>
     <td class="BodyD-Column1-Body1">
      <p>
       <img src="../../images/13_1.jpg" />
      </p>
     </td>
    </tr>
    <tr class="Body-Body2">
     <td class="BodyE-Column1-Body2">
      <p>
       1
      </p>
     </td>
     <td class="BodyE-Column1-Body2">
      <p>
       Multilog
      </p>
     </td>
     <td class="BodyD-Column1-Body2">
      <p>
       <img src="../../images/13_2.jpg" />
      </p>
     </td>
    </tr>
    <tr class="Body-Body1">
     <td class="BodyE-Column1-Body1">
      <p>
       2
      </p>
     </td>
     <td class="BodyE-Column1-Body1">
      <p>
       Multiquadric
      </p>
     </td>
     <td class="BodyD-Column1-Body1">
      <p>
       <img src="../../images/13_3.jpg" />
      </p>
     </td>
    </tr>
    <tr class="Body-Body2">
     <td class="BodyE-Column1-Body2">
      <p>
       3
      </p>
     </td>
     <td class="BodyE-Column1-Body2">
      <p>
       Natural Cubic Spline
      </p>
     </td>
     <td class="BodyD-Column1-Body2">
      <p>
       <img src="../../images/13_4.jpg" />
      </p>
     </td>
    </tr>
    <tr class="Body-Body1">
     <td class="BodyE-Column1-Body1">
      <p>
       4
      </p>
     </td>
     <td class="BodyE-Column1-Body1">
      <p>
       Thin Plate Spline
      </p>
     </td>
     <td class="BodyD-Column1-Body1">
      <p>
       <img src="../../images/13_5.jpg" />
      </p>
     </td>
    </tr>
    <tr class="Body-Body2">
     <td colspan="3" class="BodyB-Column1-Body2">
      <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
       <span class="autonumber">
        <span>
         <b>
          Note:
         </b>
        </span>
       </span>
       In the equations, h = the anisotropically scaled distance from the interpolant to the node, and R
       <sup>
        2
       </sup>
       = the value of the SMOOTHING keyword.
      </p>
     </td>
    </tr>
   </tbody>
  </table>
  <h3 class="Keyword">
   <a name="G_845992557_877652">
   </a>
   <a name="G_845992557_877652_Keywords_GRIDDATA__">
   </a>
   GRID
  </h3>
  <p>
   The GRID keyword controls how the XOUT and YOUT vectors specify where interpolates are desired.
  </p>
  <p>
   If GRID is set, XOUT and YOUT must also be specified. Interpolation is performed on a regular or irregular grid specified by the vectors XOUT with
   <i>
    m
   </i>
   elements and YOUT with
   <i>
    n
   </i>
   elements. The
   <i>
    Result
   </i>
   is an
   <i>
    m
   </i>
   -by-
   <i>
    n
   </i>
   grid with point [
   <i>
    i
   </i>
   ,
   <i>
    j
   </i>
   ] resulting from the interpolation at (XOUT[
   <i>
    i
   </i>
   ],&#160;YOUT[
   <i>
    j
   </i>
   ]). When XOUT and YOUT are used, the DELTA, DIMENSION and START keywords are ignored.
  </p>
  <h3 class="Keyword">
   <a name="G_845992557_877655">
   </a>
   <a name="G_845992557_877655_Keywords_GRIDDATA__">
   </a>
   INVERSE_DISTANCE
  </h3>
  <p>
   Selects the Inverse Distance method of interpolation.
  </p>
  <h3 class="Keyword">
   <a name="G_845992557_877657">
   </a>
   <a name="G_845992557_877657_Keywords_GRIDDATA__">
   </a>
   KRIGING
  </h3>
  <p>
   Selects the Kriging method of interpolation. The variogram type for the Kriging method is set by default, however the VARIOGRAM keyword can be used to set variogram parameters.
  </p>
  <h3 class="Keyword">
   <a name="G_845992557_877659">
   </a>
   <a name="G_845992557_877659_Keywords_GRIDDATA__">
   </a>
   LINEAR
  </h3>
  <p>
   Selects the Linear method of interpolation. The TRIANGLES keyword is required when the LINEAR keyword is used.
  </p>
  <h3 class="Keyword">
   <a name="G_845992557_877661">
   </a>
   <a name="G_845992557_877661_Keywords_GRIDDATA__">
   </a>
   MAX_PER_SECTOR
  </h3>
  <p>
   This keyword defines the search rules for the maximum number of data points to include in each sector when interpolating. Search rules effectively limit the number of data points used in computing each interpolate. For example, to use the nearest
   <i>
    n
   </i>
   nodes to compute each interpolant, specify MAX_PER_SECTOR =
   <i>
    n
   </i>
   and use the TRIANGLES keyword.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   The TRIANGLES keyword is required when the EMPTY_SECTORS,&#160; MAX_PER_SECTOR,&#160; MIN_POINTS, or SEARCH_ELLIPSE keywords are used.
  </p>
  <h3 class="Keyword">
   <a name="G_845992557_877664">
   </a>
   <a name="G_845992557_877664_Keywords_GRIDDATA__">
   </a>
   METHOD
  </h3>
  <p>
   A string containing one of the method names as shown in the following table. The default for METHOD is “InverseDistance”.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   The interpolation method can be chosen using the METHOD keyword set to the specific string, or by setting the corresponding method name keyword.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   There are no spaces between words in the method strings and the strings are case insensitive.
  </p>
  <table style="caption-side: bottom;mc-table-style: url('../../Resources/TableStyles/Description.css');margin-left: 0;margin-right: auto;" cellspacing="0" class="TableStyle_Description">
   <caption>
    METHOD Keyword Values
   </caption>
   <col />
   <col />
   <thead>
    <tr>
     <td class="TableStyle_Description_Head_0_0_RowSep_ColSep">
      <p>
       Method String
      </p>
     </td>
     <td class="TableStyle_Description_Head_0_0_RowSep_ColEnd">
      <p>
       Meaning
      </p>
     </td>
    </tr>
   </thead>
   <tbody>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      <p>
       "InverseDistance"
      </p>
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      <p>
       Data points closer to the grid points have more effect than those which are further away.
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
      <p>
       "Kriging"
      </p>
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
      <p>
       Data points and their spatial variance are used to determine trends which are applied to the grid points.
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      <p>
       "Linear"
      </p>
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      <p>
       Grid points are linearly interpolated from triangles formed by Delaunay triangulation.
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
      <p>
       "MinimumCurvature"
      </p>
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
      <p>
       A plane of grid points is conformed to the data points while trying to minimize the amount of bending in the plane.
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      <p>
       "ModifiedShepards"
      </p>
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      <p>
       Inverse Distance weighted with the least squares method.
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
      <p>
       "NaturalNeighbor"
      </p>
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
      <p>
       Each interpolant is a linear combination of the three vertices of its enclosing Delaunay triangle and their adjacent vertices.
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      <p>
       "NearestNeighbor"
      </p>
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      <p>
       The grid points have the same value as the nearest data point.
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
      <p>
       "PolynomialRegression"
      </p>
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
      <p>
       Each interpolant is a least-squares fit of a polynomial in X and Y of the specified power to the specified data points.
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      <p>
       "Quintic"
      </p>
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      <p>
       Grid points are interpolated with quintic polynomials from triangles formed by Delaunay triangulation.
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowEnd_ColSep">
      <p>
       "RadialBasisFunction"
      </p>
     </td>
     <td class="TableStyle_Description_Body_1_0_RowEnd_ColEnd">
      <p>
       The effects of data points are weighted by a function of their radial distance from a grid point.
      </p>
     </td>
    </tr>
   </tbody>
  </table>
  <h3 class="Keyword">
   <a name="G_845992557_877713">
   </a>
   <a name="G_845992557_877713_Keywords_GRIDDATA__">
   </a>
   MIN_CURVATURE
  </h3>
  <p>
   Selects the Minimum Curvature method of interpolation.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   If the Cholesky factorization used within the Minimum Curvature method fails, then a scalar 0 will be returned instead of the two-dimensional array.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   The minimum curvature algorithm requires a work array that is
   <i>
    M
   </i>
   <i style="font-size: 80%;vertical-align: super;">
    2
   </i>
   in size, where
   <i>
    M
   </i>
   is the total number of input data points. On 32-bit platforms, you are therefore limited to input data arrays that have less than approximately 46340 data points, with the exact number depending upon your available memory. Using an input array with too many elements will result in an error.
  </p>
  <h3 class="Keyword">
   <a name="G_845992557_877715">
   </a>
   <a name="G_845992557_877715_Keywords_GRIDDATA__">
   </a>
   MIN_POINTS
  </h3>
  <p>
   If fewer than this number of data points are encountered in all sectors, the value of the resulting grid point is set to the value of the MISSING keyword.
  </p>
  <p>
   The MIN_POINTS keyword also indicates the number of closest points used for each local fit, if SEARCH_ELLIPSE isn’t specified.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   The TRIANGLES keyword is required when the EMPTY_SECTORS,&#160; MAX_PER_SECTOR,&#160; MIN_POINTS, or SEARCH_ELLIPSE keywords are used.
  </p>
  <h3 class="Keyword">
   <a name="G_845992557_877719">
   </a>
   <a name="G_845992557_877719_Keywords_GRIDDATA__">
   </a>
   MISSING
  </h3>
  <p>
   Set this keyword to the value that will be used for an element of the
   <i>
    Result
   </i>
   array if there is no calculated value for that element. The default is 0.
  </p>
  <h3 class="Keyword">
   <a name="G_845992557_877723">
   </a>
   <a name="G_845992557_877723_Keywords_GRIDDATA__">
   </a>
   NATURAL_NEIGHBOR
  </h3>
  <p>
   Selects the Natural Neighbor method of interpolation.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   The TRIANGLES keyword is required when the NATURAL_NEIGHBOR keyword is used.
  </p>
  <h3 class="Keyword">
   <a name="G_845992557_877726">
   </a>
   <a name="G_845992557_877726_Keywords_GRIDDATA__">
   </a>
   NEAREST_NEIGHBOR
  </h3>
  <p>
   Selects the Nearest Neighbor method of interpolation.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   The TRIANGLES keyword is required when the NEAREST_NEIGHBOR keyword is used.
  </p>
  <h3 class="Keyword">
   <a name="G_845992557_877729">
   </a>
   <a name="G_845992557_877729_Keywords_GRIDDATA__">
   </a>
   NEIGHBORHOOD
  </h3>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   The NEIGHBORHOOD keyword is only used for the Modified Shepard’s method of interpolation.
  </p>
  <p>
   A two-element array, [
   <i>
    Nq
   </i>
   ,
   <i>
    Nw
   </i>
   ] defining the quadratic fit,
   <i>
    Nq
   </i>
   , and weighting,
   <i>
    Nw
   </i>
   , neighborhood sizes for the Modified Shepard’s method. The default for
   <i>
    Nq
   </i>
   is the smaller of 13 and the number of points minus 1, with a minimum of 5. The default for
   <i>
    Nw
   </i>
   is the smaller of 19 and the number of points. The Modified Shepard’s method first computes the coefficients of a quadratic fit for each input point, using its
   <i>
    Nq
   </i>
   closest neighbors.
  </p>
  <p>
   When interpolating an output point, the quadratic fits from the
   <i>
    Nw
   </i>
   closest input points are weighted inversely by a function of distance and then combined. The size of the neighborhood used for Shepard’s method interpolation may also be specified by the search rules keywords.
  </p>
  <h3 class="Keyword">
   <a name="G_845992557_877733">
   </a>
   <a name="G_845992557_877733_Keywords_GRIDDATA__">
   </a>
   POLYNOMIAL_REGRESSION
  </h3>
  <p>
   Selects the Polynomial Regression method for interpolation. The power of the polynomial regression is set to 2 by default, however the POWER keyword can be used to change the power to 1 or 3.
  </p>
  <p>
   The function fit to each interpolant corresponding to the POWER keyword set equal to 1, 2 (the default), and 3 respectively is as follows:
  </p>
  <p>
   <img src="../../images/13_6.jpg" />
   &#160;
  </p>
  <p>
   <img src="../../images/13_7.jpg" />
  </p>
  <p>
   <img src="../../images/13_8.jpg" />
  </p>
  <p>
   By inspection, a minimum of three data points are required to fit the linear polynomial, six data points for the second polynomial equation (where POWER = 2), and ten data points for the third polynomial (POWER = 3). If not enough data points exist for a given interpolant, the missing data values are set to the value of the MISSING keyword.
  </p>
  <h3 class="Keyword">
   <a name="G_845992557_877749">
   </a>
   <a name="G_845992557_877749_Keywords_GRIDDATA__">
   </a>
   POWER
  </h3>
  <p>
   The weighting power of the distance, or the maximum order in the polynomial fitting function. For polynomial regression, this value is either 1, 2 (the default), or 3.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   The POWER keyword is only used for the Inverse Distance and Polynomial Regression methods of interpolation.
  </p>
  <h3 class="Keyword">
   <a name="G_845992557_877752">
   </a>
   <a name="G_845992557_877752_Keywords_GRIDDATA__">
   </a>
   QUINTIC
  </h3>
  <p>
   Selects the triangulation with Quintic interpolation method.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   The TRIANGLES keyword is required when the QUINTIC keyword is used.
  </p>
  <h3 class="Keyword">
   <a name="G_845992557_877755">
   </a>
   <a name="G_845992557_877755_Keywords_GRIDDATA__">
   </a>
   RADIAL_BASIS_FUNCTION
  </h3>
  <p>
   Selects the Radial Basis Function method of interpolation.
  </p>
  <h3 class="Keyword">
   <a name="G_845992557_877757">
   </a>
   <a name="G_845992557_877757_Keywords_GRIDDATA__">
   </a>
   SEARCH_ELLIPSE
  </h3>
  <p>
   This keyword defines the search rules as a scalar or vector of from 1 to 3 elements that specify an ellipse or circle in the form [
   <i>
    R1
   </i>
   ], [
   <i>
    R1
   </i>
   ,
   <i>
    R2
   </i>
   ], or [
   <i>
    R1
   </i>
   ,
   <i>
    R2
   </i>
   ,
   <i>
    Theta
   </i>
   ].
   <i>
    R1
   </i>
   is one radius,
   <i>
    R2
   </i>
   the other radius, and
   <i>
    Theta
   </i>
   describes the angle between the
   <i>
    X
   </i>
   -axis to the
   <i>
    R1
   </i>
   -axis, counterclockwise, in degrees or radians as specified by the DEGREES keyword. Only data points within this ellipse, centered on the location of the interpolate, are considered. If not specified, or 0, this distance test is not applied. Search rules effectively limit the number of data points used in computing each interpolate.
  </p>
  <p>
   For example, to only consider data points within a distance of 5 units of each interpolant, specify the keyword as SEARCH_ELLIPSE = 5.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   The TRIANGLES keyword is required when the EMPTY_SECTORS,&#160; MAX_PER_SECTOR,&#160; MIN_POINTS, or SEARCH_ELLIPSE keywords are used.
  </p>
  <h3 class="Keyword">
   <a name="G_845992557_877761">
   </a>
   <a name="G_845992557_877761_Keywords_GRIDDATA__">
   </a>
   SECTORS
  </h3>
  <p>
   This keyword defines the search rules for the number of sectors used in applying the MAX_SECTOR, EMPTY_SECTORS, and MIN_POINTS tests, an integer from 1 (the default setting) to 8.
  </p>
  <h3 class="Keyword">
   <a name="G_845992557_877763">
   </a>
   <a name="G_845992557_877763_Keywords_GRIDDATA__">
   </a>
   SHEPARDS
  </h3>
  <p>
   Selects the Modified Shepard’s method of interpolation. The parameters for the Modified Shepard’s method are set by default, however the NEIGHBORHOOD keyword can be used to modify the parameters.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   The TRIANGLES keyword is required when the SHEPARDS keyword is used.
  </p>
  <h3 class="Keyword">
   <a name="G_845992557_877766">
   </a>
   <a name="G_845992557_877766_Keywords_GRIDDATA__">
   </a>
   SMOOTHING
  </h3>
  <p>
   A scalar value defining the smoothing radius. For the Radial Basis Function method, if SMOOTHING is not specified, the default value is equal to the average point spacing, assuming a uniform distribution. For the Inverse Distance method, the default value is 0, implying no smoothing.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   The SMOOTHING keyword is used only for the Inverse Distance and Radial Basis Function methods of interpolation.
  </p>
  <h3 class="Keyword">
   <a name="G_845992557_877769">
   </a>
   <a name="G_845992557_877769_Keywords_GRIDDATA__">
   </a>
   SPHERE
  </h3>
  <p>
   If set, data points lie on the surface of a sphere.
  </p>
  <p>
   When the SPHERE keyword is used with Cartesian input coordinates (x,y,z), the coordinates must lie on a unit sphere (i.e., center at 0,0,0 and radius = 1). If any points do not lie on the sphere (within some tolerance), they are forced to be on the sphere, and GRIDDATA issues a warning and continues execution.
  </p>
  <p>
   Furthermore, if a point lies at the origin, GRIDDATA throws an error that Cartesian coordinates cannot be zero, and halts execution.
  </p>
  <h3 class="Keyword">
   <a name="G_845992557_877771">
   </a>
   <a name="G_845992557_877771_Keywords_GRIDDATA__">
   </a>
   START
  </h3>
  <p>
   A scalar or a two-element array specifying the start of the grid in
   <i>
    X
   </i>
   and
   <i>
    Y
   </i>
   . Default value is [min(
   <i>
    x
   </i>
   ), min(
   <i>
    y
   </i>
   )].
  </p>
  <p>
   This keyword is ignored if the GRID, XOUT and YOUT keywords are specified.
  </p>
  <h3 class="Keyword">
   <a name="G_845992557_877774">
   </a>
   <a name="G_845992557_877774_Keywords_GRIDDATA__">
   </a>
   TRIANGLES
  </h3>
  <p>
   A 3-by-
   <i>
    nt
   </i>
   longword array describing the connectivity of the input points, as returned by TRIANGULATE, where
   <i>
    nt
   </i>
   is the number of triangles. If duplicate point locations are input and the TRIANGLES keyword is present, only one of the points is considered.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   The TRIANGLES keyword is required for the Natural Neighbor, Nearest Neighbor, Modified Shepard’s, Linear, and Quintic Interpolation methods.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   The TRIANGLES keyword is required when the EMPTY_SECTORS,&#160; MAX_PER_SECTOR,&#160; MIN_POINTS, or SEARCH_ELLIPSE keywords are used.
  </p>
  <h3 class="Keyword">
   <a name="G_845992557_877778">
   </a>
   <a name="G_845992557_877778_Keywords_GRIDDATA__">
   </a>
   VARIOGRAM
  </h3>
  <p>
   Specifies the variogram type and parameters for the Kriging method. This parameter is a vector of one to four elements in the form of: [
   <i>
    Type
   </i>
   ,
   <i>
    Range
   </i>
   ,
   <i>
    Nugget
   </i>
   ,
   <i>
    Scale
   </i>
   ]. The
   <i>
    Type
   </i>
   is encoded as: 1 for linear, 2 for exponential, 3 for gaussian, 4 for spherical. Defaults values are:
   <i>
    Type
   </i>
   is exponential,
   <i>
    Range
   </i>
   is 8 times the average point spacing assuming a uniform distribution,
   <i>
    Nugget
   </i>
   is zero, and
   <i>
    Scale
   </i>
   is 1.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   The VARIOGRAM keyword is only used with the Kriging method of interpolation.
  </p>
  <p>
   The following functions are used to model the variogram functions:
  </p>
  <p>
   Linear Covariance:
  </p>
  <p style="text-align: left;">
   <img src="../../images/13_12.jpg" />
  </p>
  <p>
   Exponential Covariance:
  </p>
  <p style="text-align: left;">
   <img src="../../images/13_9.jpg" />
  </p>
  <p>
   Gaussian Covariance:
  </p>
  <p style="text-align: left;">
   <img src="../../images/13_10.jpg" />
  </p>
  <p>
   Spherical Covariance:
  </p>
  <p style="text-align: left;">
   <img src="../../images/13_11.jpg" />
  </p>
  <p>
   where
   <i>
    d
   </i>
   is the distance from one point to another,
   <i>
    R
   </i>
   is the range value,
   <i>
    N
   </i>
   is the nugget value, and
   <i>
    S
   </i>
   is the scale value.
  </p>
  <h3 class="Keyword">
   <a name="G_845992557_877781">
   </a>
   <a name="G_845992557_877781_Keywords_GRIDDATA__">
   </a>
   XOUT
  </h3>
  <p>
   If the GRID keyword is set, use XOUT to specify irregularly spaced rectangular output grids. If XOUT is specified, YOUT must also be specified. When XOUT and YOUT are used, the DELTA, DIMENSION and START keywords are ignored.
  </p>
  <p>
   If GRID is not set (the default), the location vectors XOUT and YOUT directly contain the X and Y values of the interpolates, and must have the same number of elements. The
   <i>
    Result
   </i>
   has the same structure and number of elements as XOUT and YOUT, with point [
   <i>
    i
   </i>
   ] resulting from the interpolation at (XOUT[
   <i>
    i
   </i>
   ],&#160;YOUT[
   <i>
    i
   </i>
   ]).
  </p>
  <h3 class="Keyword">
   <a name="G_845992557_877784">
   </a>
   <a name="G_845992557_877784_Keywords_GRIDDATA__">
   </a>
   YOUT
  </h3>
  <p>
   If the GRID keyword is set, use YOUT to specify irregularly spaced rectangular output grids. If YOUT is specified, XOUT must also be specified. When XOUT and YOUT are used, the DELTA, DIMENSION and START keywords are ignored.
  </p>
  <p>
   If GRID is not set (the default), the location vectors XOUT and YOUT directly contain the X and Y values of the interpolates, and must have the same number of elements. The
   <i>
    Result
   </i>
   has the same structure and number of elements as XOUT and YOUT, with point [
   <i>
    i
   </i>
   ] resulting from the interpolation at (XOUT[
   <i>
    i
   </i>
   ],&#160;YOUT[
   <i>
    i
   </i>
   ]).
  </p>
  <h2 class="API">
   <a name="G_845992557_877787">
   </a>
   <a name="G_845992557_877787_PageTOC_GRIDDATA_">
   </a>
   Examples
  </h2>
  <p>
   Examples one through four below all use the same set of variables. Execute the code below before executing the examples:
  </p>
  <h4>
   <a name="G_845992557_925060">
   </a>
   <a name="G_845992557_81593">
   </a>
   Griddata Example Variables
  </h4>
  <p class="Code">
   ; Create a dataset of N points.
   <br />
   n = 100                         ;# of scattered points
   <br />
   seed = -121147L                 ;For consistency
   <br />
   x = RANDOMU(seed, n)
   <br />
   y = RANDOMU(seed, n)
   <br />
   <br />
   ; Create a dependent variable in the form a function of (x,y)
   <br />
   ; with peaks &amp; valleys.
   <br />
   f = 3 * EXP(-((9*x-2)^2 + (7-9*y)^2)/4) + $
   <br />
   &#160;&#160;&#160;3 * EXP(-((9*x+1)^2)/49 - (1-0.9*y)) + $
   <br />
   &#160;&#160;&#160;2 * EXP(-((9*x-7)^2 + (6-9*y)^2)/4) - $
   <br />
   &#160;&#160;&#160;EXP(-(9*x-4)^2 - (2-9*y)^2)
   <br />
  </p>
  <h3>
   <a name="G_845992557_885036_Keywords_GRIDDATA__">
   </a>
   Example 1
  </h3>
  <p>
   This example interpolates a data set measured on an irregular grid. Various types of the Inverse Distance interpolation method (the default method) are used in this example. (
   <span class="Bold">
    Note
   </span>
   : be sure you have created the
   <a class="MCXref_Heading_0" href="#G_845992557_925060">
    Griddata Example Variables
   </a>
   .)
  </p>
  <p class="Code">
   ; Initialize display.
   <br />
   WINDOW, 0, XSIZE = 512, YSIZE = 768, TITLE = 'Inverse Distance'
   <br />
   !P.MULTI = [0, 1, 3, 0, 0]
   <br />
   <br />
   ; Inverse distance: Simplest default case which produces a 25 x
   <br />
   ; 25 grid.
   <br />
   grid = GRIDDATA(x, y, f)
   <br />
   SURFACE, grid, CHARSIZE = 3, TITLE = 'Simple Example'
   <br />
   <br />
   ; Default case, Inverse distance.
   <br />
   grid = GRIDDATA(x, y, f, START = 0, DELTA = 0.02, DIMENSION = 51)
   <br />
   SURFACE, grid, CHARSIZE = 3, TITLE = 'Larger Grid'
   <br />
   <br />
   ; Inverse distance + smoothing.
   <br />
   grid = GRIDDATA(x, y, f, START = 0, DELTA = 0.02, DIMENSION = 51, $
   <br />
   &#160;&#160;&#160;SMOOTH = 0.05)
   <br />
   SURFACE, grid, CHARSIZE = 3, TITLE = 'Smoothing'
   <br />
   <br />
   ; Set system variable back to default value.
   <br />
   !P.MULTI = 0
   <br />
  </p>
  <h3>
   <a name="G_845992557_877822_Keywords_GRIDDATA__">
   </a>
   <a name="G_845992557_877822_PageTOC_GRIDDATA_">
   </a>
   Example 2
  </h3>
  <p>
   This example uses the same data as the previous one, however in this example we use the Radial Basis Function and the Modified Shepard’s interpolation methods.
  </p>
  <p class="Code">
   ; Initialize display.
   <br />
   WINDOW, 0, XSIZE = 512, YSIZE = 640, $
   <br />
   TITLE = 'Different Methods of Gridding'
   <br />
   !P.MULTI = [0, 1, 2, 0, 0]
   <br />
   <br />
   ; Use radial basis function with multilog basis function.
   <br />
   grid = GRIDDATA(x, y, f, START = 0, DELTA = 0.02, DIMENSION = 51, $
   <br />
   &#160;&#160;&#160;/RADIAL_BASIS_FUNCTION, FUNCTION_TYPE = 1)
   <br />
   SURFACE, grid, CHARSIZE = 3, TITLE = 'Radial Basis Function'
   <br />
   <br />
   ; The following example requires triangulation.
   <br />
   TRIANGULATE, x, y, tr
   <br />
   <br />
   ; Use Modified Shepard's method.
   <br />
   grid = GRIDDATA(x, y, f, START = 0, DELTA = 0.02, DIMENSION = 51, $
   <br />
   &#160;&#160;&#160;TRIANGLES = tr, /SHEPARDS)
   <br />
   SURFACE, grid, CHARSIZE = 3, TITLE = "Modified Shepard's Method"
   <br />
   <br />
   ; Set system variable back to default value.
   <br />
   !P.MULTI = 0
   <br />
  </p>
  <h3>
   <a name="G_845992557_877857_Keywords_GRIDDATA__">
   </a>
   <a name="G_845992557_877857_PageTOC_GRIDDATA_">
   </a>
   Example 3
  </h3>
  <p>
   This example uses the same data as the previous ones, however in this example we use various types of the Polynomial Regression interpolation method.
  </p>
  <p class="Code">
   ; Initialize display.
   <br />
   WINDOW, 0, XSIZE = 512, YSIZE = 768, $
   <br />
   &#160;&#160;&#160;TITLE = 'Polynomial Regression'
   <br />
   !P.MULTI = [0, 1, 3, 0, 0]
   <br />
   <br />
   ; The following examples require the triangulation.
   <br />
   TRIANGULATE, x, y, tr
   <br />
   <br />
   ; Fit with a 2nd degree polynomial in x and y.  This fit considers
   <br />
   ; all points when fitting the surface, obliterating the individual
   <br />
   ; peaks.
   <br />
   grid = GRIDDATA(x, y, f, START = 0, DELTA = 0.02, DIMENSION = 51, $
   <br />
   TRIANGLES = tr, /POLYNOMIAL_REGRESSION)
   <br />
   SURFACE, grid, CHARSIZE = 3, TITLE = 'Global Degree 2 Polynomial'
   <br />
   <br />
   ; Fit with a 2nd degree polynomial in x and y, but this time use
   <br />
   ; only the 10 closest nodes to each interpolant.  This provides a
   <br />
   ; relatively smooth surface, but still shows the individual peaks.
   <br />
   grid = GRIDDATA(x, y, f, START = 0, DELTA = 0.02, DIMENSION = 51, $
   <br />
   TRIANGLES = tr, /POLYNOMIAL_REGRESSION, MAX_PER_SECTOR = 10)
   <br />
   SURFACE, grid, CHARSIZE = 3, TITLE = 'Local Polynomial, 10 Point'
   <br />
   <br />
   ; As above, but use only the nodes within a distance of 0.4 when
   <br />
   ; fitting each interpolant.
   <br />
   grid = GRIDDATA(x, y, f, START = 0, DELTA = 0.02, DIMENSION = 51, $
   <br />
   TRIANGLES = tr, /POLYNOMIAL_REGRESSION, SEARCH_ELLIPSE = 0.4)
   <br />
   SURFACE, grid, CHARSIZE = 3, $
   <br />
   TITLE = 'Local Polynomial, Radius = 0.4'
   <br />
   <br />
   !P.MULTI = 0&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;; Set system variable back to default value.
   <br />
  </p>
  <h3>
   <a name="G_845992557_877903_Keywords_GRIDDATA__">
   </a>
   <a name="G_845992557_877903_PageTOC_GRIDDATA_">
   </a>
   Example 4
  </h3>
  <p>
   This example uses the same data as the previous ones; however, in this example we show how to speed up the interpolation by limiting the interpolation to the local area around each interpolate.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   The inverse distance, kriging, polynomial regression, and radial basis function methods are, by default, global methods in which each input node affects each output node. With these methods, large datasets can require a prohibitively long time to compute unless the scope of the interpolation is limited to a local area around each interpolate by specifying search rules. In fact, the radial basis function requires time proportional to the cube of the number of input points.
   <br />
   <br />
   For example, with 2,000 input points, a typical workstation required 500 seconds to interpolate a 10,000 point grid using radial basis functions.  By limiting the size of the fit to the 20 closest points to each interpolate, via the MIN_POINTS keyword, the time required dropped to less than a second.
  </p>
  <p class="Code">
   ; Initialize display.
   <br />
   WINDOW, 0, XSIZE = 512, YSIZE = 640, $
   <br />
   &#160;&#160;&#160;TITLE = 'Radial Basis Function'
   <br />
   !P.MULTI = [0, 1, 2, 0, 0]
   <br />
   <br />
   ; Slow way:
   <br />
   grid = GRIDDATA(x, y, f, START = 0, DELTA = 0.02, DIMENSION = 51, $
   <br />
   &#160;&#160;&#160;/RADIAL_BASIS_FUNCTION)
   <br />
   SURFACE, grid, CHARSIZE = 3, TITLE = 'All Points'
   <br />
   <br />
   ; The following example requires triangulation.
   <br />
   TRIANGULATE, x, y, tr
   <br />
   <br />
   ; Faster way:
   <br />
   grid = GRIDDATA(x, y, f, START = 0, DELTA = 0.02, DIMENSION = 51, $
   <br />
   &#160;&#160;&#160;/RADIAL_BASIS_FUNCTION, MIN_POINTS = 15, TRIANGLES = tr)
   <br />
   SURFACE, grid, CHARSIZE = 3, TITLE = 'Nearest 15 Points'
   <br />
   <br />
   ; Set system variable back to default value.
   <br />
   !P.MULTI = 0
   <br />
  </p>
  <h3>
   <a name="G_845992557_877953_Keywords_GRIDDATA__">
   </a>
   <a name="G_845992557_877953_PageTOC_GRIDDATA_">
   </a>
   Example 5
  </h3>
  <p>
   This example interpolates a spherical data set measured on an irregular grid. We use the Kriging and Natural Neighbors interpolation methods in this example.
  </p>
  <p>
   To begin, we will create a 100 scattered points on a sphere and form a function of their latitude and longitude. Then grid them to a 2 degree grid over the sphere, display a Mollweide projection map, and overlay the contours of the result on the map.
  </p>
  <p class="Code">
   ; Create a dataset of N points.
   <br />
   n = 100
   <br />
   ; A 2 degree grid with grid dimensions.
   <br />
   delta = 2
   <br />
   dims = [360, 180]/delta
   <br />
   ; Longitude and latitudes (for uniformly placed data)
   <br />
   lon = RANDOMU(seed, n) * 360 - 180
   <br />
   lat = ACOS(2*RANDOMU(seed, n) - 1.) * !RADEG - 90
   <br />
   ; The lon/lat grid locations
   <br />
   lon_grid = FINDGEN(dims[0]) * delta - 180
   <br />
   lat_grid = FINDGEN(dims[1]) * delta - 90
   <br />
   <br />
   ; Create a dependent variable in the form of a smoothly varying
   <br />
   ; function.
   <br />
   f = SIN(2*lon*!DTOR) + COS(lat*!DTOR) ;
   <br />
  </p>
  <p>
   Next, grid the data to a two-degree grid over the sphere, display a Mollweide projection map, and overlay the contours of the result on the map.
  </p>
  <p class="Code">
   ; Initialize display.
   <br />
   WINDOW, 0, XSIZE = 512, YSIZE = 768, TITLE = 'Spherical Gridding'
   <br />
   !P.MULTI = [0, 1, 3, 0, 0]
   <br />
   <br />
   ; Kriging: Simplest default case.
   <br />
   z = GRIDDATA(lon, lat, f, /KRIGING, /DEGREES, START = 0, /SPHERE, $
   <br />
   &#160;&#160;&#160;DELTA = delta, DIMENSION = dims)
   <br />
   MAP_SET, /MOLLWEIDE, /ISOTROPIC, /HORIZON, /GRID, CHARSIZE = 3, $
   <br />
   &#160;&#160;&#160;TITLE = 'Sphere: Kriging'
   <br />
   CONTOUR, z, lon_grid, lat_grid, /OVERPLOT, NLEVELS = 10, /FOLLOW
   <br />
  </p>
  <p>
   Next, we add a call to QHULL to triangulate the points on the sphere, and to then interpolate using the 10 closest points. The gridding portion of this example requires about one-fourth the time as above.
  </p>
  <p class="Code">
   QHULL, lon, lat, tr, /DELAUNAY, SPHERE = s
   <br />
   z = GRIDDATA(lon, lat, f, /DEGREES, START = 0, DELTA = delta, $
   <br />
   &#160;&#160;&#160;DIMENSION = dims, TRIANGLES = tr, MIN_POINTS = 10, /KRIGING, $
   <br />
   &#160;&#160;&#160;/SPHERE)
   <br />
   MAP_SET, /MOLLWEIDE, /ISOTROPIC, /HORIZON, /GRID, /ADVANCE, $
   <br />
   &#160;&#160;&#160;CHARSIZE = 3, TITLE = 'Sphere: Kriging, 10 Closest Points'
   <br />
   CONTOUR, z, lon_grid, lat_grid, /OVERPLOT, NLEVELS = 10, /FOLLOW
   <br />
   WSHOW, 0
   <br />
  </p>
  <p>
   Finally, we use the natural neighbor method, which is about four times faster than the above example but does not give as smooth a surface:
  </p>
  <p class="Code">
   z = GRIDDATA(lon, lat, f, /DEGREES, START = 0, DELTA = delta, $
   <br />
   &#160;&#160;&#160;DIMENSION = dims, /SPHERE, /NATURAL_NEIGHBOR, TRIANGLES = tr)
   <br />
   MAP_SET, /MOLLWEIDE, /ISOTROPIC, /HORIZON, /GRID, /ADVANCE, $
   <br />
   &#160;&#160;&#160;CHARSIZE = 3, TITLE = 'Sphere: Natural Neighbor'
   <br />
   CONTOUR, z, lon_grid, lat_grid, /OVERPLOT, NLEVELS = 10, /FOLLOW
   <br />
   WSHOW, 0
   <br />
   <br />
   ; Set system variable back to default value.
   <br />
   !P.MULTI = 0
   <br />
  </p>
  <h3>
   <a name="G_845992557_878011_Keywords_GRIDDATA__">
   </a>
   <a name="G_845992557_878011_PageTOC_GRIDDATA_">
   </a>
   Example 6
  </h3>
  <p>
   The following example uses the data from the
   <span class="Courier">
    irreg_grid1.txt
   </span>
   ASCII file. This file contains scattered elevation data of a model of an inlet. This scattered elevation data contains two duplicate locations.
  </p>
  <p>
   The GRID_INPUT procedure is used to omit the duplicate locations for the GRIDDATA function. The GRIDDATA function is then used to grid the data using the Radial Basis Function method. This method is specified by setting the METHOD keyword the
   <span class="Courier">
    RadialBasisFunction
   </span>
   string, although it could easily be done using the RADIAL_BASIS_FUNCTION keyword.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   Execute all of the following example sections in the order they are presented here.
  </p>
  <p>
   First, we import the data:
  </p>
  <p class="Code">
   file = FILEPATH('irreg_grid1.txt', $
   <br />
   &#160;&#160;&#160;SUBDIRECTORY = ['examples', 'data'])
   <br />
   <br />
   ; Import the data from the file into a structure.
   <br />
   dataStructure = READ_ASCII(file)
   <br />
   <br />
   ; Get the imported array from the first field of the structure.
   <br />
   dataArray = TRANSPOSE(dataStructure.field1)
   <br />
   <br />
   ; Initialize the variables of this example from
   <br />
   ; the imported array.
   <br />
   x = dataArray[*, 0]
   <br />
   y = dataArray[*, 1]
   <br />
   data = dataArray[*, 2]
   <br />
  </p>
  <p>
   Next, we display the data by scaling it to range from 1 to 253 so a color table can be applied. The values of 0, 254, and 255 are reserved as outliers. We tell IDL to use decomposed color mode (a maximum of 256 colors) and load a color table, then plot the data and show the data values in color.
  </p>
  <p class="Code">
   scaled = BYTSCL(data, TOP = !D.TABLE_SIZE - 4) + 1B
   <br />
   DEVICE, DECOMPOSED = 0
   <br />
   LOADCT, 38
   <br />
   <br />
   ; Open a display window and plot the data points.
   <br />
   WINDOW, 0
   <br />
   PLOT, x, y, /XSTYLE, /YSTYLE, LINESTYLE = 1, $
   <br />
   &#160;&#160;&#160;TITLE = 'Original Data, Scaled (1 to 253)', $
   <br />
   &#160;&#160;&#160;XTITLE = 'x', YTITLE = 'y'
   <br />
   <br />
   ; Now display the data values with respect to the color table.
   <br />
   FOR i = 0L, (N_ELEMENTS(x) - 1) DO PLOTS, x[i], y[i], PSYM = -1, $
   <br />
   &#160;&#160;&#160;SYMSIZE = 2., COLOR = scaled[i]
   <br />
  </p>
  <p>
   Next, we grid the data using the radial basis function method:
  </p>
  <p class="Code">
   ; Preprocess and sort the data. GRID_INPUT will
   <br />
   ; remove any duplicate locations.
   <br />
   GRID_INPUT, x, y, data, xSorted, ySorted, dataSorted
   <br />
   <br />
   ; Initialize the grid parameters.
   <br />
   gridSize = [51, 51]
   <br />
   <br />
   ; Use the equation of a straight line and the grid parameters to
   <br />
   ; determine the x of the resulting grid.
   <br />
   slope = (MAX(xSorted) - MIN(xSorted))/(gridSize[0] - 1)
   <br />
   intercept = MIN(xSorted)
   <br />
   xGrid = (slope*FINDGEN(gridSize[0])) + intercept
   <br />
   <br />
   ; Use the equation of a straight line and the grid parameters to
   <br />
   ; determine the y of the resulting grid.
   <br />
   slope = (MAX(ySorted) - MIN(ySorted))/(gridSize[1] - 1)
   <br />
   intercept = MIN(ySorted)
   <br />
   yGrid = (slope*FINDGEN(gridSize[1])) + intercept
   <br />
   <br />
   ; Grid the data with the Radial Basis Function method.
   <br />
   grid = GRIDDATA(xSorted, ySorted, dataSorted, $
   <br />
   DIMENSION = gridSize, METHOD = 'RadialBasisFunction')
  </p>
  <p>
   Finally, we open a second display window and contour the  Radial Basis Function results:
  </p>
  <p class="Code">
   WINDOW, 1
   <br />
   scaled = BYTSCL(grid, TOP = !D.TABLE_SIZE - 4) + 1B
   <br />
   CONTOUR, scaled, xGrid, YGrid, /XSTYLE, /YSTYLE, /FILL, $
   <br />
   &#160;&#160;&#160;LEVELS = BYTSCL(INDGEN(18), TOP = !D.TABLE_SIZE - 4) + 1B, $
   <br />
   &#160;&#160;&#160;C_COLORS = BYTSCL(INDGEN(18), TOP = !D.TABLE_SIZE - 4) + 1B, $
   <br />
   &#160;&#160;&#160;TITLE = 'The Resulting Grid with Radial Basis Function', $
   <br />
   &#160;&#160;&#160;XTITLE = 'x', YTITLE = 'y'
   <br />
  </p>
  <h3>
   <a name="G_845992557_878089_Keywords_GRIDDATA__">
   </a>
   <a name="G_845992557_878089_PageTOC_GRIDDATA_">
   </a>
   Example 7
  </h3>
  <p>
   The following example uses the data from the
   <span class="Courier">
    irreg_grid1.txt
   </span>
   ASCII file. This file contains scattered elevation data of a model of an inlet. This scattered elevation data contains two duplicate locations. The same data is used in the previous example.
  </p>
  <p>
   The GRID_INPUT procedure is used to omit the duplicate locations for the GRIDDATA function. The GRIDDATA function is then used to grid the data using the Radial Basis Function method. This method is specified by setting the METHOD keyword the
   <span class="Courier">
    RadialBasisFunction
   </span>
   string, although it could easily be done using the RADIAL_BASIS_FUNCTION keyword.
  </p>
  <p>
   Faulting is also applied in this example. First, a fault area is placed around the right side of the dataset. This fault area contains data points. The data points within this area are gridded separately from the points outside of the fault area.
  </p>
  <p>
   Then, a fault area is defined within an region that does not contain any data points. Since this fault area does not contain any points, the grid within this region simply results to the value defined by the MISSING keyword. The points outside of the fault area are gridded independent of the fault region.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   Execute all of the following example sections in the order they are presented here.
  </p>
  <p>
   First, we import the data:
  </p>
  <p class="Code">
   file = FILEPATH('irreg_grid1.txt', $
   <br />
   &#160;&#160;&#160;SUBDIRECTORY = ['examples', 'data'])
   <br />
   <br />
   ; Import the data from the file into a structure.
   <br />
   dataStructure = READ_ASCII(file)
   <br />
   <br />
   ; Get the imported array from the first field of the structure.
   <br />
   dataArray = TRANSPOSE(dataStructure.field1)
   <br />
   <br />
   ; Initialize the variables of this example from
   <br />
   ; the imported array.
   <br />
   x = dataArray[*, 0]
   <br />
   y = dataArray[*, 1]
   <br />
   data = dataArray[*, 2]
   <br />
  </p>
  <p>
   Do some pre-processing before gridding the data. GRID_INPUT will remove any duplicate locations.
  </p>
  <p class="Code">
   GRID_INPUT, x, y, data, xSorted, ySorted, dataSorted
   <br />
   <br />
   ; Initialize the grid parameters.
   <br />
   gridSize = [51, 51]
   <br />
   <br />
   ; Use the equation of a straight line and the grid parameters to
   <br />
   ; determine the x of the resulting grid.
   <br />
   slope = (MAX(xSorted) - MIN(xSorted))/(gridSize[0] - 1)
   <br />
   intercept = MIN(xSorted)
   <br />
   xGrid = (slope*FINDGEN(gridSize[0])) + intercept
   <br />
   <br />
   ; Use the equation of a straight line and the grid parameters to
   <br />
   ; determine the y of the resulting grid.
   <br />
   slope = (MAX(ySorted) - MIN(ySorted))/(gridSize[1] - 1)
   <br />
   intercept = MIN(ySorted)
   <br />
   yGrid = (slope*FINDGEN(gridSize[1])) + intercept
   <br />
  </p>
  <p>
   Grid the data with a fault area containing data points:
  </p>
  <p class="Code">
   faultVertices0 = [[2200, 4000], [2200, 3000], [2600, 2700], $
   <br />
   &#160;&#160;&#160;[2600, -50], [5050, -50], [5050, 4000], [2200, 4000]]
   <br />
   faultConnectivity0 = [7, 0, 1, 2, 3, 4, 5, 6, -1]
   <br />
   <br />
   ; Grid the data with faulting using the Radial Basis Function
   <br />
   ; method.
   <br />
   grid0 = GRIDDATA(xSorted, ySorted, dataSorted, $
   <br />
   &#160;&#160;&#160;DIMENSION = gridSize, METHOD = 'RadialBasisFunction', $
   <br />
   &#160;&#160;&#160;FAULT_XY = faultVertices0, $
   <br />
   &#160;&#160;&#160;FAULT_POLYGONS = faultConnectivity0, $
   <br />
   &#160;&#160;&#160;MISSING = MIN(dataSorted))
   <br />
  </p>
  <p>
   Grid the data again with a fault area that does not contain data points:
  </p>
  <p class="Code">
   faultVertices1 = [[2600, -50], [2800, -50], [2800, 2700], $
   <br />
   &#160;&#160;&#160;[2400, 3000], [2400, 4000], [2200, 4000], [2200, 3000], $
   <br />
   &#160;&#160;&#160;[2600, 2700], [2600, -50]]
   <br />
   faultConnectivity1 = [9, 0, 1, 2, 3, 4, 5, 6, 7, 8, -1]
   <br />
   <br />
   ; Grid the data with faulting using the Radial Basis Function
   <br />
   ; method.
   <br />
   grid1 = GRIDDATA(xSorted, ySorted, dataSorted, $
   <br />
   &#160;&#160;&#160;DIMENSION = gridSize, METHOD = 'RadialBasisFunction', $
   <br />
   &#160;&#160;&#160;FAULT_XY = faultVertices1, $
   <br />
   &#160;&#160;&#160;FAULT_POLYGONS = faultConnectivity1, $
   <br />
   &#160;&#160;&#160;MISSING = MIN(dataSorted))
   <br />
  </p>
  <p>
   Finally, we tell IDL to use decomposed color mode (a maximum of 256 colors) and load a color table, then display our gridded results:
  </p>
  <p class="Code">
   DEVICE, DECOMPOSED = 0
   <br />
   LOADCT, 38
   <br />
   WINDOW, 0, XSIZE = 600, YSIZE = 600, $
   <br />
   &#160;&#160;&#160;TITLE = 'The Resulting Grid from the Radial Basis Function '+ $
   <br />
   &#160;&#160;&#160;'Method with Faulting'
   <br />
   !P.MULTI = [0, 1, 2, 0, 0]
   <br />
   <br />
   ; Display grid results.
   <br />
   CONTOUR, BYTSCL(grid0), xGrid, YGrid, /XSTYLE, /YSTYLE, /FILL, $
   <br />
   &#160;&#160;&#160;LEVELS = BYTSCL(INDGEN(18)), C_COLORS = BYTSCL(INDGEN(18)), $
   <br />
   &#160;&#160;&#160;TITLE = 'Fault Area Contains Data ' + $
   <br />
   &#160;&#160;&#160;'(Fault Area in Dashed Lines)', XTITLE = 'x', YTITLE = 'y'
   <br />
   <br />
   ; Display outline of fault area.
   <br />
   PLOTS, faultVertices0, /DATA, LINESTYLE = 2, THICK = 2
   <br />
   <br />
   ; Display grid results.
   <br />
   CONTOUR, BYTSCL(grid1), xGrid, YGrid, /XSTYLE, /YSTYLE, /FILL, $
   <br />
   &#160;&#160;&#160;LEVELS = BYTSCL(INDGEN(18)), C_COLORS = BYTSCL(INDGEN(18)), $
   <br />
   &#160;&#160;&#160;TITLE = 'Fault Area Does Not Contain Data '+ $
   <br />
   &#160;&#160;&#160;'(Fault Area in Dashed Lines)', XTITLE = 'x', YTITLE = 'y'
   <br />
   <br />
   ; Display outline of fault area.
   <br />
   PLOTS, faultVertices1, /DATA, LINESTYLE = 2, THICK = 2
   <br />
   <br />
   ; Set system variable back to default value.
   <br />
   !P.MULTI = 0
   <br />
  </p>
  <h2 class="API">
   <a name="G_845992557_878188_PageTOC_GRIDDATA_">
   </a>
   References
  </h2>
  <h3>
   <a name="G_845992557_878189_Keywords_GRIDDATA__">
   </a>
   Kriging
  </h3>
  <p>
   Isaaks, E. H., and Srivastava, R. M., An Introduction to Applied Geostatistics, Oxford University Press, New York, 1989.
  </p>
  <h3>
   <a name="G_845992557_878191_Keywords_GRIDDATA__">
   </a>
   Minimum Curvature
  </h3>
  <p>
   Barrodale, I., et al, "Warping Digital Images Using Thin Plate Splines", Pattern Recognition, Vol 26, No 2, pp. 375-376., 1993.
  </p>
  <p>
   Powell, M.J.D., “Tabulation of thin plate splines on a very fine two-dimensional grid”, Report No. DAMTP 1992/NA2, University of Cambridge, Cambridge, U.K. 1992.
  </p>
  <h3>
   <a name="G_845992557_878194_Keywords_GRIDDATA__">
   </a>
   Modified Shepard’s
  </h3>
  <p>
   Franke, R., and Nielson, G. , "Smooth Interpolation of Large Sets of Scattered Data", International Journal for Numerical Methods in Engineering, v. 15, 1980, pp. 1691-1704.
  </p>
  <p>
   Renka, R. J., Algorithm 790 - CSHEP2D: Cubic Shepard Method for Bivariate Interpolation of Scattered Data, Robert J. Renka, ACM Trans. Math Softw. 25, 1 (March 1999), pp. 70-73.
  </p>
  <p>
   Shepard, D., "A Two Dimensional Interpolation Function for Irregularly Spaced Data", Proc. 23rd Nat. Conf. ACM, 1968, pp. 517-523.
  </p>
  <h3>
   <a name="G_845992557_878198_Keywords_GRIDDATA__">
   </a>
   Natural Neighbor
  </h3>
  <p>
   Watson, D. F., Contouring: A Guide to the Analysis and Display of Spatial Data, Pergamon Press, ISBN 0 08 040286 0, 1992.
  </p>
  <p>
   Watson, D. F., Nngridr - An Implementation of Natural Neighbor Interpolation, David Watson, P.O. Box 734, Clarement, WA 6010, Australia, 1994.
  </p>
  <h3>
   <a name="G_845992557_878201_Keywords_GRIDDATA__">
   </a>
   Quintic
  </h3>
  <p>
   Akima, H., Algorithm 761 - Scattered-data Surface Fitting that has the Accuracy of a Cubic Polynomial, Hiroshi Akima, ACM Trans. Math. Softw. 22, 3 (Sep. 1996), pp. 362 - 371.
  </p>
  <p>
   Renka, R.J., "A Triangle-based C1 Interpolation Method", Rocky Mountain Journal of Mathematics, Vol 14, No. 1, 1984.
  </p>
  <h3>
   <a name="G_845992557_878204_Keywords_GRIDDATA__">
   </a>
   Radial Basis Function
  </h3>
  <p>
   Franke, R., A Critical Comparison of Some Methods for Interpolation of Scattered Data, Naval Postgraduate School, Technical Report, NPS 53-79-003, 1979.
  </p>
  <p>
   Hardy, R.L., "Theory and Applications of the Multiquadric-biharmonic Method", Computers Math. With Applic, v 19,  no. 8/9, 1990, pp.163-208.
  </p>
  <h2 class="API">
   <a name="G_845992557_878207">
   </a>
   <a name="G_845992557_878207_PageTOC_GRIDDATA_">
   </a>
   Version History
  </h2>
  <table style="width: 499px;caption-side: top;mc-table-style: url('../../Resources/TableStyles/VersionTable.css');" cellspacing="0" class="TableStyle_VersionTable">
   <col width="91px" />
   <col width="408px" />
   <tbody>
    <tr>
     <td class="TableStyle_VersionTable_Body_0_0_RowEnd_ColSep">
      <p>
       5.5
      </p>
     </td>
     <td class="TableStyle_VersionTable_Body_0_0_RowEnd_ColEnd">
      <p>
       Introduced
      </p>
     </td>
    </tr>
   </tbody>
  </table>
  <h2 class="API">
   <a name="G_845992557_881408">
   </a>
   <a name="G_845992557_881408_PageTOC_GRIDDATA_">
   </a>
   See Also
  </h2>
  <p>
   <a class="MCXref_Heading_0" href="GRID_INPUT.html#G_845992557_877021">
    GRID_INPUT
   </a>
  </p>
  <div class="mp_footer">
   Copyright ©
   <span class="DocumentTitleCopyrightYear">
    2012
   </span>
   <![CDATA[ ]]>
   <span class="DocumentTitleCopyrightCompanyName">
    Exelis Visual Information Solutions, Inc.
   </span>
   All Rights Reserved.
  </div>
  <script type="text/javascript" src="../../SkinSupport/MadCapBodyEnd.js">
  </script>
 </body>
</html>