<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns:madcap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" madcap:lastblockdepth="2" madcap:lastheight="135.6667" madcap:lastwidth="592" madcap:disablemasterstylesheet="true" madcap:tocpath="Routines (alphabetical)|Routines: X" madcap:medium="non-print" madcap:inpreviewmode="false" madcap:preloadimages="false" madcap:runtimefiletype="Topic" madcap:targettype="WebHelp" lang="en-US" xml:lang="en-US" madcap:pathtohelpsystem="../../../" madcap:helpsystemfilename="idl.xml" madcap:searchtype="Stem">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>
   XMANAGER
  </title>
  <link href="../../SkinSupport/MadCap.css" rel="stylesheet" />
  <link href="../../Resources/TableStyles/VersionTable.css" rel="stylesheet" />
  <link href="../../Resources/Stylesheets/IDL_style.css" rel="stylesheet" />
  <script src="../../SkinSupport/MadCapAll.js" type="text/javascript">
  </script>
 </head>
 <body>
  <p class="MCWebHelpFramesetLink" style="display: none;">
   <a href="../../../idl_CSH.html#Reference Material/X/XMANAGER.html" style="">
    Open topic with navigation
   </a>
  </p>
  <div class="MCBreadcrumbsBox_0">
   <span class="MCBreadcrumbsPrefix">
    <![CDATA[ ]]>
   </span>
   <a class="MCBreadcrumbsLink" href="../../images/ref_part1.html">
    Routines (alphabetical)
   </a>
   <span class="MCBreadcrumbsDivider">
    &gt;
   </span>
   <a class="MCBreadcrumbsLink" href="X_list.html">
    Routines: X
   </a>
   <span class="MCBreadcrumbsDivider">
    &gt;
   </span>
   <span class="MCBreadcrumbs">
    XMANAGER
   </span>
  </div>
  <h1 class="Routine">
   <a name="X_800576109_762775">
   </a>
   <a name="X_800576109_55404">
   </a>
   XMANAGER
  </h1>
  <p madcap:conditions="Reference Material.Online_Help_Only">
   <madcap:conditionaltext madcap:conditions="Reference Material.Online_Help_Only">
    <a class="MCXref_Heading_0" href="#X_800576109_762781">
     Syntax
    </a>
    |
    <a class="MCXref_Heading_0" href="#X_800576109_762783">
     Arguments
    </a>
    |
    <a class="MCXref_Heading_0" href="#X_800576109_762788">
     Keywords
    </a>
    |
    <a class="MCXref_Heading_0" href="#X_800576109_900707">
     Examples
    </a>
    |
    <a class="MCXref_Heading_0" href="#X_800576109_762828">
     Version History
    </a>
    |
    <a class="MCXref_Heading_0" href="#X_800576109_991426">
     See Also
    </a>
   </madcap:conditionaltext>
  </p>
  <p>
   The
   <a name="kanchor3021">
   </a>
   XMANAGER procedure provides the
   <a name="kanchor3022">
   </a>
   main event loop and
   <a name="kanchor3023">
   </a>
   management for widgets created using IDL. Calling XMANAGER “registers” a widget program with the XMANAGER event handler. XMANAGER takes control of event processing until all widgets have been destroyed.
  </p>
  <p>
   Beginning with IDL version 5.0, IDL supports an
   <i>
    active command line
   </i>
   that allows the IDL command line to continue accepting input while properly configured widget applications are running. See
   <a class="MCXref_Heading_0" href="#X_800576109_900706" target="" title="" alt="">
    A Note About Blocking in XMANAGER
   </a>
   for a more detailed explanation of the active command line.
  </p>
  <p>
   This routine is written in the IDL language. Its source code can be found in the file
   <span class="Courier">
    xmanager.pro
   </span>
   in the
   <span class="Courier">
    lib
   </span>
   subdirectory of the IDL distribution.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   Although this routine is written in the IDL language, it may change in the future in its internal implementation. For future upgradability, it is best not to modify or even worry about what this routine does internally.
  </p>
  <h2 class="API">
   <a name="X_800576109_762781">
   </a>
   <a name="X_800576109_762781_PageTOC_XMANAGER_">
   </a>
   Syntax
  </h2>
  <p class="Syntax">
   XMANAGER [,&#160;
   <i>
    Name
   </i>
   ,
   <i>
    ID
   </i>
   ] [,&#160;/
   <a class="MCXref_Heading_0" href="#X_800576109_919187">
    CATCH
   </a>
   ] [,&#160;
   <a class="MCXref_Heading_0" href="#X_800576109_762794">
    CLEANUP
   </a>
   =
   <i>
    string
   </i>
   ] [,&#160;
   <a class="MCXref_Heading_0" href="#X_800576109_762797">
    EVENT_HANDLER
   </a>
   =‘
   <i>
    procedure_name
   </i>
   ’] [,&#160;
   <a class="MCXref_Heading_0" href="#X_800576109_762800">
    GROUP_LEADER
   </a>
   =
   <i>
    widget_id
   </i>
   ] [,&#160;/
   <a class="MCXref_Heading_0" href="#X_800576109_762804">
    JUST_REG
   </a>
   ] [,&#160;/
   <a class="MCXref_Heading_0" href="#X_800576109_921241">
    NO_BLOCK
   </a>
   ]
  </p>
  <h2 class="API">
   <a name="X_800576109_762783">
   </a>
   <a name="X_800576109_762783_PageTOC_XMANAGER_">
   </a>
   Arguments
  </h2>
  <h3 class="Argument">
   Name
  </h3>
  <p>
   A string that contains the name of the routine that creates the widget (i.e., the name of the widget creation routine that is calling XMANAGER).
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   The
   <i>
    Name
   </i>
   argument is stored in a COMMON block for use by the
   <a class="MCXref_Heading_0" href="XREGISTERED.html#X_800576109_762885" target="" title="" alt="">
    XREGISTERED
   </a>
   routine. The stored name is case-sensitive.
  </p>
  <h3 class="Argument">
   ID
  </h3>
  <p>
   The widget ID of the top-level base that is the root of the widget hierarchy being to be managed.
  </p>
  <h2 class="API">
   <a name="X_800576109_762788">
   </a>
   <a name="X_800576109_762788_PageTOC_XMANAGER_">
   </a>
   Keywords
  </h2>
  <h3 class="Keyword">
   <a name="X_800576109_919187">
   </a>
   <a name="X_800576109_919187_Keywords_XMANAGER__">
   </a>
   <a name="X_800576109_30366">
   </a>
   CATCH
  </h3>
  <p>
   Set this keyword to cause XMANAGER to catch any errors, using the
   <a class="MCXref_Heading_0" href="../C/CATCH.html#C_854643309_985147" target="" title="" alt="">
    CATCH
   </a>
   procedure, when dispatching widget events. If the CATCH keyword is set equal to zero, execution halts and IDL provides traceback information when an error is detected. This keyword is set by default (errors are caught and processing continues).
  </p>
  <p>
   Do not specify either the
   <i>
    Name
   </i>
   or
   <i>
    ID
   </i>
   argument to XMANAGER when specifying the CATCH keyword (they are ignored). CATCH turns error catching on and off for
   <i>
    all
   </i>
   applications managed by XMANAGER. When CATCH is specified, XMANAGER changes its error-catching behavior and returns immediately, without taking any other action.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   Beginning with IDL version 5.0, the default behavior of XMANAGER is to catch errors and continue processing events. In versions of IDL prior to version 5.0, XMANAGER halted when an error was detected. This change in default behavior was necessary in order to allow multiple widget applications (all being managed by XMANAGER) to coexist peacefully. When CATCH is set equal to zero, (the old behavior), any error halts XMANAGER, and thus halts event processing for all running widget applications.
   <br />
   <br />
   Note also that CATCH is only effective if XMANAGER is blocking to dispatch errors. If event dispatching for an active IDL command line is in use, the CATCH keyword has no effect.
   <br />
   <br />
   The CATCH=0 setting (errors are not caught and processing halts in XMANAGER when an error is detected) is intended as a debugging aid. Finished programs should not set CATCH=0.
  </p>
  <h3 class="Keyword">
   <a name="X_800576109_762794">
   </a>
   <a name="X_800576109_762794_Keywords_XMANAGER__">
   </a>
   <a name="X_800576109_15947">
   </a>
   CLEANUP
  </h3>
  <p>
   Set this keyword to a string that contains the name of the routine to be called when the widget program dies. If this keyword is not specified, the routine (if any) specified for the program’s top-level base by the KILL_NOTIFY keyword to WIDGET_BASE or WIDGET_CONTROL is used.
  </p>
  <p>
   The routine specified by CLEANUP becomes the KILL_NOTIFY routine for the widget application, overriding any cleanup routines that have been set previously via the KILL_NOTIFY keyword to WIDGET_BASE or WIDGET_CONTROL.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   Specifying a routine for the widget application’s top-level base via the KILL_NOTIFY keyword to WIDGET_CONTROL
   <i>
    after
   </i>
   the call to XMANAGER will override the value of the CLEANUP keyword.
  </p>
  <p>
   The cleanup routine is called with the widget identifier as its only argument.
  </p>
  <h3 class="Keyword">
   <a name="X_800576109_762797">
   </a>
   <a name="X_800576109_762797_Keywords_XMANAGER__">
   </a>
   <a name="X_800576109_24920">
   </a>
   EVENT_HANDLER
  </h3>
  <p>
   Set this keyword to a string that contains the name of a routine to be called when a widget event occurs in the widget program being registered. If this keyword is not supplied, XMANAGER will construct a default name by adding the “_event” suffix to the
   <i>
    Name
   </i>
   argument. See the example below for a more detailed explanation.
  </p>
  <h3 class="Keyword">
   <a name="X_800576109_762800">
   </a>
   <a name="X_800576109_762800_Keywords_XMANAGER__">
   </a>
   GROUP_LEADER
  </h3>
  <p>
   The widget ID of the group leader for the widget being processed. When the leader dies either by the users actions or some other routine, all widgets that have that leader will also die.
  </p>
  <p>
   For example, a widget that views a help file for a demo widget would have that demo widget as its leader. When the help widget is registered, it sets the keyword GROUP_LEADER to the widget ID of the demo widget. If the demo widget were destroyed, the help widget led by it would be killed by the XMANAGER.
  </p>
  <h3 class="Keyword">
   <a name="X_800576109_762804">
   </a>
   <a name="X_800576109_762804_Keywords_XMANAGER__">
   </a>
   JUST_REG
  </h3>
  <p>
   Set this keyword to indicate that XMANAGER should just register the widget and return immediately. This keyword is useful if you want to register a group of related top-level widgets before beginning event processing and one or more of the registered widgets requests that XMANAGER block event processing. (Note that in this case a later call to XMANAGER without the JUST_REG keyword is necessary to begin blocking.)
  </p>
  <p>
   (See
   <a class="MCXref_Heading_0" href="#X_800576109_900706" target="" title="" alt="">
    A Note About Blocking in XMANAGER
   </a>
   for further discussion of the active command line.)
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   JUST_REG is not the same as NO_BLOCK. See
   <a class="MCXref_Heading_0" href="#X_800576109_900708" target="" title="" alt="">
    JUST_REG vs. NO_BLOCK
   </a>
   for additional details.
  </p>
  <h3 class="Keyword">
   <a name="X_800576109_921241">
   </a>
   <a name="X_800576109_921241_Keywords_XMANAGER__">
   </a>
   <a name="X_800576109_32479">
   </a>
   NO_BLOCK
  </h3>
  <p>
   Set this keyword to tell XMANAGER that the registering client does not require XMANAGER to block if active command line event processing is available. If active command line event processing is available
   <i>
    and
   </i>
   every current XMANAGER client specifies NO_BLOCK, then XMANAGER will not block and the user will have access to the command line while widget applications are running.
  </p>
  <p>
   It is important to understand the result of making nested calls to XMANAGER. XMANAGER can only block event processing for one client at a time. In applications involving multiple calls to XMANAGER (either directly or via calls to other routines that call XMANAGER, such as XLOADCT), blocking occurs only for the outermost call to XMANAGER, unless XMANAGER is told not to block in that call. If an application contains two calls to XMANAGER, the second call cannot block unless the first call sets the NO_BLOCK keyword. If an application contains a call to XMANAGER, followed by a call to XLOADCT, XLOADCT will not block unless the NO_BLOCK keyword was set in the call to XMANAGER (and the BLOCK keyword to XLOADCT is set). Consider the following example:
  </p>
  <p class="Code">
   PRO blocking_example_event, event
  </p>
  <p class="Code">
   &#160;&#160;&#160;; The following call blocks only if the NO_BLOCK keyword to
  </p>
  <p class="Code">
   &#160;&#160;&#160;; XMANAGER is set:
  </p>
  <p class="Code">
   &#160;&#160;&#160;XLOADCT, /BLOCK
  </p>
  <p class="Code">
   END
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   PRO blocking_example
  </p>
  <p class="Code">
   &#160;&#160;&#160;base=WIDGET_BASE(/COLUMN)
  </p>
  <p class="Code">
   &#160;&#160;&#160;button1=WIDGET_BUTTON(base,VALUE='Run XLOADCT')
  </p>
  <p class="Code">
   &#160;&#160;&#160;WIDGET_CONTROL,base, /REALIZE
  </p>
  <p class="Code">
   &#160;&#160;&#160;XMANAGER,'blocking_example', base, /NO_BLOCK
  </p>
  <p class="Code">
   END
  </p>
  <p>
   If the NO_BLOCK keyword to XMANAGER was not set in the above example, XLOADCT would not block, even though the BLOCK keyword was set. Setting the NO_BLOCK keyword to XMANAGER prevents XMANAGER from blocking, thereby allowing the subsequent call to XMANAGER (via XLOADCT) to block.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   NO_BLOCK is not the same as JUST_REG. See
   <a class="MCXref_Heading_0" href="#X_800576109_900708" target="" title="" alt="">
    JUST_REG vs. NO_BLOCK
   </a>
   for additional details.
  </p>
  <h2 class="API">
   <a name="X_800576109_900706">
   </a>
   <a name="X_800576109_900706_PageTOC_XMANAGER_">
   </a>
   <a name="X_800576109_12599">
   </a>
   A Note About Blocking in XMANAGER
  </h2>
  <p>
   By default, IDL widget application blocking is
   <i>
    enabled
   </i>
   . Unless you take the appropriate steps, widget applications will block all other processing from occurring in IDL. Keeping the following issues in mind when writing widget applications will give you the best chance to create applications that coexist with other applications and the IDL command line.
  </p>
  <h3>
   <a name="X_800576109_991244">
   </a>
   <a name="X_800576109_991244_Keywords_XMANAGER__">
   </a>
   <a name="X_800576109_10295">
   </a>
   Active Command Line
  </h3>
  <p>
   Beginning with IDL version 5.0, most versions of IDL’s command-processing front-end are able to support an
   <i>
    <a name="kanchor3024">
    </a>
    active command line
   </i>
   while running properly constructed widget applications. What this means is that—provided the widget application is properly configured—the IDL command line is available for input while a widget application is running and widget events are being processed.
  </p>
  <p>
   There are currently 2 separate IDL command-processing front-end implementations:
  </p>
  <p class="Bullet">
   The IDL Workbench
  </p>
  <p class="Bullet">
   UNIX plain tty
  </p>
  <p>
   Note that widget applications must be well-behaved with respect to blocking widget event processing. Since in most cases XMANAGER is used to handle widget event processing, this means that in order for the command line to remain active, all widget applications must be run with the NO_BLOCK keyword to XMANAGER set. (Note that since NO_BLOCK is
   <i>
    not
   </i>
   the default, it is quite likely that some application will block.) If a single application runs in blocking mode, the command line will be inaccessible until the blocking application exits. When a blocking application exits, the IDL command line will once again become active.
  </p>
  <h3>
   <a name="X_800576109_900708">
   </a>
   <a name="X_800576109_900708_Keywords_XMANAGER__">
   </a>
   <a name="X_800576109_38729">
   </a>
   JUST_REG vs. NO_BLOCK
  </h3>
  <p>
   Although their names imply a similar function, the JUST_REG and NO_BLOCK keywords perform very different services. It is important to understand what they do and how they differ.
  </p>
  <p>
   The JUST_REG keyword tells XMANAGER that it should simply register a client and then return immediately. The result is that the client becomes known to XMANAGER, and that future calls to XMANAGER will take this client into account. Therefore, JUST_REG only controls how the registering call to XMANAGER should behave. The client can still be registered as requiring XMANAGER to block by setting NO_BLOCK=0. In this case,
   <i>
    future
   </i>
   calls to XMANAGER will block.
  </p>
  <p>
   The NO_BLOCK keyword tells XMANAGER that the registered client does not require XMANAGER to block if the command-processing front-end is able to support active command line event processing. XMANAGER remembers this attribute of the client until the client exits, even after the call to XMANAGER that registered the client returns. NO_BLOCK is just a “vote” on how XMANAGER should behave—the final decision is made by XMANAGER by considering the NO_BLOCK attributes of
   <i>
    all
   </i>
   of its current clients as well as the ability of the command-processing front-end in use to support the active command line.
  </p>
  <h3>
   <a name="X_800576109_921528">
   </a>
   <a name="X_800576109_921528_Keywords_XMANAGER__">
   </a>
   <a name="X_800576109_21342">
   </a>
   Blocking vs. Non-blocking Applications
  </h3>
  <p>
   The issue of blocking in XMANAGER requires some explanation. IDL widget events are not processed until the WIDGET_EVENT function is called to handle them. Otherwise, they are queued by IDL indefinitely. Knowing how and when to call WIDGET_EVENT is the primary service provided by XMANAGER.
  </p>
  <p>
   There are two ways blocking is typically handled:
  </p>
  <table class="AutoNumber_p_Numbered1" style="width: 100%; margin-left: 0;" cellspacing="0" cellpadding="0">
   <col style="width: 16px;" />
   <col style="width: 24px;" />
   <col style="width: auto;" />
   <tr>
    <td valign="top">
    </td>
    <td class="AutoNumber_p_Numbered1" valign="top">
     <span>
      1.
     </span>
    </td>
    <td class="AutoNumber_p_Numbered1" madcap:autonum="1. " valign="top">
     The first call to XMANAGER processes events by calling WIDGET_EVENT as necessary until no managed widgets remain on the screen. This is referred to as “blocking” because XMANAGER does not return to the caller until it is done, and the IDL command line is not available.
    </td>
   </tr>
  </table>
  <table class="AutoNumber_p_Numbered1" style="width: 100%; margin-left: 0;" cellspacing="0" cellpadding="0">
   <col style="width: 16px;" />
   <col style="width: 24px;" />
   <col style="width: auto;" />
   <tr>
    <td valign="top">
    </td>
    <td class="AutoNumber_p_Numbered1" valign="top">
     <span>
      2.
     </span>
    </td>
    <td class="AutoNumber_p_Numbered1" madcap:autonum="2. " valign="top">
     XMANAGER does not block, and instead, the part of IDL that reads command input also watches for widget events and calls WIDGET_EVENT as necessary while also reading command input. This is referred to as “non-blocking” or “active command line” mode.
    </td>
   </tr>
  </table>
  <p>
   XMANAGER will block unless the following conditions are met:
  </p>
  <p class="Bullet">
   All registered widget applications have the NO_BLOCK keyword to XMANAGER set.
  </p>
  <p class="Bullet">
   No modal dialogs are displayed. (Modal dialogs always block until dismissed.)
  </p>
  <p>
   In general, we suggest that new widget applications be written with XMANAGER blocking disabled (that is, with the NO_BLOCK keyword set).
  </p>
  <p>
   Since a widget application that does block event processing for itself will block event processing for all other widget applications (and the IDL command line) as well, we suggest that older widget applications be upgraded to take advantage of the new, non-blocking behavior by adding the NO_BLOCK keyword to most calls to XMANAGER.
  </p>
  <h2 class="API">
   <a name="X_800576109_900707">
   </a>
   <a name="X_800576109_900707_PageTOC_XMANAGER_">
   </a>
   Examples
  </h2>
  <p>
   The following code creates a widget named EXAMPLE that is just a base widget with a “Done” button and registers it with the XMANAGER. Widgets being registered with the XMANAGER must provide at least two routines. The first routine creates the widget and registers it with the manager and the second routine processes the events that occur within that widget. An example widget is supplied below that uses only two routines. A number of other “Simple Widget Examples”, can be viewed by entering
   <a name="kanchor3025">
   </a>
   <a name="kanchor3026">
   </a>
   WEXMASTER at the IDL prompt. These simple programs demonstrate many aspects of widget programming.
  </p>
  <p>
   The following lines of code would be saved in a single file, named
   <span class="Courier">
    example.pro
   </span>
   . Compile the file and enter
   <span class="Courier">
    example
   </span>
   at the IDL command line to run the code.
  </p>
  <p class="Code">
   ; Begin the event handler routine for the EXAMPLE widget:
   <br />
   PRO example_event, ev
   <br />
   <br />
   ; The uservalue is retrieved from a widget when an event occurs:
   <br />
   WIDGET_CONTROL, ev.id, GET_UVALUE = uv
   <br />
   <br />
   ; If the event occurred in the Done button, kill the widget
   <br />
   ; example:
   <br />
   if (uv eq 'DONE') THEN WIDGET_CONTROL, ev.top, /DESTROY
   <br />
   <br />
   ; End of the event handler part:
   <br />
   END
   <br />
   <br />
   ; This is the routine that creates the widget and registers it with
   <br />
   ; the XMANAGER:
   <br />
   PRO example
   <br />
   <br />
   ; Create the top-level base for the widget:
   <br />
   base = WIDGET_BASE(TITLE='Example', XSIZE=100, YSIZE=100)
   <br />
   <br />
   ; Create the Done button and set its uservalue to "DONE":
   <br />
   done = WIDGET_BUTTON(base, VALUE = 'Done', UVALUE = 'DONE', $
   <br />
   &#160;&#160;&#160;, XSIZE=100, YSIZE=100)
   <br />
   ; Realize the widget (i.e., display it on screen):
   <br />
   WIDGET_CONTROL, base, /REALIZE
   <br />
   <br />
   ; Register the widget with the XMANAGER, leaving the IDL command
   <br />
   ; line active:
   <br />
   XMANAGER, 'example', base, /NO_BLOCK
   <br />
   <br />
   ; End of the widget creation part:
   <br />
   END
  </p>
  <p>
   First the event handler routine is listed. The handler routine has the same name as the main routine with the characters “_event” added. If you would like to use another event handler name, you would need to pass its name to XMANAGER using the EVENT_HANDLER keyword.
  </p>
  <p>
   Notice that the event routine is listed before the main routine. If you include both the event routine and the main routine in a single
   <span class="Courier">
    .pro
   </span>
   file with the name of the main routine (a common practice), this is necessary to ensure that the event routine is compiled. If the event routine were placed after the main routine in the file, IDL would compile and execute the main routine — and the compiler would exit — before the event routine was compiled. Alternatively, you can save your event routine in its own file with its own name (which in the above example would be
   <span class="Courier">
    example_event.pro
   </span>
   ), and IDL will compile the routine when it is required.
  </p>
  <p>
   Notice also the NO_BLOCK keyword to XMANAGER has been included. This allows IDL to continue processing events and accepting input at the command prompt while the
   <span class="Courier">
    example
   </span>
   widget application is running.
  </p>
  <h2 class="API">
   <a name="X_800576109_762828">
   </a>
   <a name="X_800576109_762828_PageTOC_XMANAGER_">
   </a>
   Version History
  </h2>
  <table style="width: 499px;caption-side: top;mc-table-style: url('../../Resources/TableStyles/VersionTable.css');" cellspacing="0" class="TableStyle_VersionTable">
   <col width="91px" />
   <col width="408px" />
   <tbody>
    <tr>
     <td class="TableStyle_VersionTable_Body_0_0_ColSep">
      <p>
       Pre-4.0
      </p>
     </td>
     <td class="TableStyle_VersionTable_Body_0_0_ColEnd">
      <p>
       Introduced
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_VersionTable_Body_0_0_RowEnd_ColSep">
      <p>
       Pre-6.2
      </p>
     </td>
     <td class="TableStyle_VersionTable_Body_0_0_RowEnd_ColEnd">
      <p>
       Deprecated BACKGROUND and MODAL
      </p>
     </td>
    </tr>
   </tbody>
  </table>
  <h2 class="API">
   <a name="X_800576109_991426">
   </a>
   <a name="X_800576109_991426_PageTOC_XMANAGER_">
   </a>
   See Also
  </h2>
  <p>
   <a class="MCXref_Heading_0" href="XMTOOL.html#X_800576109_762865">
    XMTOOL
   </a>
   ,
   <a href="XREGISTERED.html" target="" title="" alt="" class="MCXref_0">
    XREGISTERED
   </a>
   ,
   <a href="../../Creating IDL Programs/Creating Applications in IDL/About_Widgets.html#widget_apps_4063420628_1041647" class="MCXref_0">
    About Widgets
   </a>
  </p>
  <div class="mp_footer">
   Copyright ©
   <span class="DocumentTitleCopyrightYear">
    2012
   </span>
   <![CDATA[ ]]>
   <span class="DocumentTitleCopyrightCompanyName">
    Exelis Visual Information Solutions, Inc.
   </span>
   All Rights Reserved.
  </div>
  <script type="text/javascript" src="../../SkinSupport/MadCapBodyEnd.js">
  </script>
 </body>
</html>