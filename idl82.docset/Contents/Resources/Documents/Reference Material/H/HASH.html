<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns:madcap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" madcap:lastblockdepth="2" madcap:lastheight="135.6667" madcap:lastwidth="592" madcap:disablemasterstylesheet="true" madcap:tocpath="Routines (alphabetical)|Routines: H" madcap:medium="non-print" madcap:inpreviewmode="false" madcap:preloadimages="false" madcap:runtimefiletype="Topic" madcap:targettype="WebHelp" lang="en-US" xml:lang="en-US" madcap:pathtohelpsystem="../../../" madcap:helpsystemfilename="idl.xml" madcap:searchtype="Stem">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>
   HASH
  </title>
  <link href="../../SkinSupport/MadCap.css" rel="stylesheet" />
  <link href="../../Resources/TableStyles/VersionTable.css" rel="stylesheet" />
  <link href="../../Resources/Stylesheets/IDL_style.css" rel="stylesheet" />
  <script src="../../SkinSupport/MadCapAll.js" type="text/javascript">
  </script>
 </head>
 <body>
  <p class="MCWebHelpFramesetLink" style="display: none;">
   <a href="../../../idl_CSH.html#Reference Material/H/HASH.html" style="">
    Open topic with navigation
   </a>
  </p>
  <div class="MCBreadcrumbsBox_0">
   <span class="MCBreadcrumbsPrefix">
    <![CDATA[ ]]>
   </span>
   <a class="MCBreadcrumbsLink" href="../../images/ref_part1.html">
    Routines (alphabetical)
   </a>
   <span class="MCBreadcrumbsDivider">
    &gt;
   </span>
   <a class="MCBreadcrumbsLink" href="H_list.html">
    Routines: H
   </a>
   <span class="MCBreadcrumbsDivider">
    &gt;
   </span>
   <span class="MCBreadcrumbs">
    HASH
   </span>
  </div>
  <h1 class="Routine">
   <a name="L_826528365_1077832">
   </a>
   <a name="L_826528365_61288">
   </a>
   HASH
  </h1>
  <p madcap:conditions="Reference Material.Online_Help_Only">
   <madcap:conditionaltext madcap:conditions="Reference Material.Online_Help_Only">
    <a class="MCXref_Heading_0" href="#L_826528365_1077842">
     Syntax
    </a>
    |
    <a class="MCXref_Heading_0" href="#L_826528365_1077844">
     Return Value
    </a>
    |
    <a class="MCXref_Heading_0" href="#L_826528365_1077846">
     Arguments
    </a>
    |
    <a class="MCXref_Heading_0" href="#L_826528365_1077849">
     Keywords
    </a>
    |
    <a class="MCXref_Heading_0" href="#L_826528365_1077854">
     Examples
    </a>
    |
    <a class="MCXref_Heading_0" href="#L_826528365_1077856">
     Version History
    </a>
    |
    <a class="MCXref_Heading_0" href="#L_826528365_1077863">
     See Also
    </a>
   </madcap:conditionaltext>
  </p>
  <p>
   The
   <a name="kanchor1119">
   </a>
   HASH function creates a new
   <a name="kanchor1120">
   </a>
   hash. A
   <i>
    hash
   </i>
   is a compound data type that contains key-value pairs of different data types, including any mixture of scalars, arrays, structures, pointers, object references, lists, and other hashes.
  </p>
  <p>
   Hashes have the following properties:
  </p>
  <ul>
   <li value="1">
    Elements in a hash are unordered, and are indexed by a scalar key.
   </li>
   <li value="2">
    Hashes can change their size, growing and shrinking as elements are added or deleted.
   </li>
   <li value="3">
    Individual hash elements can change their value and data type without performance penalty.
   </li>
  </ul>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   While you can use IDL's array syntax to access elements in a hash, it is important to remember that a hash does not behave like an array in all cases. See below for a full description of the characteristics of a hash.
  </p>
  <h2 class="API">
   <a name="L_826528365_1077842">
   </a>
   <a name="L_826528365_1077842_PageTOC_HASH_">
   </a>
   Syntax
  </h2>
  <p class="Syntax">
   <i>
    Result
   </i>
   = HASH( [
   <i>
    Key
   </i>
   <sub class="italic">
    1
   </sub>
   ,
   <i>
    Value
   </i>
   <sub class="italic">
    1
   </sub>
   ,
   <i>
    Key
   </i>
   <sub class="italic">
    2
   </sub>
   ,
   <i>
    Value
   </i>
   <sub class="italic">
    2
   </sub>
   , ...
   <i>
    Key
   </i>
   <sub class="italic">
    n
   </sub>
   ,
   <i>
    Value
   </i>
   <sub class="italic">
    n
   </sub>
   ] [,&#160;/
   <a href="#EXTRACT">
    EXTRACT
   </a>
   ] [,&#160;/
   <a href="#NO_COPY">
    NO_COPY
   </a>
   ] )
  </p>
  <p>
   or
  </p>
  <p class="Syntax">
   <i>
    Result
   </i>
   = HASH(
   <i>
    Keys
   </i>
   ,
   <i>
    Values
   </i>
   [,&#160;/
   <a href="#EXTRACT">
    EXTRACT
   </a>
   ] )
  </p>
  <p>
   or
  </p>
  <p class="Syntax">
   <i>
    Result
   </i>
   = HASH(
   <i>
    Keys
   </i>
   <i>
    &#160;
   </i>
   )
  </p>
  <p>
   or
  </p>
  <p class="Syntax">
   <i>
    Result
   </i>
   = HASH(
   <i>
    Structure
   </i>
   [,&#160;/
   <a href="#EXTRACT">
    EXTRACT
   </a>
   ] )
  </p>
  <h2 class="API">
   Methods
  </h2>
  <p>
   <a href="#Hash::Co">
    Count
   </a>
  </p>
  <p>
   <a href="#Hash::HasKey">
    HasKey
   </a>
  </p>
  <p>
   <a href="#Hash::Is">
    IsEmpty
   </a>
  </p>
  <p>
   <a href="#Hash::Keys">
    Keys
   </a>
  </p>
  <p>
   <a href="#Hash::Remove">
    Remove
   </a>
  </p>
  <p>
   <a href="#Hash::ToStruct">
    ToStruct
   </a>
  </p>
  <p>
   <a href="#Hash::Values">
    Values
   </a>
  </p>
  <p>
   <a href="#Hash::Where">
    Where
   </a>
  </p>
  <h2 class="API">
   <a name="L_826528365_1077844">
   </a>
   <a name="L_826528365_1077844_PageTOC_HASH_">
   </a>
   Return Value
  </h2>
  <p>
   Returns a
   <i>
    reference
   </i>
   to a newly-created hash.
  </p>
  <h2 class="API">
   <a name="L_826528365_1077846">
   </a>
   <a name="L_826528365_1077846_PageTOC_HASH_">
   </a>
   Arguments
  </h2>
  <h3 class="Argument">
   Key
   <sub>
    n
   </sub>
  </h3>
  <p>
   Each
   <i>
    Key
   </i>
   argument can be a scalar string or number. The corresponding
   <i>
    Value
   </i>
   can be a scalar or array of any IDL data type including !NULL.
  </p>
  <p>
   Each
   <i>
    Key
   </i>
   argument can also be an array or list, in which case the corresponding
   <i>
    Value
   </i>
   must be a scalar, an array or a list. If
   <i>
    Value
   </i>
   is a scalar, then that value is copied into every key. Otherwise, if
   <i>
    Value
   </i>
   is an array or a list, it must contain the same number of elements as the keys. In this case each element of the
   <i>
    Key
   </i>
   and
   <i>
    Value
   </i>
   is inserted as a separate key-value pair. If a given key occurs more than once within the input arguments, the last value will be retained.
  </p>
  <p>
   If only
   <i>
    Keys
   </i>
   is supplied (as either a scalar, an array, or a list), then the corresponding values will be set to the default value of !NULL.
  </p>
  <p>
   If no keys or values are supplied, an empty hash is returned.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   For strings, the key is case sensitive. For example, "Abc" and "abc" will be considered as two separate keys. For numbers, the actual data type does not matter, only the numeric value is used. For example, 1b (byte), 1 (int), and 1.0 (float) will all equate to the same key. Note however that because of the precision of floating-point arithmetic, single-precision and double-precision keys may be considered as different numbers. For example, 0.1 (float) and 0.1d (double) will not equate to the same key.
  </p>
  <h3 class="Argument">
   Value
   <sub>
    n
   </sub>
  </h3>
  <p>
   Each
   <i>
    Value
   </i>
   argument can be a variable or expression of any IDL data type including !NULL.
  </p>
  <h3 class="Argument">
   Structure
  </h3>
  <p>
   Instead of passing in keys or values, a single IDL structure may be passed in. In this case, each tag/value pair within the structure will be inserted within the hash.
  </p>
  <h2 class="API">
   <a name="L_826528365_1077849">
   </a>
   <a name="L_826528365_1077849_PageTOC_HASH_">
   </a>
   Keywords
  </h2>
  <h3 class="Keyword">
   <a name="EXTRACT">
   </a>
   EXTRACT
  </h3>
  <p>
   By default, all values are put into the hash unchanged. If the EXTRACT keyword is set, then any structures (or substructures) will be converted into hashes before being inserted.
   <![CDATA[ ]]>
  </p>
  <h3 class="Keyword">
   <a name="NO_COPY">
   </a>
   NO_COPY
  </h3>
  <p>
   If the NO_COPY keyword is set, the value data is taken away from the
   <i>
    Value
   </i>
   variable and attached directly to the hash variable. The default behavior is to make a copy of the input values.
  </p>
  <h2 class="API">
   <a name="L_826528365_1077854">
   </a>
   <a name="L_826528365_1077854_PageTOC_HASH_">
   </a>
   Examples
  </h2>
  <h4>
   Create a hash containing three key-value pairs, with strings for keys
  </h4>
  <p class="Code">
   hash=HASH("one", 1.0, "blue", [255,0,0], "Pi", !DPI)
  </p>
  <p class="Code">
   PRINT, N_ELEMENTS(hash)
  </p>
  <p>
   IDL Prints:
  </p>
  <p class="Code">
   3
  </p>
  <h4>
   Create a hash with a mixture of number and string keys
  </h4>
  <p class="Code">
   hash = HASH(80301, 'Boulder', 'Joe', 48236)
  </p>
  <p class="Code">
   PRINT, hash[80301]
  </p>
  <p class="Code">
   PRINT, hash['Joe']
  </p>
  <p>
   IDL Prints:
  </p>
  <p class="Code">
   Boulder
  </p>
  <p class="Code">
   48236
  </p>
  <h4>
   Create a hash containing all of the elements of a list
  </h4>
  <p class="Code">
   keys = ['A', 'B', 'C', 'D', 'E', 'F', 'G']
  </p>
  <p class="Code">
   values = LIST('one', 2.0, 3, 4l, PTR_NEW(5), {n:6}, COMPLEX(7,0))
  </p>
  <p class="Code">
   hash = HASH(keys, values)
  </p>
  <p class="Code">
   PRINT, N_ELEMENTS(hash)
  </p>
  <p>
   IDL Prints:
  </p>
  <p class="Code">
   7
  </p>
  <h4>
   Create a hash from a structure, and also convert any substructures into hashes
  </h4>
  <p class="Code">
   struct = {FIELD1: 4.0, FIELD2: {SUBFIELD1: "hello", SUBFIELD2: 3.14}}
  </p>
  <p class="Code">
   hash = HASH(struct, /EXTRACT)
  </p>
  <p class="Code">
   PRINT, hash
  </p>
  <p class="Code">
   PRINT, hash['FIELD2']
  </p>
  <p>
   IDL Prints:
  </p>
  <p class="Code">
   FIELD2: &lt;ObjHeapVar3374(HASH)&gt;
  </p>
  <p class="Code">
   FIELD1:       4.00000
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   SUBFIELD1: hello
  </p>
  <p class="Code">
   SUBFIELD2:       3.14000
  </p>
  <h1 class="ObjMethod">
   <a name="Hash::Co">
   </a>
   Hash::Count
  </h1>
  <p>
   The
   <a name="kanchor1121">
   </a>
   Hash::Count function method returns the number of elements in the hash. Optionally, the Hash::Count method can return the number of matches to a given value.
  </p>
  <h2 class="API">
   Syntax
  </h2>
  <p class="Syntax">
   <i>
    Result
   </i>
   = hash.Count( [
   <i>
    Value
   </i>
   ] )
  </p>
  <h2 class="API">
   Return Value
  </h2>
  <p>
   By default, returns an integer containing the number of elements in the hash. If
   <i>
    Value
   </i>
   is supplied, then returns an integer giving the number of occurrences of
   <i>
    Value
   </i>
   within the hash.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   See the
   <a href="#Hash::Where" target="" title="" alt="" class="MCXref_0">
    Hash::Where
   </a>
   method for the rules that are used for comparing values.
  </p>
  <h2 class="API">
   Arguments
  </h2>
  <h3 class="Argument">
   Value
  </h3>
  <p>
   A value to search for within the hash.
  </p>
  <h2 class="API">
   Keywords
  </h2>
  <p>
   None
  </p>
  <p>
   <a name="Hash::HasKey">
   </a>
  </p>
  <h1 class="ObjMethod">
   Hash::HasKey
  </h1>
  <p>
   The Hash::HasKey function method tests whether a key or set of keys exists in a hash.
  </p>
  <h2 class="API">
   Syntax
  </h2>
  <p class="Syntax" style="font-style: normal;">
   <i>
    Result
   </i>
   = hash.HasKey(
   <i>
    Keys
   </i>
   )
  </p>
  <h2 class="API">
   Return Value
  </h2>
  <p>
   If
   <i>
    Keys
   </i>
   is a scalar, then returns a scalar 1 if the key exists in the hash, or a 0 otherwise. If
   <i>
    Keys
   </i>
   is an array or list, then returns an array of 0's or 1's.
  </p>
  <h2 class="API">
   Arguments
  </h2>
  <h3 class="Argument">
   Keys
  </h3>
  <p>
   A scalar key, or an array or list of keys.
  </p>
  <h2 class="API">
   Keywords
  </h2>
  <p>
   None.
  </p>
  <h2 class="API">
   Examples
  </h2>
  <p class="Code">
   hash = HASH('black', 0, 'gray', 128, 'grey', 128, 'white', 255)
  </p>
  <p class="Code">
   print, hash.HasKey('gray')
  </p>
  <p class="Code">
   print, hash.HasKey(['grey','red','white'])
  </p>
  <p>
   IDL Prints:
  </p>
  <p class="Code">
   1
  </p>
  <p class="Code">
   1 0 1
  </p>
  <h1 class="ObjMethod">
   <a name="Hash::Is">
   </a>
   Hash::IsEmpty
  </h1>
  <p>
   The Hash::IsEmpty function method tests whether the hash is empty or not.
  </p>
  <h2 class="API">
   Syntax
  </h2>
  <p class="Syntax">
   <i>
    Result
   </i>
   = hash.IsEmpty( )
  </p>
  <h2 class="API">
   Return Value
  </h2>
  <p>
   Returns 1 if the hash contains zero elements, and 0 otherwise.
  </p>
  <h2 class="API">
   Arguments
  </h2>
  <p>
   None.
  </p>
  <h2 class="API">
   Keywords
  </h2>
  <p>
   None.
  </p>
  <p>
   <a name="Hash::Keys">
   </a>
  </p>
  <h1 class="ObjMethod">
   Hash::Keys
  </h1>
  <p>
   The Hash::Keys function method returns a list containing all keys in a hash. The order of key/value pairs within hash.Keys() and hash.Values() is guaranteed to remain the same as long as no items are added or removed from the hash.
  </p>
  <h2 class="API">
   Syntax
  </h2>
  <p class="Syntax" style="font-style: normal;">
   <i>
    Result
   </i>
   = hash.Keys( )
  </p>
  <h2 class="API">
   Return Value
  </h2>
  <p>
   Returns a list containing all of the keys. If the hash is empty then an empty list is returned.
  </p>
  <h2 class="API">
   Arguments
  </h2>
  <p>
   None.
  </p>
  <h2 class="API">
   Keywords
  </h2>
  <p>
   None.
  </p>
  <h2 class="API">
   Examples
  </h2>
  <p class="Code">
   hash = HASH('black', 0, 'gray', 128, 'grey', 128, 'white', 255)
  </p>
  <p class="Code">
   list = hash.Keys()
  </p>
  <p class="Code">
   print, list
  </p>
  <p>
   IDL Prints:
  </p>
  <p class="Code">
   white
  </p>
  <p class="Code">
   black
  </p>
  <p class="Code">
   gray
  </p>
  <p class="Code">
   grey
  </p>
  <p>
   <a name="Hash::Remove">
   </a>
  </p>
  <h1 class="ObjMethod">
   Hash::Remove
  </h1>
  <p>
   The
   <a name="kanchor1122">
   </a>
   Hash::Remove method removes elements from a
   <a name="kanchor1123">
   </a>
   hash and optionally returns the removed value.
  </p>
  <h2 class="API">
   Syntax
  </h2>
  <p class="Syntax">
   hash.Remove [,&#160;
   <i>
    Keys
   </i>
   ] [,&#160;/ALL]
  </p>
  <p>
   or
  </p>
  <p class="Syntax">
   <i>
    Result
   </i>
   = hash.Remove( [,
   <i>
    Keys
   </i>
   ] [,&#160;/ALL] )
  </p>
  <h2 class="API">
   Return Value
  </h2>
  <p>
   If
   <i>
    Keys
   </i>
   is a scalar, then the result is the value itself. If
   <i>
    Keys
   </i>
   is an array or list of keys, then the result is a hash containing the removed key-value pairs.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   If the hash is empty, calling the Hash::Remove() function method will throw an error. The Hash::Remove procedure method will quietly return.
  </p>
  <h2 class="API">
   Arguments
  </h2>
  <h3 class="Argument">
   Keys
  </h3>
  <p>
   A scalar key or an array or list of keys to be removed. If no
   <i>
    Keys
   </i>
   are supplied, an arbitrarily-chosen element is removed.
  </p>
  <h2 class="API">
   Keywords
  </h2>
  <h3 class="Keyword">
   ALL
  </h3>
  <p>
   Set this keyword to remove all entries in
   <i>
    Hash
   </i>
   , leaving the hash empty, but still in existence.
  </p>
  <h2 class="API">
   <a name="L_826528365_1080430">
   </a>
   <a name="L_826528365_1080430_PageTOC_HASH_REMOVE_">
   </a>
   Examples
  </h2>
  <p>
   Create a hash and print its contents:
  </p>
  <p class="Code">
   hash = HASH("one", 1.0, "blue", [255,0,0], "Pi", !DPI)
  </p>
  <p class="Code">
   PRINT, hash
  </p>
  <p>
   IDL Prints:
  </p>
  <p class="Code">
   Pi, 3.141592798.6
  </p>
  <p class="Code">
   blue, 255       0       0
  </p>
  <p class="Code">
   one, 1.00000
  </p>
  <p>
   Now delete some hash elements and print the contents again:
  </p>
  <p class="Code">
   hash.Remove, ["one", "Pi"]
  </p>
  <p class="Code">
   PRINT, hash
  </p>
  <p class="Code">
   PRINT, N_ELEMENTS(hash)
  </p>
  <p>
   IDL Prints:
  </p>
  <p class="Code">
   blue, 255       0       0
  </p>
  <p class="Code">
   1
  </p>
  <p>
   Now remove the last element off the hash, printing the removed value:
  </p>
  <p class="Code">
   PRINT, hash.Remove()
  </p>
  <p>
   IDL Prints:
  </p>
  <p class="Code">
   255       0       0
  </p>
  <p>
   <a name="Hash::ToStruct">
   </a>
  </p>
  <h1 class="ObjMethod">
   <a name="Hash::To">
   </a>
   Hash::ToStruct
  </h1>
  <p>
   The Hash::ToStruct function method returns an IDL structure containing all of the hash elements converted into tag/value pairs. Keys which are not strings will not be included in the structure. For string keys, any special characters in the string will be converted to underscores to produce a valid IDL tag name. If a value is undefined (!NULL) it will also be skipped (unless the MISSING keyword is set).
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   Since the hash stores its key/value pairs in an arbitrary order, the order of tags within the resulting structure will also be arbitrary, even if the same structure was used to create the hash.
  </p>
  <h2 class="API">
   Syntax
  </h2>
  <p class="Syntax" style="font-style: normal;">
   <i>
    Result
   </i>
   = hash.ToStruct(&#160;[, MISSING=
   <i>
    value
   </i>
   ] [, /NO_COPY] [, /RECURSIVE] [, SKIPPED=
   <i>
    variable
   </i>
   ] )
  </p>
  <h2 class="API">
   Return Value
  </h2>
  <p>
   The result is an IDL structure containing the key/value pairs. If the hash is empty or contains no valid keys then !NULL&#160;is returned.
  </p>
  <h2 class="API">
   Arguments
  </h2>
  <p>
   None.
  </p>
  <h2 class="API">
   Keywords
  </h2>
  <h3 class="Keyword">
   MISSING
  </h3>
  <p>
   Set this keyword to the value to be returned for missing (!NULL) values. The default behavior of the Hash::ToStruct method is to skip any keys whose value is !NULL.
  </p>
  <h3 class="Keyword">
   NO_COPY
  </h3>
  <p>
   Set this keyword to move each element from the hash to the output structure. When finished, the hash will be empty.
  </p>
  <h3 class="Keyword">
   RECURSIVE
  </h3>
  <p>
   If this keyword is set, then any HASH values within the structure are also converted into structures using the ToStruct() method. The MISSING, NO_COPY, and RECURSIVE keywords are passed on to the recursive ToStruct() calls.
  </p>
  <h3 class="Keyword">
   SKIPPED
  </h3>
  <p>
   Set this keyword to a named variable in which to return a variable of type LIST containing all of the skipped keys. A key will be skipped (not included in the result structure) under the following circumstances:
  </p>
  <ul>
   <li value="1">
    The key is not a string;
   </li>
   <li value="2">
    The key is already present in the structure (this can happen because keys are case sensitive while structure tags are case insensitive);
   </li>
   <li value="3">
    The value associated with a key is !NULL (unless the MISSING keyword is set).
   </li>
  </ul>
  <h2 class="API">
   Examples
  </h2>
  <p class="Code">
   hash = HASH('black', 0, 'gray', 128, 'grey', 128, 'white', 255, 'light red', 200)
  </p>
  <p class="Code">
   HELP, hash.ToStruct()
  </p>
  <p class="Code">
   &#160;
  </p>
  <p>
   IDL Prints:
  </p>
  <p class="Code">
   ** Structure &lt;332a8ca8&gt;, 5 tags, length=10, data length=10, refs=1:
  </p>
  <p class="Code">
   LIGHT_RED       INT            200
  </p>
  <p class="Code">
   WHITE &#160;&#160;&#160;&#160;          INT            255
  </p>
  <p class="Code">
   BLACK&#160;&#160;&#160;&#160;&#160;         INT              0
  </p>
  <p class="Code">
   GRAY&#160;&#160;&#160;&#160;&#160;&#160;           INT            128
  </p>
  <p class="Code">
   GREY&#160;&#160;&#160;&#160;&#160;&#160;           INT            128
  </p>
  <p class="Code">
   &#160;
  </p>
  <p>
   An example using the RECURSIVE keyword:
  </p>
  <p class="Code">
   struct = {FIELD1: 4.0, FIELD2: {SUBFIELD1: "hello", SUBFIELD2: 3.14}}
  </p>
  <p class="Code">
   hash = HASH(struct, /EXTRACT)
  </p>
  <p class="Code">
   PRINT, hash
  </p>
  <p class="Code">
   PRINT, hash['FIELD2']
  </p>
  <p>
   IDL Prints:
  </p>
  <p class="Code">
   FIELD2: &lt;ObjHeapVar3374(HASH)&gt;
  </p>
  <p class="Code">
   FIELD1:       4.00000
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   SUBFIELD1: hello
  </p>
  <p class="Code">
   SUBFIELD2:       3.14000
  </p>
  <h1 class="ObjMethod">
   <a name="Hash::Values">
   </a>
   Hash::Values
  </h1>
  <p>
   The Hash::Values function method returns a list containing all values in a hash.The order of key/value pairs within hash.Keys() and hash.Values() is guaranteed to remain the same as long as no items are added or removed from the hash.
  </p>
  <h2 class="API">
   Syntax
  </h2>
  <p class="Syntax" style="font-style: normal;">
   <i>
    Result
   </i>
   = hash.Values( )
  </p>
  <h2 class="API">
   Return Value
  </h2>
  <p>
   Returns a list containing all of the values. If the hash is empty then an empty list is returned.
  </p>
  <h2 class="API">
   Arguments
  </h2>
  <p>
   None.
  </p>
  <h2 class="API">
   Keywords
  </h2>
  <p>
   None.
  </p>
  <h2 class="API">
   Examples
  </h2>
  <p class="Code">
   hash = HASH('black', 0, 'gray', 128, 'grey', 128, 'white', 255)
  </p>
  <p class="Code">
   list = hash.Values()
  </p>
  <p class="Code">
   print, list
  </p>
  <p>
   IDL Prints:
  </p>
  <p class="Code">
   255
  </p>
  <p class="Code">
   0
  </p>
  <p class="Code">
   128
  </p>
  <p class="Code">
   128
  </p>
  <h1 class="ObjMethod">
   <a name="Hash::Where">
   </a>
   Hash::Where
  </h1>
  <p>
   The Hash::Where function method returns a list of all keys that contain a certain value.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   This method returns a result that is equivalent to using the
   <a href="#hashes_3331144781_1000441" target="" title="" alt="" class="MCXref_0">
    EQ
   </a>
   operator, but also provides additional keywords that are not available with the operator.
  </p>
  <h2 class="API">
   Syntax
  </h2>
  <p class="Syntax">
   <i>
    Result
   </i>
   = hash.Where(
   <i>
    Value
   </i>
   [,
   <a href="#COMPLEME" target="" title="" alt="" class="MCXref_0">
    COMPLEMENT
   </a>
   =
   <i>
    variable
   </i>
   ] [,
   <a href="#COUNT" target="" title="" alt="" class="MCXref_0">
    COUNT
   </a>
   =
   <i>
    variable
   </i>
   ] [,
   <a href="#NCOMPLEM" target="" title="" alt="" class="MCXref_0">
    NCOMPLEMENT
   </a>
   =
   <i>
    variable
   </i>
   ] )
  </p>
  <h2 class="API">
   Return Value
  </h2>
  <p>
   Returns a list containing all of the keys that contain the value. If there are no matches, an empty list is returned. The following rules are used when comparing values:
  </p>
  <ul>
   <li value="1">
    If
    <i>
     Value
    </i>
    is a scalar number or string, the corresponding hash element must be equal to the same value (although the types may differ).
   </li>
   <li value="2">
    If
    <i>
     Value
    </i>
    is an array, the corresponding hash element must be an array of the same length, with identical values (although the types may differ).
   </li>
   <li value="3">
    If
    <i>
     Value
    </i>
    is a pointer or object, the corresponding hash element must be the same pointer or object reference.
   </li>
   <li value="4">
    If
    <i>
     Value
    </i>
    is a structure, it is compared to the corresponding hash element on a tag-by-tag basis (including nested structures) using the same rules as above.
   </li>
   <li value="5">
    If
    <i>
     Value
    </i>
    is another hash, the two hashes are compared on a key-by-key basis (using the above rules), and the result is a list containing the hash keys which exist in both hashes and have the same value.
   </li>
  </ul>
  <h2 class="API">
   Arguments
  </h2>
  <h3 class="Argument">
   Value
  </h3>
  <p>
   A variable or expression of any IDL data type, including !NULL.
  </p>
  <h2 class="API">
   Keywords
  </h2>
  <h3 class="Keyword">
   <a name="COMPLEME">
   </a>
   COMPLEMENT
  </h3>
  <p>
   Set this keyword to a named variable that will return a list of keys that do not contain the value.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   If
   <i>
    Value
   </i>
   is another hash, the COMPLEMENT is a list containing all of the keys in both hashes that either do not exist in the other hash, or have a different value. In this case the number of keys in the COMPLEMENT may be greater than the number of keys in either original hash.
  </p>
  <h3 class="Keyword">
   <a name="COUNT">
   </a>
   COUNT
  </h3>
  <p>
   Set this keyword to a named variable that will return the number of matches.
  </p>
  <h3 class="Keyword">
   <a name="NCOMPLEM">
   </a>
   NCOMPLEMENT
  </h3>
  <p>
   Set this keyword to a named variable that will return the number of keys within the COMPLEMENT list.
  </p>
  <h2 class="API">
   Examples
  </h2>
  <p>
   The following example generates a random integer and an array of ten random integers (both between 0 and 9). The sample uses Hash::Where to determine if there are any matches of the value in the hash (the hash keys are the array indices).
  </p>
  <p class="Code">
   keys = 'key' + STRTRIM(SINDGEN(10),2)
  </p>
  <p class="Code">
   rndmVal = FIX(10 * RANDOMU(seed, 1))
  </p>
  <p class="Code">
   rndmArr = FIX(10 * RANDOMU(seed, 10))
  </p>
  <p class="Code">
   h = HASH(keys, rndmArr)
  </p>
  <p class="Code">
   matches = h.Where(rndmVal)
  </p>
  <p class="Code">
   PRINT, 'Random value = ', rndmVal
  </p>
  <p class="Code">
   PRINT, 'Random array = ', rndmArr
  </p>
  <p class="Code">
   HELP, matches
  </p>
  <p class="Code">
   PRINT, 'Matching keys: ', matches, FORMAT=('(A)')
  </p>
  <p>
   Sample output:
  </p>
  <p class="Code">
   Random value =        8
  </p>
  <p class="Code">
   Random array =        2       7       8       8       0       4       8       3       7       1
  </p>
  <p class="Code">
   Matching keys:
  </p>
  <p class="Code">
   key3
  </p>
  <p class="Code">
   key2
  </p>
  <p class="Code">
   key6
  </p>
  <h1>
   Concatenating Hashes
  </h1>
  <p>
   To combine two hashes to make a new hash, use the + operator:
  </p>
  <p class="Code">
   hash1 = HASH('key1', 1, 'key2', 2, 'keydup', 'abc')
  </p>
  <p class="Code">
   hash2 = HASH('key3', 'three', 'key4', 4.0, 'keydup', 'xyz')
  </p>
  <p class="Code">
   hash3 = hash1 + hash2
  </p>
  <p class="Code">
   PRINT, hash3
  </p>
  <p>
   IDL Prints:
  </p>
  <p class="Code">
   keydup, xyz
  </p>
  <p class="Code">
   key2, 2
  </p>
  <p class="Code">
   key1, 1
  </p>
  <p class="Code">
   key4, 4.00000
  </p>
  <p class="Code">
   key3, three
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   If the two hashes have duplicate keys, the values will be taken from the second operand.
  </p>
  <p>
   The + operator may also be used to combine a hash and an IDL structure to make a new hash:
  </p>
  <p class="Code">
   hash1 = HASH('key1', 1, 'key2', 2, 'keydup', 'abc')
  </p>
  <p class="Code">
   struct = {tag1: 'mytagvalue', tag2: 2.0}
  </p>
  <p class="Code">
   hash3 = hash1 + struct
  </p>
  <p class="Code">
   PRINT, hash3
  </p>
  <p>
   IDL Prints:
  </p>
  <p class="Code">
   keydup: abc
  </p>
  <p class="Code">
   key2:        2
  </p>
  <p class="Code">
   key1:        1
  </p>
  <p class="Code">
   TAG2:       2.00000
  </p>
  <p class="Code">
   TAG1: mytagvalue
  </p>
  <h1>
   Comparing Hashes
  </h1>
  <h2 class="API">
   <a name="hashes_3331144781_1000441">
   </a>
   <a name="hashes_3331144781_22828">
   </a>
   EQ
  </h2>
  <p>
   The EQ operator does a comparison of two hashes, or a hash and a value. For the case of two hashes, EQ returns a list of keys that exist in both hashes and have the same value. For the case of a hash and a value, EQ returns a list of keys that contain that value. In either case, if there are no matches, an empty list is returned.
  </p>
  <p>
   For example, to compare two hashes:
  </p>
  <p class="Code">
   hash1 = HASH('key1', 1, 'key2', 2, 'key3', 3, 'anotherkey', 3.14)
  </p>
  <p class="Code">
   hash2 = HASH('key1', 1, 'key2', 2, 'key3', 3.5)
  </p>
  <p class="Code">
   result = hash1 EQ hash2
  </p>
  <p class="Code">
   HELP, result
  </p>
  <p class="Code">
   PRINT, result
  </p>
  <p>
   IDL Prints:
  </p>
  <p class="Code">
   RESULT          LIST  &lt;ID=114775  NELEMENTS=2&gt;
  </p>
  <p class="Code">
   key2
  </p>
  <p class="Code">
   key1
  </p>
  <p>
   To compare a hash and a value:
  </p>
  <p class="Code">
   hash = HASH('key1', 1.414, 'key2', 3.14, 'key3', 1.414)
  </p>
  <p class="Code">
   result = hash EQ 1.414&#160;&#160;&#160;&#160;; (or 1.414 EQ hash)
  </p>
  <p class="Code">
   HELP, result
  </p>
  <p class="Code">
   PRINT, result
  </p>
  <p>
   IDL Prints:
  </p>
  <p class="Code">
   RESULT          LIST  &lt;ID=114789  NELEMENTS=2&gt;
  </p>
  <p class="Code">
   key1
  </p>
  <p class="Code">
   key3
  </p>
  <p>
   To compare a hash and a value that is not in the hash:
  </p>
  <p class="Code">
   hash = HASH('key1', 1.414, 'key2', 3.14, 'key3', 1.414)
  </p>
  <p class="Code">
   result = hash EQ 2.718&#160;&#160;&#160;&#160;; (or 2.718 EQ hash)
  </p>
  <p class="Code">
   HELP, result
  </p>
  <p>
   IDL Prints:
  </p>
  <p class="Code">
   RESULT          LIST  &lt;ID=114817  NELEMENTS=0&gt;
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   See the
   <a href="#Hash::Where" target="" title="" alt="" class="MCXref_0">
    Hash::Where
   </a>
   method for the rules that are used for comparing values.
  </p>
  <h2 class="API">
   <a name="hashes_3331144781_1000441">
   </a>
   <a name="hashes_3331144781_22828">
   </a>
   NE
  </h2>
  <p>
   The NE operator behaves in the opposite manner of EQ. For NE with two hashes, the result is a list containing all of the keys in both hashes that either do not exist in the other hash, or have a different value. For NE with a hash and a value, the result is a list containing all of the keys that do not contain that value. In either case, if every element is a match, then an empty list is returned.
  </p>
  <p>
   For example, to compare two hashes:
  </p>
  <p class="Code">
   hash1 = HASH('key1', 1, 'key2', 2, 'key3', 3, 'anotherkey', 3.14)
  </p>
  <p class="Code">
   hash2 = HASH('key1', 1, 'key2', 2, 'key3', 3.5)
  </p>
  <p class="Code">
   result = hash1 NE hash2
  </p>
  <p class="Code">
   HELP, result
  </p>
  <p class="Code">
   PRINT, result
  </p>
  <p>
   IDL Prints:
  </p>
  <p class="Code">
   RESULT          LIST  &lt;ID=114843  NELEMENTS=2&gt;
  </p>
  <p class="Code">
   anotherkey
  </p>
  <p class="Code">
   key3
  </p>
  <p>
   To compare a hash and a value:
  </p>
  <p class="Code">
   hash = HASH('key1', 1.414, 'key2', 3.14, 'key3', 1.414)
  </p>
  <p class="Code">
   result = hash NE 1.414&#160;&#160;&#160;&#160;; (or 1.414 NE hash)
  </p>
  <p class="Code">
   HELP, result
  </p>
  <p class="Code">
   PRINT, result
  </p>
  <p>
   IDL Prints:
  </p>
  <p class="Code">
   RESULT          LIST  &lt;ID=114857  NELEMENTS=1&gt;
  </p>
  <p class="Code">
   key2
  </p>
  <p>
   To compare a hash and a !NULL value:
  </p>
  <p class="Code">
   hash = HASH('key1', 1.414, 'key2', 3.14, 'key3', !NULL, 'key4', !NULL)
  </p>
  <p class="Code">
   result = hash NE !NULL&#160;&#160;&#160;&#160;; (or !NULL NE hash)
  </p>
  <p class="Code">
   HELP, result
  </p>
  <p class="Code">
   PRINT, result
  </p>
  <p>
   IDL Prints:
  </p>
  <p class="Code">
   RESULT          LIST  &lt;ID=114817  NELEMENTS=2&gt;
  </p>
  <p class="Code">
   key2
  </p>
  <p class="Code">
   key1
  </p>
  <h1>
   Hash Access
  </h1>
  <p>
   In many cases, you can access elements of a hash variable using standard IDL array syntax, as if the hash were a one-dimensional array.
  </p>
  <h2 class="API">
   <a name="hashes_3331144781_998687">
   </a>
   <a name="hashes_3331144781_98034">
   </a>
   Retrieve a Single Element
  </h2>
  <p>
   To copy the value of a single hash element into a new variable, leaving the hash unchanged, use array syntax:
  </p>
  <p class="Code">
   value = hash[
   <i>
    Key
   </i>
   ]
  </p>
  <p>
   where
   <i>
    Key
   </i>
   is the scalar key of the desired element within the hash.
  </p>
  <p>
   To retrieve an arbitrary element in a hash and remove it, use the hash.Remove() method:
  </p>
  <p class="Code">
   value = hash.Remove()
  </p>
  <p>
   To retrieve a specific element in a hash and remove it:
  </p>
  <p class="Code">
   value = hash.Remove(
   <i>
    Key
   </i>
   )
  </p>
  <p>
   where
   <i>
    Key
   </i>
   is the scalar key of the desired element within the hash.
  </p>
  <h2 class="API">
   <a name="hashes_3331144781_998773">
   </a>
   <a name="hashes_3331144781_96774">
   </a>
   Insert a Single Element
  </h2>
  <p>
   To insert a single value into a hash, creating a new hash element, use array syntax:
  </p>
  <p class="Code">
   hash[
   <i>
    Key
   </i>
   ] =
   <i>
    Value
   </i>
  </p>
  <p>
   where
   <i>
    Value
   </i>
   is the value to be stored in the new hash element.
  </p>
  <h2 class="API">
   <a name="hashes_3331144781_998838">
   </a>
   <a name="hashes_3331144781_55536">
   </a>
   Change the Value of a Single Element
  </h2>
  <p>
   To change the value of a single hash element, use array syntax:
  </p>
  <p class="Code">
   hash[
   <i>
    Key
   </i>
   ] =
   <i>
    Value
   </i>
  </p>
  <p>
   where
   <i>
    Key
   </i>
   is the scalar key of the desired element within the hash and
   <i>
    Value
   </i>
   is the new value.
  </p>
  <h2 class="API">
   <a name="hashes_3331144781_998763">
   </a>
   <a name="hashes_3331144781_22904">
   </a>
   Create a Sub-hash
  </h2>
  <p>
   To create a new hash that is a subset of an existing hash, use array syntax:
  </p>
  <p class="Code">
   newHash = origHash[ [
   <i>
    Key
   </i>
   <sub>
    1
   </sub>
   , ...,
   <i>
    Key
   </i>
   <sub>
    n
   </sub>
   ] ]
  </p>
  <p>
   or
  </p>
  <p class="Code">
   newHash = origHash[
   <i>
    Keys
   </i>
   ]
  </p>
  <p>
   where
   <span class="Courier" style="font-style: italic;">
    Key
   </span>
   <sub style="font-family: Times;line-height: 13pt;">
    1
   </sub>
   <span class="Courier">
    ,
   </span>
   <span class="Courier">
    ...,
    <i>
     Key
    </i>
   </span>
   <sub style="font-family: Times;line-height: 13pt;">
    n
   </sub>
   are individual keys concatenated into an array, and
   <span class="Courier-Italic">
    Keys
   </span>
   is an array or list of keys. Here
   <span class="Courier">
    newHash
   </span>
   is a new hash variable that contains copies of the key-value pairs from
   <span class="Courier">
    origHash
   </span>
   specified by the keys.
  </p>
  <h2 class="API">
   <a name="hashes_3331144781_998841">
   </a>
   <a name="hashes_3331144781_80654">
   </a>
   Insert or Change the Value of Multiple Elements
  </h2>
  <p>
   Insert or change the value of multiple hash elements in a single operation by specifying an array or list of keys to be replaced and/or added in the existing hash and providing the replacement values in an array or list:
  </p>
  <p class="Code">
   hash[[
   <i>
    Key
   </i>
   <sub>
    1
   </sub>
   , ...,
   <i>
    Key
   </i>
   <sub>
    n
   </sub>
   ]] =
   <i>
    Values
   </i>
  </p>
  <p>
   or
  </p>
  <p class="Code">
   hash[
   <i>
    Keys
   </i>
   ] =
   <i>
    Values
   </i>
  </p>
  <p>
   where
   <span class="Courier" style="font-style: italic;">
    Key
   </span>
   <sub style="font-family: Times;line-height: 13pt;">
    1
   </sub>
   <span class="Courier">
    ,
   </span>
   <span class="Courier">
    ...,
    <i>
     Key
    </i>
   </span>
   <sub style="font-family: Times;line-height: 13pt;">
    n
   </sub>
   are individual keys concatenated into an array,
   <span class="Courier-Italic">
    Keys
   </span>
   is an array or list of keys, and
   <span class="Courier-Italic">
    Values
   </span>
   is a scalar, an array or a list of values. If
   <span class="Courier-Italic">
    Values
   </span>
   is a scalar, then that value is copied into every key. Otherwise, if
   <span class="Courier-Italic">
    Values
   </span>
   is an array or a list, it must contain the same number of elements as the keys. In this case each element of
   <span class="Courier-Italic">
    Keys
   </span>
   and
   <span class="Courier-Italic">
    Values
   </span>
   is inserted as a separate key-value pair. For each key-value pair, if the key already exists in the hash then the value is replaced, and if the key does not exist then it is added. If a given key occurs more than once within the new keys, the last value will be retained.
  </p>
  <h2 class="API">
   <a name="hashes_3331144781_998769">
   </a>
   <a name="hashes_3331144781_40875">
   </a>
   Copy a Hash
  </h2>
  <p>
   To copy a hash reference, simply assign it to a new variable:
  </p>
  <p class="Code">
   newHash = origHash
  </p>
  <p>
   It is important to understand that with this operation,
   <span class="Courier">
    newHash
   </span>
   and
   <span class="Courier">
    origHash
   </span>
   are references to the same hash; modifying an element in one hash modifies the same element in the other hash. For example, if we create
   <span class="Courier">
    hash2
   </span>
   as a copy of
   <span class="Courier">
    hash1
   </span>
   and then change the value of an element in
   <span class="Courier">
    hash2
   </span>
   , the same element in
   <span class="Courier">
    hash1
   </span>
   also changes:
  </p>
  <p class="Code">
   hash1 = HASH('key1', 1, 'key2', 2)
  </p>
  <p class="Code">
   hash2 = hash1
  </p>
  <p class="Code">
   hash2['key1'] = 'hello'
  </p>
  <p class="Code">
   HELP, hash1['key1'], hash2['key2']
  </p>
  <p>
   IDL Prints:
  </p>
  <p class="Code">
   &lt;Expression&gt;    STRING    = 'hello'
  </p>
  <p class="Code">
   &lt;Expression&gt;    STRING    = 'hello'
  </p>
  <p>
   Note that both hashes contain the new value for that key.
  </p>
  <p>
   To create a new hash variable whose elements are copies of the values in the original hash, you could use the following:
  </p>
  <p class="Code">
   newHash = HASH(origHash.Keys(), origHash.Values())
  </p>
  <p>
   Another method to copy a hash is to use array syntax to copy all of the elements:
  </p>
  <p class="Code">
   newHash = origHash[*]
  </p>
  <p>
   This is equivalent to using
   <span class="Courier">
    HASH(origHash.Keys(), origHash.Values())
   </span>
   and is provided as a programming shortcut.
  </p>
  <p>
   For example:
  </p>
  <p class="Code">
   hash1 = HASH('key1', 1, 'key2', 2)
  </p>
  <p class="Code">
   hash2 = hash1[*]
  </p>
  <p class="Code">
   hash2['key1'] = 'hello'
  </p>
  <p class="Code">
   HELP, hash1['key1'], hash2['key2']
  </p>
  <p>
   IDL Prints:
  </p>
  <p class="Code">
   &lt;Expression&gt;    STRING    = 1
  </p>
  <p class="Code">
   &lt;Expression&gt;       STRING    = 'hello'
  </p>
  <p>
   Note that the value in
   <span class="Courier">
    hash1
   </span>
   remains unchanged.
  </p>
  <h2 class="API">
   <a name="hashes_3331144781_998822">
   </a>
   <a name="hashes_3331144781_53967">
   </a>
   Iterate Through a Hash
  </h2>
  <p>
   To iterate through the elements in a hash, loop over the keys and use standard array syntax:
  </p>
  <p class="Code">
   hash = HASH('Mercury', 1, 'Venus', 2, 'Earth', 3, 'Mars', 4)
  </p>
  <p class="Code">
   keys = hash.Keys()
  </p>
  <p class="Code">
   FOR i=0,N_ELEMENTS(hash)-1 DO PRINT, hash[keys[i]]
  </p>
  <p>
   A more efficient method of iteration is to use FOREACH:
  </p>
  <p class="Code">
   hash = HASH('Mercury', 1, 'Venus', 2, 'Earth', 3, 'Mars', 4)
  </p>
  <p class="Code">
   FOREACH value, hash DO     &#160;&#160;&#160;&#160;&#160;&#160;&#160;PRINT, 'Value = ', value
  </p>
  <p>
   You may also use the optional argument to FOREACH to retrieve the key associated with each value:
  </p>
  <p class="Code">
   hash = HASH('Mercury', 1, 'Venus', 2, 'Earth', 3, 'Mars', 4)
  </p>
  <p class="Code">
   FOREACH value, hash, key DO PRINT, key + ' is planet #', value
  </p>
  <h2 class="API">
   Access and Change Array Elements within a Hash
  </h2>
  <p>
   If a hash item contains an array, another hash, or a list, individual elements within that item may be accessed and modified using standard array syntax. In this case, the first dimension must be a hash key (a scalar string or number) that specifies the hash element, and the higher dimensions are used to index into the array itself. The higher dimensions may be any combination of scalars, subscript ranges, or index arrays. The syntax looks like:
  </p>
  <p class="Code">
   values = hash[key, sub0, sub1,...]
  </p>
  <p class="Code">
   hash[key, sub0, sub1,...] = values
  </p>
  <p>
   where
   <i>
    key
   </i>
   is a scalar string or number that specifies the hash element, and
   <i>
    sub0
   </i>
   ,
   <i>
    sub1
   </i>
   ,... are the subscript ranges or indices for the contained array.
  </p>
  <p>
   For example, to create a "ragged" array, where each element is a vector of a different length:
  </p>
  <p class="Code">
   hash = HASH( 'Array1', FINDGEN(100), 'Array2', FINDGEN(67), 'Array3', FINDGEN(93), $
  </p>
  <p class="Code">
   'Array4', FINDGEN(120) )
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Print the 6th element of the first vector
  </p>
  <p class="Code">
   PRINT, hash['Array1', 5]
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Print every other element of the third vector
  </p>
  <p class="Code">
   PRINT, hash['Array3', 0:*:2]
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Change several elements of the fourth vector
  </p>
  <p class="Code">
   HASH['Array4', [5,10,15,20]] = -1
  </p>
  <p>
   In this example, we create a hash that contains a one-dimensional array, a string, and a two-dimensional array:
  </p>
  <p class="Code">
   hash = HASH( 'Data', FINDGEN(10), 'Date', 'April 1, 2001', 'Hanning', HANNING(100, 50) )
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Modify an element in the center of the 2D array
  </p>
  <p class="Code">
   hash['Hanning', 50, 25] = 0.0
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Change an entire column of the 2D array
  </p>
  <p class="Code">
   hash['Hanning', 99, *] = -1.0
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Extract a subset of the 2D array
  </p>
  <p class="Code">
   HELP, hash['Hanning', 10:15, 7:11]
  </p>
  <p>
   IDL prints:
  </p>
  <p class="Code">
   &lt;Expression&gt;    FLOAT     = Array[6, 5]
  </p>
  <p>
   In this example, we create a hash that contains a one-dimensional array, a string, a list, (which contains a two-dimensional array), and another  hash:
  </p>
  <p class="Code">
   hash = HASH('Data', FINDGEN(10), 'Date', 'April 2', $
  </p>
  <p class="Code">
   &#160;&#160;'List', LIST('MyData', DIST(20, 30)), $
  </p>
  <p class="Code">
   &#160;&#160;'Properties', HASH('LINESTYLE', 3, 'THICK', 2) )
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Extract the entire 2D array from the sub-list
  </p>
  <p class="Code">
   HELP, hash['List', 1]
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Extract a subset of the 2D array within the sub-list
  </p>
  <p class="Code">
   HELP, hash['List', 1, 10:15, [20,21,22] ]
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Add a new key-value to the hash within the hash
  </p>
  <p class="Code">
   hash['Properties', 'COLOR'] = 'blue'
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Extract a value from the hash within the hash
  </p>
  <p class="Code">
   HELP, HASH['Properties', 'COLOR' ]
  </p>
  <p>
   IDL prints:
  </p>
  <p class="Code">
   &lt;Expression&gt;    FLOAT     = Array[20, 30]
  </p>
  <p class="Code">
   &lt;Expression&gt;    FLOAT     = Array[6, 3]
  </p>
  <p class="Code">
   &lt;Expression&gt;    STRING    = 'blue'
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   When indexing into an array contained within a hash, the first dimension must always be the hash key. Since IDL can only handle a maximum of eight dimensions, you can only use up to seven dimensions when indexing into an array within a hash. If the array is contained within a hash or list (which is itself contained within a hash), the maximum number of dimensions will be six, and so on.
  </p>
  <h1>
   Information about Hashes
  </h1>
  <h2 class="API">
   Logical Truth
  </h2>
  <p>
   The logical truth operator evaluates a hash. It returns a value of 1 (TRUE) if the hash is non-empty, and returns 0 (FALSE) if the hash is empty.
  </p>
  <p class="Code">
   IF (hash) THEN . . .
  </p>
  <h2 class="API">
   <a name="hashes_3331144781_1000539">
   </a>
   <a name="hashes_3331144781_38436">
   </a>
   Logical Negation
  </h2>
  <p>
   The logical negation operator negates the logical value of a hash:
  </p>
  <p class="Code">
   IF (~hash) THEN . . .
  </p>
  <p>
   If
   <i>
    hash
   </i>
   is TRUE, the statement evaluates as FALSE, and so on.
  </p>
  <h2 class="API">
   N_ELEMENTS
  </h2>
  <p>
   The N_ELEMENTS function returns the number of elements in a hash:
  </p>
  <p class="Code">
   Result = N_ELEMENTS(hash)
  </p>
  <p>
   If
   <span class="Courier">
    hash
   </span>
   contains zero elements, or if
   <span class="Courier">
    hash
   </span>
   is an undefined variable, 0 is returned.
  </p>
  <p>
   For more information, see
   <a class="MCXref_Heading_0" href="../N/N_ELEMENTS.html#N_830853741_953695" target="" title="" alt="">
    N_ELEMENTS
   </a>
   .
  </p>
  <h2 class="API">
   ISA
  </h2>
  <p>
   The ISA function can determine whether the given variable is a hash:
  </p>
  <p class="Code">
   x = HASH('key1', 1, 'key2', 2)
   <br />
   PRINT, ISA(x, 'HASH')
  </p>
  <p>
   IDL prints:
  </p>
  <p class="Code">
   1
  </p>
  <p>
   For more information, see
   <a class="MCXref_Heading_0" href="../I/ISA.html#I_833016429_1127569" target="" title="" alt="">
    ISA
   </a>
   .
  </p>
  <h2 class="API">
   TYPENAME
  </h2>
  <p>
   The TYPENAME function returns the type HASH for a hash variable:
  </p>
  <p class="Code">
   x = HASH('key1', 1, 'key2', 2)
   <br />
   PRINT, TYPENAME(x)
  </p>
  <p>
   IDL prints:
  </p>
  <p class="Code">
   HASH
  </p>
  <p>
   For more information, see
   <a class="MCXref_Heading_0" href="../T/TYPENAME.html#T_809226861_1160964" target="" title="" alt="">
    TYPENAME
   </a>
   .
  </p>
  <h2 class="API">
   HELP
  </h2>
  <p>
   The HELP procedure provides general information about a hash variable:
  </p>
  <p class="Code">
   newHash = HASH('key1', 1, 'key2', [1,2,3])
   <br />
   HELP, newHash
  </p>
  <p>
   IDL prints:
  </p>
  <p class="Code">
   NEWHASH         HASH  &lt;ID=1 NELEMENTS=2&gt;
  </p>
  <p>
   In this case, the variable name is NEWHASH. the type name is HASH, the heap ID is 1, and there are two elements in the hash.
  </p>
  <h2 class="API">
   PRINT
  </h2>
  <p>
   The PRINT procedure gives the value for each hash element:
  </p>
  <p class="Code">
   newHash = HASH('Mercury', 1, 'Venus', 2, 'Earth', 3, 'Mars', 4)
   <br />
   PRINT, newHash
  </p>
  <p>
   IDL prints:
  </p>
  <p class="Code">
   Earth, 3
  </p>
  <p class="Code">
   Mars, 4
  </p>
  <p class="Code">
   Venus, 2
  </p>
  <p class="Code">
   Mercury, 1
  </p>
  <h2 class="API">
   <a name="L_826528365_1077856">
   </a>
   <a name="L_826528365_1077856_PageTOC_HASH_">
   </a>
   Version History
  </h2>
  <table style="width: 499px;caption-side: top;mc-table-style: url('../../Resources/TableStyles/VersionTable.css');" cellspacing="0" class="TableStyle_VersionTable">
   <col width="91px" />
   <col width="408px" />
   <tbody>
    <tr>
     <td class="TableStyle_VersionTable_Body_0_0_ColSep">
      <p>
       8.0
      </p>
     </td>
     <td class="TableStyle_VersionTable_Body_0_0_ColEnd">
      <p>
       Introduced
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_VersionTable_Body_0_0_RowSep_ColSep">
      <p>
       8.1
      </p>
     </td>
     <td class="TableStyle_VersionTable_Body_0_0_RowSep_ColEnd">
      <p>
       Added NO_COPY keyword to ToStruct function method
      </p>
      <p>
       Added Count, FindValue, IsEmpty methods
      </p>
      <p>
       Added ability to index into arrays within a hash
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_VersionTable_Body_0_0_RowEnd_ColSep">
      8.2
     </td>
     <td class="TableStyle_VersionTable_Body_0_0_RowEnd_ColEnd">
      Added the Where method, deprecated the FindValue method
     </td>
    </tr>
   </tbody>
  </table>
  <h2 class="API">
   <a name="L_826528365_1077863">
   </a>
   <a name="L_826528365_1077863_PageTOC_HASH_">
   </a>
   See Also
  </h2>
  <p>
   <a class="MCXref_Heading_0" href="../L/LIST.html#L_826528365_1077832" target="" title="" alt="">
    LIST
   </a>
  </p>
  <div class="mp_footer">
   Copyright ©
   <span class="DocumentTitleCopyrightYear">
    2012
   </span>
   <![CDATA[ ]]>
   <span class="DocumentTitleCopyrightCompanyName">
    Exelis Visual Information Solutions, Inc.
   </span>
   All Rights Reserved.
  </div>
  <script type="text/javascript" src="../../SkinSupport/MadCapBodyEnd.js">
  </script>
 </body>
</html>