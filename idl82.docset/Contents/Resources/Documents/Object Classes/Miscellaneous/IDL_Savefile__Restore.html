<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns:madcap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" madcap:lastblockdepth="2" madcap:lastheight="135.6667" madcap:lastwidth="592" madcap:disablemasterstylesheet="true" madcap:tocpath="IDL Programming|Objects|Miscellaneous Object Classes|IDL_Savefile" madcap:medium="non-print" madcap:inpreviewmode="false" madcap:preloadimages="false" madcap:runtimefiletype="Topic" madcap:targettype="WebHelp" lang="en-US" xml:lang="en-US" madcap:pathtohelpsystem="../../../" madcap:helpsystemfilename="idl.xml" madcap:searchtype="Stem">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>
   IDL_Savefile::Restore
  </title>
  <link href="../../SkinSupport/MadCap.css" rel="stylesheet" />
  <link href="../../Resources/TableStyles/VersionTable.css" rel="stylesheet" />
  <link href="../../Resources/Stylesheets/IDL_style.css" rel="stylesheet" />
  <script src="../../SkinSupport/MadCapAll.js" type="text/javascript">
  </script>
 </head>
 <body>
  <p class="MCWebHelpFramesetLink" style="display: none;">
   <a href="../../../idl_CSH.html#Object Classes/Miscellaneous/IDL_Savefile__Restore.html" style="">
    Open topic with navigation
   </a>
  </p>
  <div class="MCBreadcrumbsBox_0">
   <span class="MCBreadcrumbsPrefix">
    <![CDATA[ ]]>
   </span>
   <a class="MCBreadcrumbsLink" href="../../IDL Programming.html">
    IDL Programming
   </a>
   <span class="MCBreadcrumbsDivider">
    &gt;
   </span>
   <a class="MCBreadcrumbsLink" href="../ref_part2.html">
    Objects
   </a>
   <span class="MCBreadcrumbsDivider">
    &gt;
   </span>
   <a class="MCBreadcrumbsLink" href="objects_misc.html">
    Miscellaneous Object Classes
   </a>
   <span class="MCBreadcrumbsDivider">
    &gt;
   </span>
   <span class="MCBreadcrumbs">
    IDL_Savefile::Restore
   </span>
  </div>
  <h1 class="ObjMethod">
   <a name="objects_misc_904195448_1034827">
   </a>
   <a name="objects_misc_904195448_34238">
   </a>
   IDL_Savefile::Restore
  </h1>
  <p madcap:conditions="Reference Material.Online_Help_Only">
   <madcap:conditionaltext madcap:conditions="Reference Material.Online_Help_Only">
    <a class="MCXref_Heading_0" href="#objects_misc_904195448_1034839">
     Syntax
    </a>
    |
    <a class="MCXref_Heading_0" href="#objects_misc_904195448_1034868">
     Arguments
    </a>
    |
    <a class="MCXref_Heading_0" href="#objects_misc_904195448_1034875">
     Keywords
    </a>
    |
    <a class="MCXref_Heading_0" href="#objects_misc_904195448_1034916">
     Notes on Restored Heap Variables
    </a>
    |
    <a class="MCXref_Heading_0" href="#objects_misc_904195448_1034981">
     Example
    </a>
    |
    <a class="MCXref_Heading_0" href="#objects_misc_904195448_1034986">
     Version History
    </a>
   </madcap:conditionaltext>
  </p>
  <p>
   The IDL_Savefile::
   <a name="kanchor4705">
   </a>
   Restore procedure method selectively restores individual items from the associated SAVE file.
  </p>
  <p>
   Given the
   <i>
    identifier
   </i>
   for an item within the SAVE file, this method restores the item along with any additional items (such as structure definitions or heap variables) upon which the specified item depends. Use the
   <a class="MCXref_Heading_0" href="IDL_Savefile__Names.html#objects_misc_904195448_1034737">
    IDL_Savefile::Names
   </a>
   method to retrieve valid item identifiers.
  </p>
  <p>
   By default, this method restores variables from the SAVE file; keywords can be used to restore items of other types.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   There are several issues of which you should be aware when using this method to restore pointers or object references. See
   <a class="MCXref_Heading_0" href="#objects_misc_904195448_1034916">
    Notes on Restored Heap Variables
   </a>
   for details.
  </p>
  <h2 class="API">
   <a name="objects_misc_904195448_1034839">
   </a>
   <a name="objects_misc_904195448_1034839_PageTOC_IDL_Savefile">
   </a>
   Syntax
  </h2>
  <p class="Syntax">
   <i>
    Obj
   </i>
   -&gt;[
   <a class="MCXref_Heading_0" href="IDL_Savefile.html#objects_misc_904195448_1076956">
    IDL_Savefile
   </a>
   ::]Restore,
   <i>
    SaveItem
   </i>
   [,&#160;/
   <a class="MCXref_Heading_0" href="#objects_misc_904195448_1034877">
    COMMON
   </a>
   ] [,&#160;/
   <a class="MCXref_Heading_0" href="#objects_misc_904195448_1034881">
    FUNCTION
   </a>
   ] [,&#160;
   <a class="MCXref_Heading_0" href="#objects_misc_904195448_1034884">
    NEW_HEAPVAR
   </a>
   =
   <i>
    variable
   </i>
   ] [,&#160;/
   <a class="MCXref_Heading_0" href="#objects_misc_904195448_1098480">
    NO_COMPILE
   </a>
   ] [,&#160;/
   <a class="MCXref_Heading_0" href="#objects_misc_904195448_1034892">
    OBJECT_HEAPVAR
   </a>
   ] [,&#160;/
   <a class="MCXref_Heading_0" href="#objects_misc_904195448_1034898">
    POINTER_HEAPVAR
   </a>
   ] [,&#160;/
   <a class="MCXref_Heading_0" href="#objects_misc_904195448_1034904">
    PROCEDURE
   </a>
   ] [,&#160;
   <a class="MCXref_Heading_0" href="#objects_misc_904195448_1034907">
    RESTORED_OBJECTS
   </a>
   =
   <i>
    variable
   </i>
   ] [,&#160;/
   <a class="MCXref_Heading_0" href="#objects_misc_904195448_1034910">
    STRUCTURE_DEFINITION
   </a>
   ] [,&#160;/
   <a class="MCXref_Heading_0" href="#objects_misc_904195448_1034913">
    VERBOSE
   </a>
   ]
  </p>
  <h2 class="API">
   <a name="objects_misc_904195448_1034868">
   </a>
   <a name="objects_misc_904195448_1034868_PageTOC_IDL_Savefile">
   </a>
   Arguments
  </h2>
  <h3 class="Argument">
   SaveItem
  </h3>
  <p>
   A scalar string or string array of identifiers for items to be restored from the SAVE file. Identifiers are retrieved from the SAVE file using the
   <a class="MCXref_Heading_0" href="IDL_Savefile__Names.html#objects_misc_904195448_1034737">
    IDL_Savefile::Names
   </a>
   method.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   If either the OBJECT_HEAPVAR keyword or the POINTER_HEAPVAR keyword is specified,
   <i>
    SaveItem
   </i>
   must be an integer or integer array.
  </p>
  <h2 class="API">
   <a name="objects_misc_904195448_1034875">
   </a>
   <a name="objects_misc_904195448_1034875_PageTOC_IDL_Savefile">
   </a>
   Keywords
  </h2>
  <h3 class="Keyword">
   <a name="objects_misc_904195448_1034877">
   </a>
   <a name="objects_misc_904195448_1000035_Keywords_IDL_Savefile">
   </a>
   COMMON
  </h3>
  <p>
   Set this keyword to restore the main-level COMMON block definitions specified by
   <i>
    SaveItem
   </i>
   .
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   To restore both a COMMON block definition and the variables it references, restore the definition first, then restore the variables.
  </p>
  <h3 class="Keyword">
   <a name="objects_misc_904195448_1034881">
   </a>
   <a name="objects_misc_904195448_1000038_Keywords_IDL_Savefile">
   </a>
   FUNCTION
  </h3>
  <p>
   Set this keyword to restore the function(s) specified by
   <i>
    SaveItem
   </i>
   .
  </p>
  <h3 class="Keyword">
   <a name="objects_misc_904195448_1034884">
   </a>
   <a name="objects_misc_904195448_1000041_Keywords_IDL_Savefile">
   </a>
   NEW_HEAPVAR
  </h3>
  <p>
   Set this keyword equal to a named variable that will contain valid references for heap variables.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   This keyword is only valid when either the OBJECT_HEAPVAR or the POINTER_HEAPVAR keyword is specified.
  </p>
  <p>
   The returned variable will have the same structure as
   <i style="letter-spacing: -0.02em;">
    SaveItem
   </i>
   , with each element in the returned array corresponding to the same element in the
   <i>
    SaveItem
   </i>
   array. If OBJECT_HEAPVAR is specified, the returned variable will contain an array of object references; if POINTER_HEAPVAR is specified, the returned variable will contain an array of pointers. See
   <a class="MCXref_Heading_0" href="#objects_misc_904195448_1034916">
    Notes on Restored Heap Variables
   </a>
   for additional information on restoring heap variables.
  </p>
  <h3 class="Keyword">
   <a name="objects_misc_904195448_1098480">
   </a>
   <a name="objects_misc_904195448_88303">
   </a>
   NO_COMPILE
  </h3>
  <p>
   By default, when Restore encounters a structure variable or object reference, it automatically attempts to find a corresponding
   <span class="Courier">
    __define
   </span>
   file (a
   <span class="Courier">
    .pro
   </span>
   or
   <span class="Courier">
    .sav
   </span>
   file in IDL’s path that contains the corresponding structure or class definition). If IDL finds a
   <span class="Courier">
    __define
   </span>
   file, it compiles it automatically, before restoring the variable or object reference. Set the NO_COMPILE keyword to
   <i>
    disable
   </i>
   this automatic compilation behavior.
  </p>
  <p>
   Automatic compilation of structure definitions is useful for object class definitions if you have defined the object methods within the same
   <span class="Courier">
    .pro
   </span>
   or
   <span class="Courier">
    .sav
   </span>
   file — compiling the
   <span class="Courier">
    __define
   </span>
   file will also compile the class methods and make them available to the newly-restored variables.
  </p>
  <p>
   Automatic compilation is also useful if the structure or class definition has
   <i>
    changed
   </i>
   since the SAVE file was created. Compiling the
   <span class="Courier">
    __define
   </span>
   file will ensure that IDL caches the new structure definition first, before the variable is restored.
  </p>
  <p>
   This keyword is ignored for SAVE files that contain code.
  </p>
  <h3 class="Keyword">
   <a name="objects_misc_904195448_1034892">
   </a>
   <a name="objects_misc_904195448_1000044_Keywords_IDL_Savefile">
   </a>
   OBJECT_HEAPVAR
  </h3>
  <p>
   Set this keyword to restore the object heap variable(s) specified by
   <i>
    SaveItem
   </i>
   . To obtain valid references to the newly restored heap variables, you must also specify the NEW_HEAPVAR keyword. See
   <a class="MCXref_Heading_0" href="#objects_misc_904195448_1034916">
    Notes on Restored Heap Variables
   </a>
   for additional information on restoring heap variables.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   Only heap variables whose
   <i>
    save attribute
   </i>
   is set to True (the default) will are saved. See
   <a class="MCXref_Heading_0" href="../../Reference Material/H/HEAP_SAVE.html#H_835179117_924792">
    HEAP_SAVE
   </a>
   for additional details on save attributes.
  </p>
  <h3 class="Keyword">
   <a name="objects_misc_904195448_1034898">
   </a>
   <a name="objects_misc_904195448_1015827_Keywords_IDL_Savefile">
   </a>
   POINTER_HEAPVAR
  </h3>
  <p>
   Set this keyword to restore the pointer heap variable(s) specified by
   <i>
    SaveItem
   </i>
   . To obtain valid references to the newly restored heap variables, you must also specify the NEW_HEAPVAR keyword. See
   <a class="MCXref_Heading_0" href="#objects_misc_904195448_1034916">
    Notes on Restored Heap Variables
   </a>
   for additional information on restoring heap variables.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   Only heap variables whose
   <i>
    save attribute
   </i>
   is set to True (the default) will are saved. See
   <a class="MCXref_Heading_0" href="../../Reference Material/H/HEAP_SAVE.html#H_835179117_924792">
    HEAP_SAVE
   </a>
   for additional details on save attributes.
  </p>
  <h3 class="Keyword">
   <a name="objects_misc_904195448_1034904">
   </a>
   <a name="objects_misc_904195448_1015829_Keywords_IDL_Savefile">
   </a>
   PROCEDURE
  </h3>
  <p>
   Set this keyword to restore the procedure(s) specified by
   <i>
    SaveItem
   </i>
   .
  </p>
  <h3 class="Keyword">
   <a name="objects_misc_904195448_1034907">
   </a>
   <a name="objects_misc_904195448_1000053_Keywords_IDL_Savefile">
   </a>
   RESTORED_OBJECTS
  </h3>
  <p>
   Set this keyword equal to a named variable that will contain an array of object references for any objects restored. The resulting list of objects is useful for programmatically calling the objects’ own restore methods (if any). If no objects are restored, the variable will contain a null object reference.
  </p>
  <h3 class="Keyword">
   <a name="objects_misc_904195448_1034910">
   </a>
   <a name="objects_misc_904195448_1000056_Keywords_IDL_Savefile">
   </a>
   STRUCTURE_DEFINITION
  </h3>
  <p>
   Set this keyword to restore the named structure definition(s) specified by
   <i>
    SaveItem
   </i>
   . Named structure definitions are saved by IDL when a structure variable of that type is
   <span class="_Override" style="letter-spacing: -0.02em;">
    saved, and are restored when the variable is restored. The STRUCTURE_DEFINITION
   </span>
   keyword allows you to restore just the definition, without the variable. This can be useful if you simply wish to create a new variable of the same type, and have no use for the saved variable data.
  </p>
  <h3 class="Keyword">
   <a name="objects_misc_904195448_1034913">
   </a>
   <a name="objects_misc_904195448_1000059_Keywords_IDL_Savefile">
   </a>
   VERBOSE
  </h3>
  <p>
   Set this keyword to print an informative message for each item restored.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   Messages are only printed for top-level named variables. Heap variable references returned by the NEW_HEAPVAR keyword will not generate individual messages.
  </p>
  <h2 class="API">
   <a name="objects_misc_904195448_1034916">
   </a>
   <a name="objects_misc_904195448_1034916_PageTOC_IDL_Savefile">
   </a>
   <a name="objects_misc_904195448_94220">
   </a>
   Notes on Restored Heap Variables
  </h2>
  <p>
   IDL variables can contain object or pointer references to
   <i>
    heap variables
   </i>
   , and these heap variables can contain other such references, either to themselves or to other heap variables. There is no limit to the number of references that can be made to a given heap variable. This flexible design allows the construction of arbitrary data structures.
  </p>
  <p>
   While the RESTORE procedure handles all details related to restoring heap variables in a way that is transparent to the IDL user, the IDL_Savefile::Restore method provides greater flexibility and thus requires greater care. In particular, you should be aware of the following when using the IDL_Savefile::Restore method to restore heap variables:
  </p>
  <table class="AutoNumber_p_Numbered1" style="width: 100%; margin-left: 0;" cellspacing="0" cellpadding="0">
   <col style="width: 16px;" />
   <col style="width: 24px;" />
   <col style="width: auto;" />
   <tr>
    <td valign="top">
    </td>
    <td class="AutoNumber_p_Numbered1" valign="top">
     <span>
      1.
     </span>
    </td>
    <td class="AutoNumber_p_Numbered1" madcap:autonum="1. " valign="top">
     An IDL_Savefile object will restore a given heap variable only once. This has implications for situations in which heap variables might be freed during the IDL_Savefile object’s lifetime. See
     <a class="MCXref_Heading_0" href="#objects_misc_904195448_1034940">
      Caution Regarding Restored Heap Variables
     </a>
     for a complete discussion of this issue.
    </td>
   </tr>
  </table>
  <table class="AutoNumber_p_Numbered1" style="width: 100%; margin-left: 0;" cellspacing="0" cellpadding="0">
   <col style="width: 16px;" />
   <col style="width: 24px;" />
   <col style="width: auto;" />
   <tr>
    <td valign="top">
    </td>
    <td class="AutoNumber_p_Numbered1" valign="top">
     <span>
      2.
     </span>
    </td>
    <td class="AutoNumber_p_Numbered1" madcap:autonum="2. " valign="top">
     The IDL_Savefile object makes it possible to restore a heap variable independently of any regular IDL variable that might refer to it. This feature is described in detail in
     <a class="MCXref_Heading_0" href="#objects_misc_904195448_1034949">
      Restoring Heap Variables Directly
     </a>
     .
    </td>
   </tr>
  </table>
  <h3>
   Understanding How Heap Variables are Restored
  </h3>
  <p>
   When the SAVE procedure saves variables that contain object or pointer references, the referenced heap variables are also saved. Internally, heap variables are represented by unique integers called
   <i>
    heap identifiers
   </i>
   , which are not generally accessible (or useful) to the IDL user. The unique integers used to identify heap variables are assigned by IDL when the variables are created, and are therefore only unique within that IDL session. A given heap variable will typically have completely different identifiers in two different IDL sessions.
  </p>
  <p>
   When RESTORE later restores variables containing object or pointer references, the heap variables are likewise restored. Note, however, that the unique identifiers for the restored heap variables will be different from the identifiers they had in the IDL session in which the SAVE file was created. RESTORE handles the mapping of the old identifiers to the new ones internally, in a manner that is completely transparent to the IDL user. This allows the user to save and restore very complex data structures using the simple interface provided by the SAVE and RESTORE procedures.
  </p>
  <p>
   Notice that when using SAVE and RESTORE, the user always deals with regular named variables. Heap variables are never explicitly saved or restored; they are referenced only indirectly, through the regular variables that refer to them. Working with restored heap variables directly would be inconvenient, because heap variables lack mnemonic names that allow for easy identification, and because the original integer identifiers assigned by IDL when the heap variables were created have no meaning in the IDL session into which the variables are restored.
  </p>
  <p>
   The IDL_Savefile::Restore method duplicates the behavior of the RESTORE procedure with regard to heap variables. That is, when a regular IDL variable that refers to a pointer or object heap variable is restored, the heap variable is also restored automatically. In addition, although it is rarely (if ever) useful, the IDL_Savefile::Restore method provides the ability to restore heap variables
   <i>
    without
   </i>
   restoring the IDL variables that refer to them. To accomplish this, the IDL_Savefile object allows you to retrieve the integer heap identifiers stored in the SAVE file, using the POINTER_HEAPVAR and OBJECT_HEAPVAR keywords to the Names method. Note that it would be incorrect to treat these identifiers as object or pointer references, because they are not valid references in the restoring IDL session. For this reason, they are reported as simple integer values. They have no special meaning outside of that given to them by the IDL_Savefile object for a given object instance.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   Restoring heap variables independently of regular variables is not recommended; the mechanism is provided only for completeness. See
   <a class="MCXref_Heading_0" href="#objects_misc_904195448_1034949">
    Restoring Heap Variables Directly
   </a>
   , for additional information.
  </p>
  <h3>
   <a name="objects_misc_904195448_1034940">
   </a>
   <a name="objects_misc_904195448_72792">
   </a>
   Caution Regarding Restored Heap Variables
  </h3>
  <p>
   A given instance of an IDL_Savefile object will never restore a given pointer or object heap variable more than once, regardless of the number of pointers or object references that refer to that heap variable. While this reflects the expected behavior of pointers and object references — references to the same underlying quantity should all point to the same heap variable — you must take care in situations in which heap variables can be destroyed during the lifetime of the IDL_Savefile object.
  </p>
  <p>
   To make the implications of this behavior clear, consider an example in which a SAVE file contains two variables, A and B, each of which is a pointer reference to the same underlying pointer heap variable. After instantiating an IDL_Savefile object named
   <span class="Courier">
    obj
   </span>
   that refers to the SAVE file, execute the following IDL commands:
  </p>
  <p class="Code">
   obj-&gt;RESTORE, 'a'
  </p>
  <p class="Code">
   PTR_FREE, a
  </p>
  <p class="Code">
   obj-&gt;RESTORE, 'b'
  </p>
  <p>
   The result is that both restored variables A and B are dangling references to a non-existent heap variable. IDL does not re-create the heap variable when B is restored, because the IDL_Savefile object knows that it already restored it once. The process of freeing the heap variable using the PTR_FREE procedure does not influence the behavior of the IDL_Savefile object — as far as the savefile object is concerned, the heap variable referred to by the variable B has already been restored, and should not be restored again.
  </p>
  <p class="Tip" madcap:autonum="&lt;b&gt;Tip: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Tip:
     </b>
    </span>
   </span>
   To force IDL to create multiple instances of a single saved heap variable, you can create multiple instances of the IDL_Savefile object referring to the same SAVE file, and use each one to create a distinct and separate instance of the heap variable. We caution you that this sort of code can become confusing very quickly.
  </p>
  <h3>
   <a name="objects_misc_904195448_1034949">
   </a>
   <a name="objects_misc_904195448_40751">
   </a>
   Restoring Heap Variables Directly
  </h3>
  <p>
   The IDL_Savefile object is designed to provide a way to query and restore
   <i>
    anything
   </i>
   contained within a SAVE file. As a result, the savefile object provides a mechanism for restoring heap variables independently of any regular IDL variables that may refer to them.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   The ability to directly restore heap variables independently of any referring regular variable is provided for completeness only. Restoring heap variables directly as described in this section is rarely (if ever) useful. The recommended way to restore a heap variable is to restore a regular IDL variable that refers to the heap variable.
  </p>
  <p>
   To restore a heap variable independently of any regular variable, do the following:
  </p>
  <table class="AutoNumber_p_Numbered1" style="width: 100%; margin-left: 0;" cellspacing="0" cellpadding="0">
   <col style="width: 16px;" />
   <col style="width: 24px;" />
   <col style="width: auto;" />
   <tr>
    <td valign="top">
    </td>
    <td class="AutoNumber_p_Numbered1" valign="top">
     <span>
      1.
     </span>
    </td>
    <td class="AutoNumber_p_Numbered1" madcap:autonum="1. " valign="top">
     Use either the POINTER_HEAPVAR or the OBJECT_HEAPVAR keyword (as appropriate) to the IDL_Savefile::Names method to retrieve the integer heap identifier of the heap variable.
    </td>
   </tr>
  </table>
  <table class="AutoNumber_p_Numbered1" style="width: 100%; margin-left: 0;" cellspacing="0" cellpadding="0">
   <col style="width: 16px;" />
   <col style="width: 24px;" />
   <col style="width: auto;" />
   <tr>
    <td valign="top">
    </td>
    <td class="AutoNumber_p_Numbered1" valign="top">
     <span>
      2.
     </span>
    </td>
    <td class="AutoNumber_p_Numbered1" madcap:autonum="2. " valign="top">
     Use either the POINTER_HEAPVAR or the OBJECT_HEAPVAR keyword (as appropriate) and the NEW_HEAPVAR keyword to the IDL_Savefile::Restore method to associate the restored heap variable with a new regular variable.
    </td>
   </tr>
  </table>
  <p>
   The following IDL code provides an example of how this might look:
  </p>
  <p class="Code">
   ; First create a pointer
  </p>
  <p class="Code">
   myPtr = PTR_NEW('99.00')
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Create a SAVE file containing the pointer reference
  </p>
  <p class="Code">
   SAVE, myPtr, FILE='ptr.sav'
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Reset the IDL session
  </p>
  <p class="Code">
   .FULL_RESET_SESSION
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Create a savefile object from the SAVE file
  </p>
  <p class="Code">
   sObj = OBJ_NEW('IDL_Savefile', 'ptr.sav')
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Retrieve the heap identifier of the saved pointer heap variable
  </p>
  <p class="Code">
   ptrName = sObj-&gt;Names(/POINTER_HEAPVAR)
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Restore the heap variable, associating it with a new regular
  </p>
  <p class="Code">
   ; variable. Note that ptrName is (in this case) a one-element array.
  </p>
  <p class="Code">
   sObj-&gt;Restore, ptrName[0], /POINTER_HEAPVAR, NEW_HEAPVAR=myNewPtr
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Code">
   ; Display the contents of the new variable
  </p>
  <p class="Code">
   PRINT, *myNewPtr
  </p>
  <p>
   IDL Prints:
  </p>
  <p class="Code">
   99.00
  </p>
  <p class="Code">
   &#160;
  </p>
  <p class="Tip" madcap:autonum="&lt;b&gt;Tip: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Tip:
     </b>
    </span>
   </span>
   The above example is presented to depict the process of restoring a heap variable directly. It would have been much easier to simply restore the
   <span class="Courier">
    myPtr
   </span>
   variable contained in the SAVE file.
  </p>
  <h2 class="API">
   <a name="objects_misc_904195448_1034981">
   </a>
   <a name="objects_misc_904195448_1034981_PageTOC_IDL_Savefile">
   </a>
   Example
  </h2>
  <p>
   See
   <a class="MCXref_Heading_0" href="IDL_Savefile.html#objects_misc_904195448_1034474">
    Example
   </a>
   for an example that restores variable data.
  </p>
  <h2 class="API">
   <a name="objects_misc_904195448_1034986">
   </a>
   <a name="objects_misc_904195448_1034986_PageTOC_IDL_Savefile">
   </a>
   Version History
  </h2>
  <table style="width: 499px;caption-side: top;mc-table-style: url('../../Resources/TableStyles/VersionTable.css');" cellspacing="0" class="TableStyle_VersionTable">
   <col width="91px" />
   <col width="408px" />
   <tbody>
    <tr>
     <td class="TableStyle_VersionTable_Body_0_0_ColSep">
      <p>
       6.1
      </p>
     </td>
     <td class="TableStyle_VersionTable_Body_0_0_ColEnd">
      <p>
       Introduced
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_VersionTable_Body_0_0_RowEnd_ColSep">
      <p>
       8.0
      </p>
     </td>
     <td class="TableStyle_VersionTable_Body_0_0_RowEnd_ColEnd">
      <p>
       Added NO_COMPILE keyword
      </p>
     </td>
    </tr>
   </tbody>
  </table>
  <div class="mp_footer">
   Copyright ©
   <span class="DocumentTitleCopyrightYear">
    2012
   </span>
   <![CDATA[ ]]>
   <span class="DocumentTitleCopyrightCompanyName">
    Exelis Visual Information Solutions, Inc.
   </span>
   All Rights Reserved.
  </div>
  <script type="text/javascript" src="../../SkinSupport/MadCapBodyEnd.js">
  </script>
 </body>
</html>