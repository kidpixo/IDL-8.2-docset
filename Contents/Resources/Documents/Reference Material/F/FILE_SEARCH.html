<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns:madcap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" madcap:lastblockdepth="2" madcap:lastheight="135.6667" madcap:lastwidth="592" madcap:disablemasterstylesheet="true" madcap:tocpath="Routines (alphabetical)|Routines: F" madcap:medium="non-print" madcap:inpreviewmode="false" madcap:preloadimages="false" madcap:runtimefiletype="Topic" madcap:targettype="WebHelp" lang="en-US" xml:lang="en-US" madcap:pathtohelpsystem="../../../" madcap:helpsystemfilename="idl.xml" madcap:searchtype="Stem">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>
   FILE_SEARCH
  </title>
  <link href="../../SkinSupport/MadCap.css" rel="stylesheet" />
  <link href="../../Resources/TableStyles/Description.css" rel="stylesheet" />
  <link href="../../Resources/TableStyles/VersionTable.css" rel="stylesheet" />
  <link href="../../Resources/Stylesheets/IDL_style.css" rel="stylesheet" />
  <script src="../../SkinSupport/MadCapAll.js" type="text/javascript">
  </script>
 </head>
 <body>
  <p class="MCWebHelpFramesetLink" style="display: none;">
   <a href="../../../idl_CSH.html#Reference Material/F/FILE_SEARCH.html" style="">
    Open topic with navigation
   </a>
  </p>
  <div class="MCBreadcrumbsBox_0">
   <span class="MCBreadcrumbsPrefix">
    <![CDATA[ ]]>
   </span>
   <a class="MCBreadcrumbsLink" href="../../images/ref_part1.html">
    Routines (alphabetical)
   </a>
   <span class="MCBreadcrumbsDivider">
    &gt;
   </span>
   <a class="MCBreadcrumbsLink" href="F_list.html">
    Routines: F
   </a>
   <span class="MCBreadcrumbsDivider">
    &gt;
   </span>
   <span class="MCBreadcrumbs">
    FILE_SEARCH
   </span>
  </div>
  <h1 class="Routine">
   <a name="F_848155245_893545">
   </a>
   <a name="F_848155245_92438">
   </a>
   FILE_SEARCH
  </h1>
  <p madcap:conditions="Reference Material.Online_Help_Only">
   <madcap:conditionaltext madcap:conditions="Reference Material.Online_Help_Only">
    <a class="MCXref_Heading_0" href="#F_848155245_883917">
     Syntax
    </a>
    |
    <a class="MCXref_Heading_0" href="#F_848155245_900740">
     Return Value
    </a>
    |
    <a class="MCXref_Heading_0" href="#F_848155245_883923">
     Arguments
    </a>
    |
    <a class="MCXref_Heading_0" href="#F_848155245_883931">
     Keywords
    </a>
    |
    <a class="MCXref_Heading_0" href="#F_848155245_884160">
     Examples
    </a>
    |
    <a class="MCXref_Heading_0" href="#F_848155245_884196">
     Version History
    </a>
    |
    <a class="MCXref_Heading_0" href="#F_848155245_891292">
     See Also
    </a>
   </madcap:conditionaltext>
  </p>
  <p>
   The
   <a name="kanchor954">
   </a>
   FILE_SEARCH function returns a string array containing the names of all files matching the input path specification. Input path specifications may contain wildcard characters, enabling them to match multiple files.
  </p>
  <p>
   A
   <i>
    relative path
   </i>
   is a path specification that can only be unambiguously interpreted by basing it relative to some other known location. Usually, this location is the current working directory for the process. A
   <i>
    fully qualified path
   </i>
   is a complete and unambiguous path that can be interpreted directly. For example,
   <span class="Courier">
    bin/idl
   </span>
   is a relative path, while
   <span class="Courier">
    /usr/local/exelis/idl/bin/idl
   </span>
   is a fully qualified path. By default, FILE_SEARCH follows the format of the input to decide whether to return relative or fully-qualified paths.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   In most cases, the operation of FILE_SEARCH is straightforward. There are, however, numerous options available; while these options make the routine more powerful, they may also make its behavior less intuitive. Read the keyword descriptions for additional details.
   <br />
   <br />
   In addition, there are platform-specific behaviors of which you should be aware, especially if you work in a multiplatform environment.
  </p>
  <h2 class="API">
   <a name="F_848155245_883917">
   </a>
   <a name="F_848155245_883917_PageTOC_FILE_SEARCH_">
   </a>
   Syntax
  </h2>
  <p class="Syntax">
   <i>
    Result
   </i>
   = FILE_SEARCH(
   <i>
    Path_Specification
   </i>
   )
  </p>
  <p>
   or for recursive searching,
  </p>
  <p class="Syntax">
   <i>
    Result
   </i>
   = FILE_SEARCH(
   <i>
    Dir_Specification
   </i>
   ,
   <i>
    Recur_Pattern
   </i>
   )
  </p>
  <p class="Syntax">
   <span class="Bold">
    Keywords:
   </span>
   [,&#160;
   <a class="MCXref_Heading_0" href="#F_848155245_883932">
    COUNT
   </a>
   =
   <i>
    variable
   </i>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#F_848155245_883934">
    EXPAND_ENVIRONMENT
   </a>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#F_848155245_883941">
    EXPAND_TILDE
   </a>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#F_848155245_883947">
    FOLD_CASE
   </a>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#F_848155245_883949">
    FULLY_QUALIFY_PATH
   </a>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#F_848155245_883957">
    ISSUE_ACCESS_ERROR
   </a>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#F_848155245_883959">
    MARK_DIRECTORY
   </a>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#F_848155245_883965">
    MATCH_ALL_INITIAL_DOT
   </a>
   &#160;|&#160;/
   <a class="MCXref_Heading_0" href="#F_848155245_883967">
    MATCH_INITIAL_DOT
   </a>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#F_848155245_883969">
    NOSORT
   </a>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#F_848155245_883975">
    QUOTE
   </a>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#F_848155245_883984">
    TEST_DIRECTORY
   </a>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#F_848155245_883986">
    TEST_EXECUTABLE
   </a>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#F_848155245_883991">
    TEST_READ
   </a>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#F_848155245_883994">
    TEST_REGULAR
   </a>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#F_848155245_883996">
    TEST_WRITE
   </a>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#F_848155245_883999">
    TEST_ZERO_LENGTH
   </a>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#F_848155245_932747">
    WINDOWS_SHORT_NAMES
   </a>
   &#160;]
  </p>
  <p class="Syntax">
   <span class="Bold">
    UNIX-Only Keywords:
   </span>
   [,&#160;/
   <a class="MCXref_Heading_0" href="#F_848155245_900969">
    TEST_BLOCK_SPECIAL
   </a>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#F_848155245_900971">
    TEST_CHARACTER_SPECIAL
   </a>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#F_848155245_900973">
    TEST_DANGLING_SYMLINK
   </a>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#F_848155245_900983">
    TEST_GROUP
   </a>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#F_848155245_900993">
    TEST_NAMED_PIPE
   </a>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#F_848155245_901003">
    TEST_SETGID
   </a>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#F_848155245_901005">
    TEST_SETUID
   </a>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#F_848155245_901015">
    TEST_SOCKET
   </a>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#F_848155245_901017">
    TEST_STICKY_BIT
   </a>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#F_848155245_901019">
    TEST_SYMLINK
   </a>
   &#160;] [,&#160;/
   <a class="MCXref_Heading_0" href="#F_848155245_901021">
    TEST_USER
   </a>
   &#160;]
  </p>
  <h2 class="API">
   <a name="F_848155245_900740">
   </a>
   <a name="F_848155245_43115">
   </a>
   Return Value
  </h2>
  <p>
   Returns all matched filenames in a string array, one file name per array element. If no files exist with names matching the input arguments, a null scalar string is returned instead of a string array.
  </p>
  <p>
   If the input path is relative, the results will be relative. If the input is fully qualified, the results will also be fully qualified. If you specify the FULLY_QUALIFY_PATH keyword, the results will be fully qualified no matter which form of input is used. FILE_SEARCH returns results based on standard and recursive searches:
  </p>
  <ul>
   <li value="1">
    <span class="Bold">
     Standard:
    </span>
    When called with a single
    <i>
     Path_Specification
    </i>
    argument, FILE_SEARCH returns all files that match that specification. This is the same operation, sometimes referred to as
    <i>
     file globbing
    </i>
    , performed by most operating system command interpreters when wildcard characters are used in file specifications.
   </li>
   <li value="2">
    <span class="Bold">
     Recursive:
    </span>
    When called with two arguments, FILE_SEARCH performs
    <a name="kanchor955">
    </a>
    recursive searching of directory hierarchies. In a recursive search, FILE_SEARCH looks recursively for any and all subdirectories in the file hierarchy rooted at the
    <i>
     Dir_Specification
    </i>
    argument. Within each of these subdirectories
    <a name="kanchor956">
    </a>
    , it returns the names of all files that match the pattern in the
    <i>
     Recur_Pattern
    </i>
    argument. This operation is similar to that performed by the UNIX
    <span class="Courier">
     find(1)
    </span>
    command.
   </li>
  </ul>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   To avoid going into an infinite loop, the FILE_SEARCH routine does not follow symbolic links.
  </p>
  <h2 class="API">
   <a name="F_848155245_883923">
   </a>
   <a name="F_848155245_883923_PageTOC_FILE_SEARCH_">
   </a>
   Arguments
  </h2>
  <p>
   Any of the arguments described in this section can contain wildcard characters.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   Windows platforms have a file name length limit of 260 characters, while Unix platforms have a limit of 1024 characters.
   <i>
    Path_Specification
   </i>
   or
   <i>
    Dir_Specification
   </i>
   values longer than this limit will return an empty string.
  </p>
  <h3 class="Argument">
   Path_Specification
  </h3>
  <p>
   A scalar or array variable of string type, containing file paths to match. If
   <i>
    Path_Specification
   </i>
   is not supplied, or if it is supplied as an empty string, FILE_SEARCH uses a default pattern of
   <span class="Courier">
    '*'
   </span>
   , which matches all files in the current directory.
  </p>
  <h3 class="Argument">
   Dir_Specification
  </h3>
  <p>
   A scalar or array variable of string type, containing directory paths within which FILE_SEARCH will perform recursive searching for files matching the
   <i>
    Recur_Pattern
   </i>
   argument. FILE_SEARCH examines
   <i>
    Dir_Specification
   </i>
   , and any directory found below it, and returns the paths of any files in those directories that match
   <i>
    Recur_Pattern
   </i>
   . If
   <i>
    Dir_Specification
   </i>
   is supplied as an empty string, FILE_SEARCH searches the current directory.
  </p>
  <h3 class="Argument">
   Recur_Pattern
  </h3>
  <p>
   A scalar string containing a pattern for files to match in any of the directories specified by the
   <i>
    Dir_Specification
   </i>
   argument. If
   <i>
    Recur_Pattern
   </i>
   is supplied as an empty string, FILE_SEARCH uses a default pattern of
   <span class="Courier">
    '*'
   </span>
   , which matches all files in the specified directories.
  </p>
  <h2 class="API">
   <a name="F_848155245_883931">
   </a>
   <a name="F_848155245_883931_PageTOC_FILE_SEARCH_">
   </a>
   Keywords
  </h2>
  <h3 class="Keyword">
   <a name="F_848155245_883932">
   </a>
   <a name="F_848155245_883932_Keywords_FILE_SEARCH__">
   </a>
   COUNT
  </h3>
  <p>
   A named variable into which the number of files found is placed. If no files are found, a value of 0 (zero) is returned.
  </p>
  <h3 class="Keyword">
   <a name="F_848155245_883934">
   </a>
   <a name="F_848155245_883934_Keywords_FILE_SEARCH__">
   </a>
   EXPAND_ENVIRONMENT
  </h3>
  <p>
   By default, FILE_SEARCH follows the conventions of the underlying operating system to determine whether it should expand environment variable references in input file specification patterns. The default is to do such expansions under UNIX, and not to do them under Microsoft Windows. The EXPAND_ENVIRONMENT keyword is used to change this behavior. Set it to a non-zero value to cause FILE_SEARCH to perform environment variable expansion on all platforms. Set it to zero to disable such expansion.
  </p>
  <p>
   The syntax for expanding environment variables in an input file pattern is based on that supported by the standard UNIX shell (
   <span class="Courier">
    /bin/sh
   </span>
   ).
  </p>
  <h3 class="Keyword">
   <a name="F_848155245_883941">
   </a>
   <a name="F_848155245_883941_Keywords_FILE_SEARCH__">
   </a>
   EXPAND_TILDE
  </h3>
  <p>
   Users of the UNIX C-shell (
   <span class="Courier">
    /bin/csh
   </span>
   ), and other tools influenced by it, are familiar with the use of a tilde (
   <span class="Courier">
    ~
   </span>
   ) character at the beginning of a path to denote a home directory. A tilde by itself at the beginning of the path (e.g.
   <span class="Courier">
    ~/directory/file
   </span>
   ) is equivalent to the home directory of the user executing the command, while a tilde followed by the name of a user (e.g.
   <span class="Courier">
    ~user/directory/file
   </span>
   ) is expanded to the home directory of the named user.
  </p>
  <p>
   By default, FILE_SEARCH follows the conventions of the underlying operating system in deciding whether to expand a leading tilde or to treat it as a literal character. Hence, the default is to expand the leading tilde under UNIX, and not under Microsoft Windows. The EXPAND_TILDE keyword is used to change this behavior.
  </p>
  <p>
   Set EXPAND_TILDE to 0 (zero) to disable tilde expansion on all platforms. Set it to a non-zero value to enable tilde expansion.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   Under Microsoft Windows, only the plain form of tilde is recognized. Attempts to use the ~user form will cause IDL to issue an error. IDL uses the HOME and HOMEPATH environment variables to obtain a home directory for the current Windows user.
  </p>
  <h3 class="Keyword">
   <a name="F_848155245_883947">
   </a>
   <a name="F_848155245_883947_Keywords_FILE_SEARCH__">
   </a>
   FOLD_CASE
  </h3>
  <p>
   By default, FILE_SEARCH follows the case sensitivity policy of the underlying operating system. By default, matches are case sensitive on UNIX platforms, and case insensitive on Microsoft Windows platforms. The FOLD_CASE keyword is used to change this behavior. Set it to a non-zero value to cause FILE_SEARCH to do all file matching case insensitively. Explicitly set FOLD_CASE equal to zero to cause all file matching to be case sensitive.
  </p>
  <p>
   Maintain the default value of FOLD_CASE, for
   <span class="_Override" style="font-size: 10pt;line-height: 12pt;">
    the following reasons:
   </span>
  </p>
  <ul>
   <li value="1">
    Under UNIX, case-insensitive file searching (that is, setting FOLD_CASE=1) can lead to confusing behavior, since files with the same name in different combinations of upper- and lower-case letters are actually distinct files that can exist simultaneously in the same directory. However, case insensitivity can be useful under UNIX when combined with wildcards in order to find all instances of a given file type without regard to case.
   </li>
  </ul>
  <p class="indent">
   For example, the following will find all files in the current directory that end with a
   <span class="Courier">
    .dat
   </span>
   extension without regard to the case of the extension:
  </p>
  <p class="Code_Indented">
   datafiles = FILE_SEARCH('*.dat', /FOLD_CASE)
  </p>
  <ul>
   <li value="1">
    Under Windows, case-sensitive file searching (that is, setting FOLD_CASE=0) is rarely useful, since files with the same name in different combinations of upper- and lower-case letters cannot exist simultaneously in the same directory, and a case-insensitive search will return any version.
   </li>
  </ul>
  <h3 class="Keyword">
   <a name="F_848155245_883949">
   </a>
   <a name="F_848155245_883949_Keywords_FILE_SEARCH__">
   </a>
   FULLY_QUALIFY_PATH
  </h3>
  <p>
   If set, FILE_SEARCH expands all returned file paths so that they are complete. Under UNIX, this means that all files are specified relative to the root of the file system. On Windows platforms, it means that all files are specified relative to the drive on which they are located. By default, FILE_SEARCH returns fully qualified paths when the input specification is fully qualified, and returns relative paths otherwise. For example:
  </p>
  <p class="Code">
   CD, '/usr/local/exelis/idl/bin'
   <br />
   PRINT, FILE_SEARCH('idl')
   <br />
  </p>
  <p>
   IDL prints: idl
  </p>
  <p class="Code">
   PRINT, FILE_SEARCH('idl',/FULLY_QUALIFY_PATH)
  </p>
  <p>
   IDL prints: /usr/local/exelis/idl/bin/idl
  </p>
  <p>
   Under Microsoft Windows, any use of a drive letter colon (:) character implies full qualification, even if the path following the colon does not start with a slash character.
  </p>
  <h3 class="Keyword">
   <a name="F_848155245_883957">
   </a>
   <a name="F_848155245_883957_Keywords_FILE_SEARCH__">
   </a>
   ISSUE_ACCESS_ERROR
  </h3>
  <p>
   If the IDL process lacks the necessary permission to access a directory included in the input specification, FILE_SEARCH will normally skip over it quietly and not include it in the generated results. Set ISSUE_ACCESS_ERROR to cause an error to be issued instead.
  </p>
  <h3 class="Keyword">
   <a name="F_848155245_883959">
   </a>
   <a name="F_848155245_883959_Keywords_FILE_SEARCH__">
   </a>
   MARK_DIRECTORY
  </h3>
  <p>
   If set, all directory paths are returned with a path separator character appended to the end. This allows the caller to concatenate a file name directly to the end without having to supply a separator character first. This is convenient for cross-platform programming, as the separator characters differ between operating systems:
  </p>
  <p class="Code">
   PRINT, FILE_SEARCH(!DIR)
  </p>
  <p>
   IDL prints: /usr/local/exelis/idl
  </p>
  <p class="Code">
   PRINT, FILE_SEARCH(!DIR, /MARK_DIRECTORY)
  </p>
  <p>
   IDL prints: /usr/local/exelis/idl/
  </p>
  <h3 class="Keyword">
   <a name="F_848155245_883965">
   </a>
   <a name="F_848155245_883965_Keywords_FILE_SEARCH__">
   </a>
   MATCH_ALL_INITIAL_DOT
  </h3>
  <p>
   By default, wildcards do not match leading dot (.) characters, and FILE_SEARCH does not return the names of files that start with the dot (.) character unless the leading dot is actually contained within the search string. Set MATCH_ALL_INITIAL_DOT to change this policy so that wildcards will match all files starting with a dot, including the special “.” (current directory) and “..” (parent directory) entries. Use the MATCH_INITIAL_DOT keyword instead of MATCH_ALL_INITIAL_DOT for most purposes.
  </p>
  <h3 class="Keyword">
   <a name="F_848155245_883967">
   </a>
   <a name="F_848155245_883967_Keywords_FILE_SEARCH__">
   </a>
   MATCH_INITIAL_DOT
  </h3>
  <p>
   MATCH_INITIAL_DOT serves the same function as MATCH_ALL_INITIAL_DOT, except that the special “.” (current directory) and “..” (parent directory) directories are not included.
  </p>
  <h3 class="Keyword">
   <a name="F_848155245_883969">
   </a>
   <a name="F_848155245_883969_Keywords_FILE_SEARCH__">
   </a>
   NOSORT
  </h3>
  <p>
   Normally, FILE_SEARCH sorts the list of files returned by the operating system in a case-sensitive manner. If the NOSORT keyword is set, FILE_SEARCH will not perform the sort, instead returning exactly what is returned by the underlying operating system calls. On some operating systems, this can make FILE_SEARCH execute faster. The order of the results returned when NOSORT is set depends on the implementation of the operating system, and should not be relied upon.
  </p>
  <h3 class="Keyword">
   <a name="F_848155245_883975">
   </a>
   <a name="F_848155245_883975_Keywords_FILE_SEARCH__">
   </a>
   QUOTE
  </h3>
  <p>
   FILE_SEARCH usually treats all wildcards found in the input specification as having the special meanings described in
   <a class="MCXref_Heading_0" href="#F_848155245_932524" target="" title="" alt="">
    Supported Wildcards and Expansions
   </a>
   . This means that such characters cannot normally be used as plain literal characters in file names. For example, it is not possible to match a file that contains a literal asterisk character in its name because asterisk is interpreted as the “match zero or more characters” wildcard.
  </p>
  <p>
   If the QUOTE keyword is set, the backslash character can be used to escape any character so that it is treated as a plain character with no special meaning. In this mode, FILE_SEARCH replaces any two-character sequence starting with a backslash with the second character of the pair. In the process, any special wildcard meaning that character might have had disappears, and the character is treated as a literal.
  </p>
  <p>
   If QUOTE is set, any literal backslash characters in your path must themselves be escaped with a backslash character. This is especially important for Microsoft Windows users, because the directory separator character for that platform is the backslash. Windows IDL also accepts UNIX-style forward slashes for directory separators, so Windows users have two choices in handling this issue:
  </p>
  <p class="Code">
   Result = FILE_SEARCH('C:\\home\\bob\\\*.dat', /QUOTE)
  </p>
  <p class="Code">
   Result = FILE_SEARCH('C:/home/bob/\*.dat', /QUOTE)
  </p>
  <p>
   On a Windows system, either of these options gives the path to a file named
   <span class="Courier">
    *.dat
   </span>
   .
  </p>
  <h3 class="Keyword">
   <a name="F_848155245_900969">
   </a>
   <a name="F_848155245_900969_Keywords_FILE_SEARCH__">
   </a>
   TEST_BLOCK_SPECIAL
  </h3>
  <p>
   <i>
    This keyword is only available on UNIX platforms.
   </i>
  </p>
  <p>
   Only include a matching file if it is a block special device.
  </p>
  <h3 class="Keyword">
   <a name="F_848155245_900971">
   </a>
   <a name="F_848155245_900971_Keywords_FILE_SEARCH__">
   </a>
   TEST_CHARACTER_SPECIAL
  </h3>
  <p>
   <i>
    This keyword is only available on UNIX platforms.
   </i>
  </p>
  <p>
   Only include a matching file if it is a character special device.
  </p>
  <h3 class="Keyword">
   <a name="F_848155245_900973">
   </a>
   <a name="F_848155245_900973_Keywords_FILE_SEARCH__">
   </a>
   TEST_DANGLING_SYMLINK
  </h3>
  <p>
   <i>
    This keyword is only available on UNIX platforms.
   </i>
  </p>
  <p>
   Only include a matching file if it is a symbolic link that points at a non-existent file.
  </p>
  <h3 class="Keyword">
   <a name="F_848155245_883984">
   </a>
   <a name="F_848155245_883984_Keywords_FILE_SEARCH__">
   </a>
   TEST_DIRECTORY
  </h3>
  <p>
   Only include a matching file if it is a directory.
  </p>
  <h3 class="Keyword">
   <a name="F_848155245_883986">
   </a>
   <a name="F_848155245_883986_Keywords_FILE_SEARCH__">
   </a>
   TEST_EXECUTABLE
  </h3>
  <p>
   Only include a matching file if it is executable. The source of this information differs between operating systems:
  </p>
  <p class="indent">
   <span class="Bold">
    UNIX:
   </span>
   IDL checks the per-file information (the execute bit) maintained by the operating system.
  </p>
  <p class="indent">
   <span class="Bold">
    Microsoft Windows:
   </span>
   The determination is made on the basis of the file name extension (e.g.
   <span class="Courier">
    .exe
   </span>
   ).
  </p>
  <h3 class="Keyword">
   <a name="F_848155245_900983">
   </a>
   <a name="F_848155245_900983_Keywords_FILE_SEARCH__">
   </a>
   TEST_GROUP
  </h3>
  <p>
   <i>
    This keyword is only available on UNIX platforms.
   </i>
  </p>
  <p>
   Only include a matching file if it belongs to the same effective group ID (GID) as the IDL process.
  </p>
  <h3 class="Keyword">
   <a name="F_848155245_900993">
   </a>
   <a name="F_848155245_900993_Keywords_FILE_SEARCH__">
   </a>
   TEST_NAMED_PIPE
  </h3>
  <p>
   <i>
    This keyword is only available on UNIX platforms.
   </i>
  </p>
  <p>
   Only include a matching file if it is a named pipe (fifo) device.
  </p>
  <h3 class="Keyword">
   <a name="F_848155245_883991">
   </a>
   <a name="F_848155245_883991_Keywords_FILE_SEARCH__">
   </a>
   TEST_READ
  </h3>
  <p>
   Only include a matching file if it is readable by the user.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   This keyword does not support Access Control List (ACL) settings for files.
  </p>
  <h3 class="Keyword">
   <a name="F_848155245_883994">
   </a>
   <a name="F_848155245_883994_Keywords_FILE_SEARCH__">
   </a>
   TEST_REGULAR
  </h3>
  <p>
   Only include a matching file if it is a regular disk file and not a directory, pipe, socket, or other special file type.
  </p>
  <h3 class="Keyword">
   <a name="F_848155245_901003">
   </a>
   <a name="F_848155245_901003_Keywords_FILE_SEARCH__">
   </a>
   TEST_SETGID
  </h3>
  <p>
   <i>
    This keyword is only available on UNIX platforms.
   </i>
  </p>
  <p>
   Only include a matching file if it has its Set-Group-ID bit set.
  </p>
  <h3 class="Keyword">
   <a name="F_848155245_901005">
   </a>
   <a name="F_848155245_901005_Keywords_FILE_SEARCH__">
   </a>
   TEST_SETUID
  </h3>
  <p>
   <i>
    This keyword is only available on UNIX platforms.
   </i>
  </p>
  <p>
   Only include a matching file if it has its Set-User-ID bit set.
  </p>
  <h3 class="Keyword">
   <a name="F_848155245_901015">
   </a>
   <a name="F_848155245_901015_Keywords_FILE_SEARCH__">
   </a>
   TEST_SOCKET
  </h3>
  <p>
   <i>
    This keyword is only available on UNIX platforms.
   </i>
  </p>
  <p>
   Only include a matching file if it is a UNIX domain socket.
  </p>
  <h3 class="Keyword">
   <a name="F_848155245_901017">
   </a>
   <a name="F_848155245_901017_Keywords_FILE_SEARCH__">
   </a>
   TEST_STICKY_BIT
  </h3>
  <p>
   <i>
    This keyword is only available on UNIX platforms.
   </i>
  </p>
  <p>
   Only include a matching file if it has its sticky bit set.
  </p>
  <h3 class="Keyword">
   <a name="F_848155245_901019">
   </a>
   <a name="F_848155245_901019_Keywords_FILE_SEARCH__">
   </a>
   TEST_SYMLINK
  </h3>
  <p>
   <i>
    This keyword is only available on UNIX platforms.
   </i>
  </p>
  <p>
   Only include a matching file if it is a symbolic link that points at an existing file.
  </p>
  <h3 class="Keyword">
   <a name="F_848155245_901021">
   </a>
   <a name="F_848155245_901021_Keywords_FILE_SEARCH__">
   </a>
   TEST_USER
  </h3>
  <p>
   <i>
    This keyword is only available on UNIX platforms.
   </i>
  </p>
  <p>
   Only include a matching file if it belongs to the same effective user ID (UID) as the IDL process.
  </p>
  <h3 class="Keyword">
   <a name="F_848155245_883996">
   </a>
   <a name="F_848155245_883996_Keywords_FILE_SEARCH__">
   </a>
   TEST_WRITE
  </h3>
  <p>
   Only include a matching file if it is writable by the user.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   This keyword does not support Access Control List (ACL) settings for files.
  </p>
  <h3 class="Keyword">
   <a name="F_848155245_883999">
   </a>
   <a name="F_848155245_883999_Keywords_FILE_SEARCH__">
   </a>
   TEST_ZERO_LENGTH
  </h3>
  <p>
   Only include a matching file if it has zero length.
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   The length of a directory is highly system-dependent and does not necessarily correspond to the number of files it contains. In particular, it is possible for an empty directory to report a non-zero length. Avoid using the TEST_ZERO_LENGTH keyword on directories, as the information returned cannot be used in a meaningful way.
  </p>
  <h3 class="Keyword">
   <a name="F_848155245_884152_Keywords_FILE_SEARCH__">
   </a>
   <a name="F_848155245_884152_PageTOC_FILE_SEARCH_">
   </a>
   TEST_* Keywords
  </h3>
  <p>
   The keywords with names that start with the TEST_ prefix allow you to filter the list of resulting file paths based on various criteria. If you remove the TEST_ prefix from these keywords, they correspond directly to the same keywords to the FILE_TEST function, and are internally implemented by the same test code. One could therefore use FILE_TEST instead of the TEST_ keywords to FILE_SEARCH. For example, the following statement locates all subdirectories of the current directory:
  </p>
  <p class="Code">
   Result = FILE_SEARCH(/TEST_DIRECTORY)
  </p>
  <p>
   It is equivalent to the following statements, using FILE_TEST:
  </p>
  <p class="Code">
   result = FILE_SEARCH()
  </p>
  <p class="Code">
   idx = where(FILE_TEST(result, /DIRECTORY), count)
  </p>
  <p class="Code">
   result = (count eq 0) ? '' : result[idx]
  </p>
  <p>
   The TEST_* keywords are more succinct, and can be more efficient in the common case in which FILE_SEARCH generates a long list of results, only to have FILE_TEST discard most of them.
  </p>
  <h3 class="Keyword">
   <a name="F_848155245_932747">
   </a>
   <a name="F_848155245_932747_Keywords_FILE_SEARCH__">
   </a>
   <a name="F_848155245_96048">
   </a>
   WINDOWS_SHORT_NAMES
  </h3>
  <p>
   By default, FILE_SEARCH ignores Microsoft Windows 8.3 short names when performing file matching and only considers the real file names. Set the WINDOWS_SHORT_NAMES keyword to change this policy. If this keyword is set, FILE_SEARCH looks at both the real and 8.3 short names associated with each file as it checks for a match. See
   <a class="MCXref_Heading_0" href="#F_848155245_932659" target="" title="" alt="">
    Microsoft Windows “8.3 Short Names”
   </a>
   for more information on this subject. This keyword is quietly ignored on non-Windows platforms.
  </p>
  <p>
   You should be aware that turning on short name support can lead to confusing results. Such use should be considered carefully. For example, consider running the following IDL statement in a directory containing a single file named
   <span class="Courier">
    file_search.html
   </span>
   :
  </p>
  <p class="Code">
   PRINT, FILE_SEARCH('*.htm')
  </p>
  <p>
   Because this statement does not enable short name support, no files matching the specified pattern are found, and IDL does not print any filenames. This is the result most people would expect. If short name support is enabled, however:
  </p>
  <p class="Code">
   PRINT, FILE_SEARCH('*.htm', /WINDOWS_SHORT_NAMES)
  </p>
  <p>
   IDL prints:
  </p>
  <p class="Code">
   file_search.html
  </p>
  <p>
   In this case, IDL checks the short names as well as the real names. The 8.3 short name for
   <span class="Courier">
    file_search.html
   </span>
   will be similar to
   <span class="Courier">
    FILE_S~1.HTM
   </span>
   , which matches the
   <i>
    Path_Specification
   </i>
   . As such, FILE_SEARCH reports the real name for the matched file. This is the correct answer, but probably not the expected result.
  </p>
  <h2 class="API">
   <a name="F_848155245_932524">
   </a>
   <a name="F_848155245_884026_PageTOC_FILE_SEARCH_">
   </a>
   <a name="F_848155245_52207">
   </a>
   Supported Wildc
   <a name="kanchor957">
   </a>
   ards and Expansions
  </h2>
  <p>
   The wildcards understood by FILE_SEARCH are based on those used by the standard UNIX shell
   <span class="Courier">
    /bin/sh
   </span>
   (the
   <span class="Courier">
    ?
   </span>
   ,
   <span class="Courier">
    *
   </span>
   ,
   <span class="Courier">
    [
   </span>
   , and
   <span class="Courier">
    ]
   </span>
   , characters, and environment variables) with some enhancements commonly found in the C-shell
   <span class="Courier">
    /bin/csh
   </span>
   (the
   <span class="Courier">
    ~
   </span>
   ,
   <span class="Courier">
    {
   </span>
   , and
   <span class="Courier">
    }
   </span>
   characters). These wildcards are processed identically across all IDL supported platforms. The supported wildcards are shown in the following table:
  </p>
  <table style="caption-side: bottom;mc-table-style: url('../../Resources/TableStyles/Description.css');margin-left: 0;margin-right: auto;" cellspacing="0" class="TableStyle_Description">
   <caption>
    Supported Wildcards and Expansions
   </caption>
   <col />
   <col />
   <thead>
    <tr>
     <td class="TableStyle_Description_Head_0_0_RowSep_ColSep">
      <p>
       Wildcard
      </p>
     </td>
     <td class="TableStyle_Description_Head_0_0_RowSep_ColEnd">
      <p>
       Description
      </p>
     </td>
    </tr>
   </thead>
   <tbody>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      <p>
       *
      </p>
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      <p>
       Matches any string, including empty strings.
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
      <p>
       ?
      </p>
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
      <p>
       Matches any single character.
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      <p>
       [...]
      </p>
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      <p>
       Matches any one of the enclosed characters. A pair of characters separated by “
       <span class="Courier">
        -
       </span>
       ” matches any character lexically between the pair, inclusive. If the first character following the opening bracket (
       <span class="Courier">
        [
       </span>
       ) is a
       <span class="Courier">
        !
       </span>
       or
       <span class="Courier">
        ^
       </span>
       , any character not enclosed is matched.
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
      <p>
       {
       <i>
        str
       </i>
       ,
       <i>
        str
       </i>
       , ...}
      </p>
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
      <p>
       Expand to each string (or filename-matching pattern) in the comma-separated list.
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      <p>
       ~
      </p>
      <p>
       ~
       <i>
        user
       </i>
      </p>
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      <p>
       If used at start of input file specification, is replaced with the path to the appropriate home directory. See the description of the
       <a class="MCXref_Heading_0" href="#F_848155245_883941">
        EXPAND_TILDE
       </a>
       keyword for details.
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
      <p>
       $
       <i>
        var
       </i>
      </p>
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
      <p>
       Replace with value of the named environment variable. See the description of the
       <a class="MCXref_Heading_0" href="#F_848155245_883934">
        EXPAND_ENVIRONMENT
       </a>
       keyword for full details.
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      <p>
       ${
       <i>
        var
       </i>
       }
      </p>
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      <p>
       Replace ${
       <i>
        var
       </i>
       } with the value of the
       <i>
        var
       </i>
       environment variable. If
       <i>
        var
       </i>
       is not found in the environment, ${
       <i>
        var
       </i>
       } is replaced with an empty string. This format is useful when the environment variable reference sits directly next to unrelated text, as the use of the {} brackets make it possible for IDL to determine where the environment variable ends and the remaining text starts (e.g. ${mydir}other_text).
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
      <p>
       ${
       <i>
        var
       </i>
       :-
       <i>
        alttext
       </i>
       }
      </p>
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
      <p>
       If environment variable
       <i>
        var
       </i>
       is present in the environment and has a non-NULL value, then substitute that value. If
       <i>
        var
       </i>
       is not present, or has a NULL value, then substitute the alternative text (
       <i>
        alttext
       </i>
       ) provided instead.
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowEnd_ColSep">
      <p>
       ${
       <i>
        var
       </i>
       -
       <i>
        alttext
       </i>
       }
      </p>
     </td>
     <td class="TableStyle_Description_Body_0_0_RowEnd_ColEnd">
      <p>
       If environment variable
       <i>
        var
       </i>
       is present in the environment (even if it has a NULL value) then substitute that value. If
       <i>
        var
       </i>
       is not present, then substitute the alternative text (
       <i>
        alttext
       </i>
       ) provided instead.
      </p>
     </td>
    </tr>
   </tbody>
  </table>
  <p>
   These wildcards can appear anywhere in an input file specification, with the following exceptions:
  </p>
  <h3>
   Tilde (~)
  </h3>
  <p>
   The tilde character is only considered to be a wildcard if it is the first character in the input file specification and the
   <a class="MCXref_Heading_0" href="#F_848155245_883941">
    EXPAND_TILDE
   </a>
   keyword is set. Otherwise, it is treated as a regular character.
  </p>
  <h3>
   Initial Dot Character
  </h3>
  <p>
   The default is for wildcards not to match the dot (.) character if it occurs as the first character of a directory or file name. This follows the convention of UNIX shells, which treat such names as hidden files. In order to match such files, you can take any of the following actions:
  </p>
  <p class="Bullet">
   Explicitly include the dot character at the start of your pattern (e.g. “.*”).
  </p>
  <p class="Bullet">
   Specify the
   <a class="MCXref_Heading_0" href="#F_848155245_883967">
    MATCH_INITIAL_DOT
   </a>
   keyword, which changes the dot matching policy so that wildcards will match any names starting with dot (except for the special “.” and “..” directories).
  </p>
  <p class="Bullet">
   Specify the
   <a class="MCXref_Heading_0" href="#F_848155245_883965">
    MATCH_ALL_INITIAL_DOT
   </a>
   keyword, which changes the dot matching policy so that wildcards will match any names starting with dot (including the special “.” and “..” directories).
  </p>
  <h3>
   Microsoft Windows UNC Paths
  </h3>
  <p>
   On a local area network, Microsoft Windows offers an alternative to the drive letter syntax for accessing files. The
   <i>
    Universal Naming Convention
   </i>
   (UNC) allows for specification of paths on other hosts using the syntax:
  </p>
  <p class="Code">
   \\hostname\sharename\dir\dir\...\file
  </p>
  <p>
   UNC paths are distinguished from normal paths by the use of two initial slashes in the path. FILE_SEARCH can process such paths, but wildcard characters are not allowed in the
   <span class="Courier">
    hostname
   </span>
   or
   <span class="Courier">
    sharename
   </span>
   segments. Wildcards are allowed for specifying directories and files. For performance reasons, avoid using the recursive form of FILE_SEARCH with UNC paths on very large directory trees.
  </p>
  <h2 class="API">
   <a name="F_848155245_932592">
   </a>
   <a name="F_848155245_884084_PageTOC_FILE_SEARCH_">
   </a>
   Platform-Specific Filename Matching Issues
  </h2>
  <p>
   When using FILE_SEARCH, you should be aware of the following platform-specific issues.
  </p>
  <h3>
   File Path Syntax
  </h3>
  <p>
   The syntax allowed for file paths differs between operating systems. FILE_SEARCH always processes file paths using the syntax rules for the platform on which the IDL session is running. As a convenience for Microsoft Windows users, Windows IDL accepts UNIX style forward slashes as well as the usual backslashes as path separators.
  </p>
  <h3>
   Differing Defaults Between Platforms
  </h3>
  <p>
   The different operating systems supported by IDL have some conventions for processing file paths that are inherently incompatible. If FILE_SEARCH attempted to force an identical default policy for these features across all platforms, the resulting routine would be inconvenient to use on all platforms. FILE_SEARCH resolves this inherent tension between convenience and control in the following way:
  </p>
  <p class="Bullet">
   These features are controlled by keywords which are listed in the table below. If a keyword is not explicitly specified, FILE_SEARCH will determine an appropriate default for that feature based on the conventions of the underlying operating system. Hence, FILE_SEARCH will by default behave in a way that is reasonable on the platform on which it is used.
  </p>
  <p class="Bullet">
   If one of these keywords is explicitly specified, FILE_SEARCH will use its value to determine support for that feature. Hence, if the keyword is used, FILE_SEARCH will behave identically on all platforms. If maximum cross-platform control is desired, you can achieve it by specifying all the relevant keywords.
  </p>
  <p>
   The keywords that have different defaults on different platforms are listed in the following table:
  </p>
  <table style="caption-side: bottom;mc-table-style: url('../../Resources/TableStyles/Description.css');margin-left: 0;margin-right: auto;" cellspacing="0" class="TableStyle_Description">
   <caption>
    FILE_SEARCH Defaults that Differ Between Platforms
   </caption>
   <col />
   <col />
   <col />
   <col />
   <thead>
    <tr>
     <td class="TableStyle_Description_Head_0_0_RowSep_ColSep">
      <p>
       Wildcard
      </p>
     </td>
     <td class="TableStyle_Description_Head_0_0_RowSep_ColSep">
      <p>
       Keyword
      </p>
     </td>
     <td class="TableStyle_Description_Head_0_0_RowSep_ColSep">
      <p>
       Default
       <br />
       UNIX
      </p>
     </td>
     <td class="TableStyle_Description_Head_0_0_RowSep_ColEnd">
      <p>
       Default
       <br />
       Win
      </p>
     </td>
    </tr>
   </thead>
   <tbody>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      <p>
       $
       <i>
        var
       </i>
       <br />
       ${
       <i>
        var
       </i>
       }
       <br />
       ${
       <i>
        var
       </i>
       :-
       <i>
        alttext
       </i>
       }
       <br />
       ${
       <i>
        var
       </i>
       -
       <i>
        alttext
       </i>
       }
      </p>
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      <p>
       &#160;
      </p>
      <p>
       EXPAND_ENVIRONMENT
      </p>
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColSep">
      <p>
       &#160;
      </p>
      <p>
       yes
      </p>
     </td>
     <td class="TableStyle_Description_Body_0_0_RowSep_ColEnd">
      <p>
       &#160;
      </p>
      <p>
       no
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
      <p>
       ~
      </p>
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
      <p>
       EXPAND_TILDE
      </p>
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColSep">
      <p>
       yes
      </p>
     </td>
     <td class="TableStyle_Description_Body_1_0_RowSep_ColEnd">
      <p>
       no
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_Description_Body_0_0_RowEnd_ColSep">
      <p>
       &#160;
      </p>
     </td>
     <td class="TableStyle_Description_Body_0_0_RowEnd_ColSep">
      <p>
       FOLD_CASE
      </p>
     </td>
     <td class="TableStyle_Description_Body_0_0_RowEnd_ColSep">
      <p>
       no
      </p>
     </td>
     <td class="TableStyle_Description_Body_0_0_RowEnd_ColEnd">
      <p>
       yes
      </p>
     </td>
    </tr>
   </tbody>
  </table>
  <h3>
   <a name="F_848155245_932659">
   </a>
   <a name="F_848155245_77644">
   </a>
   Microsoft Windows “8.3 Short Names”
  </h3>
  <p>
   Older versions of Microsoft operating systems limited files to very short names: up to eight characters were allowed for the file name, followed by a dot (.), followed by an extension of up to three characters. This scheme is often referred to as “8.3 short names” or just “8.3”. Newer releases of the Windows operating system have moved past the 8.3 limits, and allow much longer names. In order to allow old programs from older systems to run on newer systems without first being rebuilt, these newer versions of Windows actually maintain two separate and distinct file names for each file. Every file has, in addition to its real (potentially long) name, an automatically generated “8.3 short name”. If the real name fits within the 8.3 limits, the real and short names are the same. If the real name does not fit within the 8.3 limits, the operating system constructs an 8.3 short name for it by applying a set of heuristic rules (See Microsoft’s documentation for more detail on how these names are constructed). For example, the file
   <span class="Courier">
    file_search.html
   </span>
   will be given a short name that looks something like
   <span class="Courier">
    FILE_S~1.HTM
   </span>
   .
  </p>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   8.3 short names are strictly a Windows backwards compatibility feature, and are not generally useful in newer software.
  </p>
  <p>
   8.3 short names are an issue for FILE_SEARCH if the
   <i>
    Path_Specification
   </i>
   argument includes them. FILE_SEARCH handles this situation using the following rules:
  </p>
  <ol>
   <li value="1">
    Before starting the process of file name matching, FILE_SEARCH examines the portion of
    <i>
     Path_Specification
    </i>
    between the first character and the first wildcard character (or the entire string if there are no wildcards) for non-wildcarded short names. Any such names are replaced by their real names.
   </li>
   <li value="2">
    By default, FILE_SEARCH only considers the real name during the process of matching
    <i>
     Path_Specification
    </i>
    with files, ignoring the 8.3 short names. The
    <a class="MCXref_Heading_0" href="#F_848155245_932747">
     WINDOWS_SHORT_NAMES
    </a>
    keyword can be set to change this policy. If WINDOWS_SHORT_NAMES is set, FILE_SEARCH looks at
    <i>
     both
    </i>
    the real and 8.3 short names associated with each file as it checks for a match.
   </li>
   <li value="3">
    If WINDOWS_SHORT_NAMES is set and FILE_SEARCH matches the 8.3 short name for a file, the real file name is returned. For instance, in the above example if FILE_SEARCH matches
    <span class="Courier">
     FILE_S~1.HTM
    </span>
    , it will return
    <span class="Courier">
     file_search.html
    </span>
    .
   </li>
  </ol>
  <p class="Note" madcap:autonum="&lt;b&gt;Note: &lt;/b&gt;">
   <span class="autonumber">
    <span>
     <b>
      Note:
     </b>
    </span>
   </span>
   Windows 8.3 short names can be very confusing to understand. Avoid them unless absolutely necessary. Most modern applications will not encounter a need to match 8.3 short names.
  </p>
  <h2 class="API">
   <a name="F_848155245_884160">
   </a>
   <a name="F_848155245_884160_PageTOC_FILE_SEARCH_">
   </a>
   Examples
  </h2>
  <h3>
   <a name="F_848155245_884161_Keywords_FILE_SEARCH__">
   </a>
   Example 1
  </h3>
  <p>
   Find all files in the current working directory:
  </p>
  <p class="Code">
   Result = FILE_SEARCH()
  </p>
  <h3>
   <a name="F_848155245_884164_Keywords_FILE_SEARCH__">
   </a>
   Example 2
  </h3>
  <p>
   Find all IDL program (
   <span class="Courier">
    *.pro
   </span>
   ) files in the current working directory:
  </p>
  <p class="Code">
   Result = FILE_SEARCH('*.pro')
  </p>
  <p>
   To determine the number of IDL procedure files that exist in the current directory, use the following statement:
  </p>
  <p class="Code">
   PRINT, '# IDL pro files:',N_ELEMENTS(FILE_SEARCH('*.pro'))
  </p>
  <h3>
   <a name="F_848155245_884167_Keywords_FILE_SEARCH__">
   </a>
   Example 3
  </h3>
  <p>
   Under Microsoft Windows, find all files in the top level directories of all drives other than the floppy drives:
  </p>
  <p class="Code">
   Result=FILE_SEARCH('[!ab]:*')
  </p>
  <p>
   This example relies on the following:
  </p>
  <ul>
   <li value="1">
    FILE_SEARCH allows wildcards within the drive letter part of an input file specification.
   </li>
   <li value="2">
    Drives A and B are always floppies, and are not used by Windows for any other type of drive.
   </li>
  </ul>
  <h3>
   <a name="F_848155245_884173_Keywords_FILE_SEARCH__">
   </a>
   Example 4
  </h3>
  <p>
   Find all files in the user’s home directory that start with the letters A-D. Match both upper and lowercase letters:
  </p>
  <p class="Code">
   Result = FILE_SEARCH('~/[a-d]*', /EXPAND_TILDE, /FOLD_CASE)
  </p>
  <h3>
   <a name="F_848155245_884176_Keywords_FILE_SEARCH__">
   </a>
   Example 5
  </h3>
  <p>
   Find all directories in the user’s home directory that start with the letters A-D. Match both upper and lowercase letters:
  </p>
  <p class="Code">
   Result = FILE_SEARCH('~/[a-d]*', /EXPAND_TILDE, /FOLD_CASE, $
   <br />
   /TEST_DIRECTORY)
  </p>
  <h3>
   <a name="F_848155245_884180_Keywords_FILE_SEARCH__">
   </a>
   Example 6
  </h3>
  <p>
   Recursively find all subdirectories found underneath the user’s home directory that do not start with a dot character:
  </p>
  <p class="Code">
   Result = FILE_SEARCH('$HOME', '*', /EXPAND_ENVIRONMENT, $
   <br />
   /TEST_DIRECTORY)
  </p>
  <h3>
   <a name="F_848155245_884184_Keywords_FILE_SEARCH__">
   </a>
   Example 7
  </h3>
  <p>
   Recursively find all subdirectories found underneath the user’s home directory, including those that start with a dot character, but excluding the special “.” and “..” directories:
  </p>
  <p class="Code">
   Result = FILE_SEARCH('$HOME', '*', /MATCH_INITIAL_DOT, $
   <br />
   /EXPAND_ENVIRONMENT, /TEST_DIRECTORY)
  </p>
  <h3>
   <a name="F_848155245_884188_Keywords_FILE_SEARCH__">
   </a>
   Example 8
  </h3>
  <p>
   Find all
   <span class="Courier">
    .pro
   </span>
   and
   <span class="Courier">
    .sav
   </span>
   files in an IDL library search path, sorted by directory, in the order IDL searches for them:
  </p>
  <p class="Code">
   Result = FILE_SEARCH(STRSPLIT(!PATH, PATH_SEP(/SEARCH_PATH), $
   <br />
   &#160;&#160;&#160;/EXTRACT) + '/*.{pro,sav}')
  </p>
  <p>
   Colon (:) is the UNIX path separator character, so the call to
   <span class="_Override" style="font-family: Courier;font-size: 9pt;line-height: 11pt;">
    STRSPLIT
   </span>
   breaks the IDL search path into an array of directories. To each directory name, we concatenate the wildcards necessary to match any .pro or .sav files in that directory. When this array is passed to FILE_SEARCH, it locates all files that match these specifications. FILE_SEARCH sorts all of the files found by each input string. The files for each string are then placed into the output array in the order they were searched for.
  </p>
  <h3>
   <a name="F_848155245_884193_Keywords_FILE_SEARCH__">
   </a>
   Example 9
  </h3>
  <p>
   Recursively find all directories in your IDL distribution:
  </p>
  <p class="Code">
   Result = FILE_SEARCH(!DIR, '*', /TEST_DIRECTORY)
  </p>
  <h3>
   Example 10
  </h3>
  <p>
   Under Microsoft Windows, FILE_SEARCH can be used to convert a path that uses 8.3 short names into an equivalent path that uses the real names. For example, Windows provides a directory for each user where applications are expected to create temporary files. Consider a user of Windows named Scott. The short name for Scott’s temporary directory (which is usually available via the Windows “Temp” environment variable) will typically be something like
   <span class="Courier">
    C:\DOCUME~1\scott\LOCALS~1\Temp
   </span>
   . This can be converted to real names using a statement like the following:
  </p>
  <p class="Code">
   PRINT, FILE_SEARCH(GETENV('Temp'))
  </p>
  <p>
   IDL prints:
  </p>
  <p class="Code">
   C:\Documents and Settings\scott\Local Settings\Temp
  </p>
  <p>
   There are some noteworthy facts about this example:
  </p>
  <ol>
   <li value="1">
    Short names are relatively rare in modern Windows systems. Environment variables are one of the few ways in which they are still seen.
   </li>
   <li value="2">
    It was not necessary to specify the WINDOWS_SHORT_NAMES keyword in this example, although it would have been harmless to do so, because the path being converted contains no wildcard characters. FILE_SEARCH will always attempt to convert any non-wildcarded path components at the beginning of the path to their long names before it begins searching.
   </li>
   <li value="3">
    The
    <a class="MCXref_Heading_0" href="../G/GETENV.html#G_845992557_677069" target="" title="" alt="">
     GETENV
    </a>
    function supports a special token (IDL_TMPDIR) that should be used to obtain the directory where temporary files go. This provides a portable cross platform way to find a good temporary directory. Under Windows, GETENV automatically converts the result of translating the IDL_TMPDIR preference to real names in a manner similar to that shown in this example.
   </li>
   <li value="4">
    People find the 8.3 short names confusing, and you may wish to translate them to real names for display purposes. However, most file handling functions and procedures in IDL will accept either without issue. There is little reason to translate them before using them in programs.
   </li>
  </ol>
  <h2 class="API">
   <a name="F_848155245_884196">
   </a>
   <a name="F_848155245_884196_PageTOC_FILE_SEARCH_">
   </a>
   Version History
  </h2>
  <table style="width: 499px;caption-side: top;mc-table-style: url('../../Resources/TableStyles/VersionTable.css');" cellspacing="0" class="TableStyle_VersionTable">
   <col width="91px" />
   <col width="408px" />
   <tbody>
    <tr>
     <td class="TableStyle_VersionTable_Body_0_0_ColSep">
      <p>
       5.5
      </p>
     </td>
     <td class="TableStyle_VersionTable_Body_0_0_ColEnd">
      <p>
       Introduced
      </p>
     </td>
    </tr>
    <tr>
     <td class="TableStyle_VersionTable_Body_0_0_RowEnd_ColSep">
      <p>
       6.1
      </p>
     </td>
     <td class="TableStyle_VersionTable_Body_0_0_RowEnd_ColEnd">
      <p>
       Added WINDOWS_SHORT_NAMES keyword
      </p>
     </td>
    </tr>
   </tbody>
  </table>
  <h2 class="API">
   <a name="F_848155245_891292">
   </a>
   <a name="F_848155245_891292_PageTOC_FILE_SEARCH_">
   </a>
   See Also
  </h2>
  <p>
   <a class="MCXref_Heading_0" href="FILE_TEST.html#F_848155245_882359">
    FILE_TEST
   </a>
   ,
   <a class="MCXref_Heading_0" href="FILEPATH.html#F_848155245_877311">
    FILEPATH
   </a>
   ,
   <a class="MCXref_Heading_0" href="../G/GETENV.html#G_845992557_677069" target="" title="" alt="">
    GETENV
   </a>
   ,
   <a class="MCXref_Heading_0" href="../Functional List of IDL Routines/Input_Output.html#funclisting_2438760872_1213961" target="" title="" alt="">
    General File Access
   </a>
  </p>
  <div class="mp_footer">
   Copyright ©
   <span class="DocumentTitleCopyrightYear">
    2012
   </span>
   <![CDATA[ ]]>
   <span class="DocumentTitleCopyrightCompanyName">
    Exelis Visual Information Solutions, Inc.
   </span>
   All Rights Reserved.
  </div>
  <script type="text/javascript" src="../../SkinSupport/MadCapBodyEnd.js">
  </script>
 </body>
</html>